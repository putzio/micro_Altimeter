
g:\Studia\PUT Rocket LAB\altimetr\Altimetr_SPI\build/Altimetr_SPI.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
__vectors():
../../../../crt1/gcrt1.S:61
       0:	a6 c0       	rjmp	.+332    	; 0x14e <__dtors_end>
       2:	00 00       	nop
../../../../crt1/gcrt1.S:67
       4:	d8 c0       	rjmp	.+432    	; 0x1b6 <__bad_interrupt>
       6:	00 00       	nop
../../../../crt1/gcrt1.S:68
       8:	d6 c0       	rjmp	.+428    	; 0x1b6 <__bad_interrupt>
       a:	00 00       	nop
../../../../crt1/gcrt1.S:69
       c:	d4 c0       	rjmp	.+424    	; 0x1b6 <__bad_interrupt>
       e:	00 00       	nop
../../../../crt1/gcrt1.S:70
      10:	d2 c0       	rjmp	.+420    	; 0x1b6 <__bad_interrupt>
      12:	00 00       	nop
../../../../crt1/gcrt1.S:71
      14:	d0 c0       	rjmp	.+416    	; 0x1b6 <__bad_interrupt>
      16:	00 00       	nop
../../../../crt1/gcrt1.S:72
      18:	ce c0       	rjmp	.+412    	; 0x1b6 <__bad_interrupt>
      1a:	00 00       	nop
../../../../crt1/gcrt1.S:73
      1c:	cc c0       	rjmp	.+408    	; 0x1b6 <__bad_interrupt>
      1e:	00 00       	nop
../../../../crt1/gcrt1.S:74
      20:	ca c0       	rjmp	.+404    	; 0x1b6 <__bad_interrupt>
      22:	00 00       	nop
../../../../crt1/gcrt1.S:75
      24:	c8 c0       	rjmp	.+400    	; 0x1b6 <__bad_interrupt>
      26:	00 00       	nop
../../../../crt1/gcrt1.S:76
      28:	c6 c0       	rjmp	.+396    	; 0x1b6 <__bad_interrupt>
      2a:	00 00       	nop
../../../../crt1/gcrt1.S:77
      2c:	c4 c0       	rjmp	.+392    	; 0x1b6 <__bad_interrupt>
      2e:	00 00       	nop
../../../../crt1/gcrt1.S:78
      30:	c2 c0       	rjmp	.+388    	; 0x1b6 <__bad_interrupt>
      32:	00 00       	nop
../../../../crt1/gcrt1.S:79
      34:	c0 c0       	rjmp	.+384    	; 0x1b6 <__bad_interrupt>
      36:	00 00       	nop
../../../../crt1/gcrt1.S:80
      38:	0c 94 93 0e 	jmp	0x1d26	; 0x1d26 <__vector_14>
../../../../crt1/gcrt1.S:81
      3c:	bc c0       	rjmp	.+376    	; 0x1b6 <__bad_interrupt>
      3e:	00 00       	nop
../../../../crt1/gcrt1.S:82
      40:	ba c0       	rjmp	.+372    	; 0x1b6 <__bad_interrupt>
      42:	00 00       	nop
../../../../crt1/gcrt1.S:83
      44:	0c 94 fd 0d 	jmp	0x1bfa	; 0x1bfa <__vector_17>
../../../../crt1/gcrt1.S:84
      48:	0c 94 f8 0d 	jmp	0x1bf0	; 0x1bf0 <__vector_18>
../../../../crt1/gcrt1.S:85
      4c:	0c 94 02 0e 	jmp	0x1c04	; 0x1c04 <__vector_19>
../../../../crt1/gcrt1.S:86
      50:	b2 c0       	rjmp	.+356    	; 0x1b6 <__bad_interrupt>
      52:	00 00       	nop
../../../../crt1/gcrt1.S:87
      54:	b0 c0       	rjmp	.+352    	; 0x1b6 <__bad_interrupt>
      56:	00 00       	nop
../../../../crt1/gcrt1.S:88
      58:	ae c0       	rjmp	.+348    	; 0x1b6 <__bad_interrupt>
      5a:	00 00       	nop
../../../../crt1/gcrt1.S:89
      5c:	ac c0       	rjmp	.+344    	; 0x1b6 <__bad_interrupt>
      5e:	00 00       	nop
../../../../crt1/gcrt1.S:90
      60:	aa c0       	rjmp	.+340    	; 0x1b6 <__bad_interrupt>
      62:	00 00       	nop
../../../../crt1/gcrt1.S:91
      64:	0c 94 6b 0e 	jmp	0x1cd6	; 0x1cd6 <__vector_25>
../../../../crt1/gcrt1.S:92
      68:	a6 c0       	rjmp	.+332    	; 0x1b6 <__bad_interrupt>
      6a:	00 00       	nop
../../../../crt1/gcrt1.S:93
      6c:	a4 c0       	rjmp	.+328    	; 0x1b6 <__bad_interrupt>
      6e:	00 00       	nop
../../../../crt1/gcrt1.S:94
      70:	a2 c0       	rjmp	.+324    	; 0x1b6 <__bad_interrupt>
      72:	00 00       	nop
../../../../crt1/gcrt1.S:95
      74:	a0 c0       	rjmp	.+320    	; 0x1b6 <__bad_interrupt>
      76:	00 00       	nop
      78:	07 63       	ori	r16, 0x37	; 55
      7a:	42 36       	cpi	r20, 0x62	; 98
      7c:	b7 9b       	sbis	0x16, 7	; 22
      7e:	d8 a7       	std	Y+40, r29	; 0x28
      80:	1a 39       	cpi	r17, 0x9A	; 154
      82:	68 56       	subi	r22, 0x68	; 104
      84:	18 ae       	std	Y+56, r1	; 0x38
      86:	ba ab       	std	Y+50, r27	; 0x32
      88:	55 8c       	ldd	r5, Z+29	; 0x1d
      8a:	1d 3c       	cpi	r17, 0xCD	; 205
      8c:	b7 cc       	rjmp	.-1682   	; 0xfffff9fc <__eeprom_end+0xff7ef9f8>
      8e:	57 63       	ori	r21, 0x37	; 55
      90:	bd 6d       	ori	r27, 0xDD	; 221
      92:	ed fd       	.word	0xfded	; ????
      94:	75 3e       	cpi	r23, 0xE5	; 229
      96:	f6 17       	cp	r31, r22
      98:	72 31       	cpi	r23, 0x12	; 18
      9a:	bf 00       	.word	0x00bf	; ????
      9c:	00 00       	nop
      9e:	80 3f       	cpi	r24, 0xF0	; 240
      a0:	08 00       	.word	0x0008	; ????
      a2:	00 00       	nop
      a4:	be 92       	st	-X, r11
      a6:	24 49       	sbci	r18, 0x94	; 148
      a8:	12 3e       	cpi	r17, 0xE2	; 226
      aa:	ab aa       	std	Y+51, r10	; 0x33
      ac:	aa 2a       	or	r10, r26
      ae:	be cd       	rjmp	.-1156   	; 0xfffffc2c <__eeprom_end+0xff7efc28>
      b0:	cc cc       	rjmp	.-1640   	; 0xfffffa4a <__eeprom_end+0xff7efa46>
      b2:	4c 3e       	cpi	r20, 0xEC	; 236
      b4:	00 00       	nop
      b6:	00 80       	ld	r0, Z
      b8:	be ab       	std	Y+54, r27	; 0x36
      ba:	aa aa       	std	Y+50, r10	; 0x32
      bc:	aa 3e       	cpi	r26, 0xEA	; 234
      be:	00 00       	nop
      c0:	00 00       	nop
      c2:	bf 00       	.word	0x00bf	; ????
      c4:	00 00       	nop
      c6:	80 3f       	cpi	r24, 0xF0	; 240
      c8:	00 00       	nop
      ca:	00 00       	nop
      cc:	00 08       	sbc	r0, r0
      ce:	41 78       	andi	r20, 0x81	; 129
      d0:	d3 bb       	out	0x13, r29	; 19
      d2:	43 87       	std	Z+11, r20	; 0x0b
      d4:	d1 13       	cpse	r29, r17
      d6:	3d 19       	sub	r19, r13
      d8:	0e 3c       	cpi	r16, 0xCE	; 206
      da:	c3 bd       	out	0x23, r28	; 35
      dc:	42 82       	std	Z+2, r4	; 0x02
      de:	ad 2b       	or	r26, r29
      e0:	3e 68       	ori	r19, 0x8E	; 142
      e2:	ec 82       	std	Y+4, r14	; 0x04
      e4:	76 be       	out	0x36, r7	; 54
      e6:	d9 8f       	std	Y+25, r29	; 0x19
      e8:	e1 a9       	ldd	r30, Z+49	; 0x31
      ea:	3e 4c       	sbci	r19, 0xCE	; 206
      ec:	80 ef       	ldi	r24, 0xF0	; 240
      ee:	ff be       	out	0x3f, r15	; 63
      f0:	01 c4       	rjmp	.+2050   	; 0x8f4 <SPIClass::endTransaction()+0x8e>
      f2:	ff 7f       	andi	r31, 0xFF	; 255
      f4:	3f 00       	.word	0x003f	; ????
      f6:	00 00       	nop
	...

000000fa <__trampolines_end>:
__trampolines_start():
      fa:	43 6f       	ori	r20, 0xF3	; 243
      fc:	75 6c       	ori	r23, 0xC5	; 197
      fe:	64 20       	and	r6, r4
     100:	6e 6f       	ori	r22, 0xFE	; 254
     102:	74 20       	and	r7, r4
     104:	66 69       	ori	r22, 0x96	; 150
     106:	6e 64       	ori	r22, 0x4E	; 78
     108:	20 61       	ori	r18, 0x10	; 16
     10a:	20 76       	andi	r18, 0x60	; 96
     10c:	61 6c       	ori	r22, 0xC1	; 193
     10e:	69 64       	ori	r22, 0x49	; 73
     110:	20 42       	sbci	r18, 0x20	; 32
     112:	4d 50       	subi	r20, 0x0D	; 13
     114:	32 38       	cpi	r19, 0x82	; 130
     116:	30 20       	and	r3, r0
     118:	73 65       	ori	r23, 0x53	; 83
     11a:	6e 73       	andi	r22, 0x3E	; 62
     11c:	6f 72       	andi	r22, 0x2F	; 47
     11e:	2c 20       	and	r2, r12
     120:	63 68       	ori	r22, 0x83	; 131
     122:	65 63       	ori	r22, 0x35	; 53
     124:	6b 20       	and	r6, r11
     126:	77 69       	ori	r23, 0x97	; 151
     128:	72 69       	ori	r23, 0x92	; 146
     12a:	6e 67       	ori	r22, 0x7E	; 126
     12c:	20 6f       	ori	r18, 0xF0	; 240
     12e:	72 20       	and	r7, r2
     130:	74 72       	andi	r23, 0x24	; 36
     132:	79 20       	and	r7, r9
     134:	61 20       	and	r6, r1
     136:	64 69       	ori	r22, 0x94	; 148
     138:	66 66       	ori	r22, 0x66	; 102
     13a:	65 72       	andi	r22, 0x25	; 37
     13c:	65 6e       	ori	r22, 0xE5	; 229
     13e:	74 20       	and	r7, r4
     140:	61 64       	ori	r22, 0x41	; 65
     142:	64 72       	andi	r22, 0x24	; 36
     144:	65 73       	andi	r22, 0x35	; 53
     146:	73 21       	and	r23, r3
	...

0000014a <__ctors_start>:
__ctors_start():
     14a:	2d 0f       	add	r18, r29

0000014c <__ctors_end>:
__dtors_start():
     14c:	92 12       	cpse	r9, r18

0000014e <__dtors_end>:
__dtors_end():
../../../../crt1/gcrt1.S:230
     14e:	11 24       	eor	r1, r1
../../../../crt1/gcrt1.S:231
     150:	1f be       	out	0x3f, r1	; 63
../../../../crt1/gcrt1.S:232
     152:	cf ef       	ldi	r28, 0xFF	; 255
../../../../crt1/gcrt1.S:234
     154:	cd bf       	out	0x3d, r28	; 61
../../../../crt1/gcrt1.S:236
     156:	df e3       	ldi	r29, 0x3F	; 63
../../../../crt1/gcrt1.S:237
     158:	de bf       	out	0x3e, r29	; 62

0000015a <_initThreeStuff()>:
_Z15_initThreeStuffv():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/main.cpp:95
 * (many are available reasonably cheaply on aliexpress et al.) end up being very useful        *
 * for this sort of thing.                                                                      */

  void __attribute__((weak)) init_reset_flags();
  void __attribute__((weak)) init_reset_flags() {
    uint8_t flags = RSTCTRL.RSTFR;
     15a:	80 91 40 00 	lds	r24, 0x0040	; 0x800040 <vtable for Adafruit_BMP280_Temp+0x7f4c7a>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/main.cpp:96
    RSTCTRL.RSTFR = flags;
     15e:	80 93 40 00 	sts	0x0040, r24	; 0x800040 <vtable for Adafruit_BMP280_Temp+0x7f4c7a>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/main.cpp:97
    if (flags == 0) {
     162:	81 11       	cpse	r24, r1
     164:	05 c0       	rjmp	.+10     	; 0x170 <_initThreeStuff()+0x16>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/main.cpp:98
      _PROTECTED_WRITE(RSTCTRL.SWRR, 1);
     166:	98 ed       	ldi	r25, 0xD8	; 216
     168:	21 e0       	ldi	r18, 0x01	; 1
     16a:	94 bf       	out	0x34, r25	; 52
     16c:	20 93 41 00 	sts	0x0041, r18	; 0x800041 <vtable for Adafruit_BMP280_Temp+0x7f4c7b>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/main.cpp:100
    }
    GPIOR0 = flags;
     170:	8c bb       	out	0x1c, r24	; 28

00000172 <__do_clear_bss>:
__do_clear_bss():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2441
     172:	29 e3       	ldi	r18, 0x39	; 57
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2442
     174:	a6 e0       	ldi	r26, 0x06	; 6
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2443
     176:	b8 e3       	ldi	r27, 0x38	; 56
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2444
     178:	01 c0       	rjmp	.+2      	; 0x17c <.do_clear_bss_start>

0000017a <.do_clear_bss_loop>:
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2446
     17a:	1d 92       	st	X+, r1

0000017c <.do_clear_bss_start>:
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2448
     17c:	aa 33       	cpi	r26, 0x3A	; 58
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2449
     17e:	b2 07       	cpc	r27, r18
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2450
     180:	e1 f7       	brne	.-8      	; 0x17a <.do_clear_bss_loop>

00000182 <__do_copy_data>:
__do_copy_data():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2409
     182:	18 e3       	ldi	r17, 0x38	; 56
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2410
     184:	a0 e0       	ldi	r26, 0x00	; 0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2411
     186:	b8 e3       	ldi	r27, 0x38	; 56
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2412
     188:	ee e0       	ldi	r30, 0x0E	; 14
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2413
     18a:	f4 e3       	ldi	r31, 0x34	; 52
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2414
     18c:	02 c0       	rjmp	.+4      	; 0x192 <__do_copy_data+0x10>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2417
     18e:	05 90       	lpm	r0, Z+
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2422
     190:	0d 92       	st	X+, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2424
     192:	a6 30       	cpi	r26, 0x06	; 6
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2425
     194:	b1 07       	cpc	r27, r17
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2426
     196:	d9 f7       	brne	.-10     	; 0x18e <__do_copy_data+0xc>

00000198 <__do_global_ctors>:
__do_global_ctors():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2466
     198:	10 e0       	ldi	r17, 0x00	; 0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2467
     19a:	c6 ea       	ldi	r28, 0xA6	; 166
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2468
     19c:	d0 e0       	ldi	r29, 0x00	; 0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2472
     19e:	04 c0       	rjmp	.+8      	; 0x1a8 <__do_global_ctors+0x10>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2474
     1a0:	21 97       	sbiw	r28, 0x01	; 1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2480
     1a2:	fe 01       	movw	r30, r28
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2481
     1a4:	0e 94 55 18 	call	0x30aa	; 0x30aa <__tablejump2__>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2483
     1a8:	c5 3a       	cpi	r28, 0xA5	; 165
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2484
     1aa:	d1 07       	cpc	r29, r17
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2489
     1ac:	c9 f7       	brne	.-14     	; 0x1a0 <__do_global_ctors+0x8>
../../../../crt1/gcrt1.S:314
     1ae:	0e 94 21 10 	call	0x2042	; 0x2042 <main>
../../../../crt1/gcrt1.S:315
     1b2:	0c 94 9e 19 	jmp	0x333c	; 0x333c <__do_global_dtors>

000001b6 <__bad_interrupt>:
__vector_22():
../../../../crt1/gcrt1.S:209
     1b6:	24 cf       	rjmp	.-440    	; 0x0 <__vectors>

000001b8 <NotifyUser_onReceive.constprop.5>:
NotifyUser_onReceive.constprop.5():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:762
      uint8_t* rxHead   = &(_data->_bytesToReadWrite);
    #else                                           // Separate tx/rx Buffers
      uint8_t* rxHead   = &(_data->_bytesToRead);
    #endif
  #endif
  if (_data->user_onReceive != NULL) {
     1b8:	e0 91 c5 38 	lds	r30, 0x38C5	; 0x8038c5 <Wire+0x16>
     1bc:	f0 91 c6 38 	lds	r31, 0x38C6	; 0x8038c6 <Wire+0x17>
     1c0:	30 97       	sbiw	r30, 0x00	; 0
     1c2:	31 f0       	breq	.+12     	; 0x1d0 <NotifyUser_onReceive.constprop.5+0x18>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:763
    if ((*rxHead) > 0) {
     1c4:	80 91 c0 38 	lds	r24, 0x38C0	; 0x8038c0 <Wire+0x11>
     1c8:	88 23       	and	r24, r24
     1ca:	11 f0       	breq	.+4      	; 0x1d0 <NotifyUser_onReceive.constprop.5+0x18>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:764
      _data->user_onReceive((*rxHead));
     1cc:	90 e0       	ldi	r25, 0x00	; 0
     1ce:	09 94       	ijmp
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:767
    }
  }
}
     1d0:	08 95       	ret

000001d2 <Print::write(unsigned char const*, unsigned int)>:
_ZN5Print5writeEPKhj():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:29
#include "Print.h"

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size) {
     1d2:	af 92       	push	r10
     1d4:	bf 92       	push	r11
     1d6:	cf 92       	push	r12
     1d8:	df 92       	push	r13
     1da:	ef 92       	push	r14
     1dc:	ff 92       	push	r15
     1de:	0f 93       	push	r16
     1e0:	1f 93       	push	r17
     1e2:	cf 93       	push	r28
     1e4:	df 93       	push	r29
     1e6:	6c 01       	movw	r12, r24
     1e8:	7b 01       	movw	r14, r22
     1ea:	8b 01       	movw	r16, r22
     1ec:	04 0f       	add	r16, r20
     1ee:	15 1f       	adc	r17, r21
     1f0:	eb 01       	movw	r28, r22
     1f2:	5e 01       	movw	r10, r28
     1f4:	ae 18       	sub	r10, r14
     1f6:	bf 08       	sbc	r11, r15
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:31
  size_t n = 0;
  while (size--) {
     1f8:	c0 17       	cp	r28, r16
     1fa:	d1 07       	cpc	r29, r17
     1fc:	59 f0       	breq	.+22     	; 0x214 <Print::write(unsigned char const*, unsigned int)+0x42>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:32
    if (write(*buffer++)) {
     1fe:	69 91       	ld	r22, Y+
     200:	d6 01       	movw	r26, r12
     202:	ed 91       	ld	r30, X+
     204:	fc 91       	ld	r31, X
     206:	01 90       	ld	r0, Z+
     208:	f0 81       	ld	r31, Z
     20a:	e0 2d       	mov	r30, r0
     20c:	c6 01       	movw	r24, r12
     20e:	09 95       	icall
     210:	89 2b       	or	r24, r25
     212:	79 f7       	brne	.-34     	; 0x1f2 <Print::write(unsigned char const*, unsigned int)+0x20>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:39
    } else {
      break;
    }
  }
  return n;
}
     214:	c5 01       	movw	r24, r10
     216:	df 91       	pop	r29
     218:	cf 91       	pop	r28
     21a:	1f 91       	pop	r17
     21c:	0f 91       	pop	r16
     21e:	ff 90       	pop	r15
     220:	ef 90       	pop	r14
     222:	df 90       	pop	r13
     224:	cf 90       	pop	r12
     226:	bf 90       	pop	r11
     228:	af 90       	pop	r10
     22a:	08 95       	ret

0000022c <UartClass::availableForWrite()>:
_ZN9UartClass17availableForWriteEv():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:642
  int UartClass::availableForWrite(void) {
    tx_buffer_index_t head;
    tx_buffer_index_t tail;

    TX_BUFFER_ATOMIC {
      head = _tx_buffer_head;
     22c:	fc 01       	movw	r30, r24
     22e:	53 89       	ldd	r21, Z+19	; 0x13
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:643
      tail = _tx_buffer_tail;
     230:	44 89       	ldd	r20, Z+20	; 0x14
     232:	25 2f       	mov	r18, r21
     234:	30 e0       	ldi	r19, 0x00	; 0
     236:	84 2f       	mov	r24, r20
     238:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:646
    }
    if (head >= tail) {
      return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
     23a:	82 1b       	sub	r24, r18
     23c:	93 0b       	sbc	r25, r19
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:645

    TX_BUFFER_ATOMIC {
      head = _tx_buffer_head;
      tail = _tx_buffer_tail;
    }
    if (head >= tail) {
     23e:	54 17       	cp	r21, r20
     240:	10 f0       	brcs	.+4      	; 0x246 <UartClass::availableForWrite()+0x1a>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:646
      return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
     242:	cf 96       	adiw	r24, 0x3f	; 63
     244:	08 95       	ret
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:648
    }
    return tail - head - 1;
     246:	01 97       	sbiw	r24, 0x01	; 1
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:649
  }
     248:	08 95       	ret

0000024a <UartClass::read()>:
_ZN9UartClass4readEv():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:626
    } else {
      return _rx_buffer[_rx_buffer_tail];
    }
  }

  int UartClass::read(void) {
     24a:	fc 01       	movw	r30, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:628
    // if the head isn't ahead of the tail, we don't have any characters
    if (_rx_buffer_head == _rx_buffer_tail) {
     24c:	91 89       	ldd	r25, Z+17	; 0x11
     24e:	82 89       	ldd	r24, Z+18	; 0x12
     250:	98 17       	cp	r25, r24
     252:	61 f0       	breq	.+24     	; 0x26c <UartClass::read()+0x22>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:631
      return -1;
    } else {
      unsigned char c = _rx_buffer[_rx_buffer_tail];
     254:	a2 89       	ldd	r26, Z+18	; 0x12
     256:	ae 0f       	add	r26, r30
     258:	bf 2f       	mov	r27, r31
     25a:	b1 1d       	adc	r27, r1
     25c:	55 96       	adiw	r26, 0x15	; 21
     25e:	8c 91       	ld	r24, X
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:632
      _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) & (SERIAL_RX_BUFFER_SIZE - 1); // % SERIAL_RX_BUFFER_SIZE;
     260:	92 89       	ldd	r25, Z+18	; 0x12
     262:	9f 5f       	subi	r25, 0xFF	; 255
     264:	9f 73       	andi	r25, 0x3F	; 63
     266:	92 8b       	std	Z+18, r25	; 0x12
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:633
      return c;
     268:	90 e0       	ldi	r25, 0x00	; 0
     26a:	08 95       	ret
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:629
  }

  int UartClass::read(void) {
    // if the head isn't ahead of the tail, we don't have any characters
    if (_rx_buffer_head == _rx_buffer_tail) {
      return -1;
     26c:	8f ef       	ldi	r24, 0xFF	; 255
     26e:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:635
    } else {
      unsigned char c = _rx_buffer[_rx_buffer_tail];
      _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) & (SERIAL_RX_BUFFER_SIZE - 1); // % SERIAL_RX_BUFFER_SIZE;
      return c;
    }
  }
     270:	08 95       	ret

00000272 <UartClass::peek()>:
_ZN9UartClass4peekEv():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:618
}
  int UartClass::available(void) {
    return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) & (SERIAL_RX_BUFFER_SIZE - 1); //% SERIAL_RX_BUFFER_SIZE;
  }

  int UartClass::peek(void) {
     272:	fc 01       	movw	r30, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:619
    if (_rx_buffer_head == _rx_buffer_tail) {
     274:	91 89       	ldd	r25, Z+17	; 0x11
     276:	82 89       	ldd	r24, Z+18	; 0x12
     278:	98 17       	cp	r25, r24
     27a:	31 f0       	breq	.+12     	; 0x288 <UartClass::peek()+0x16>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:622
      return -1;
    } else {
      return _rx_buffer[_rx_buffer_tail];
     27c:	82 89       	ldd	r24, Z+18	; 0x12
     27e:	e8 0f       	add	r30, r24
     280:	f1 1d       	adc	r31, r1
     282:	85 89       	ldd	r24, Z+21	; 0x15
     284:	90 e0       	ldi	r25, 0x00	; 0
     286:	08 95       	ret
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:620
    return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) & (SERIAL_RX_BUFFER_SIZE - 1); //% SERIAL_RX_BUFFER_SIZE;
  }

  int UartClass::peek(void) {
    if (_rx_buffer_head == _rx_buffer_tail) {
      return -1;
     288:	8f ef       	ldi	r24, 0xFF	; 255
     28a:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:624
    } else {
      return _rx_buffer[_rx_buffer_tail];
    }
  }
     28c:	08 95       	ret

0000028e <UartClass::available()>:
_ZN9UartClass9availableEv():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:614

  // Note: Does not change output pins
  // though the datasheetsays turning the TX module sets it to input.
  _state = 0;
}
  int UartClass::available(void) {
     28e:	fc 01       	movw	r30, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:615
    return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) & (SERIAL_RX_BUFFER_SIZE - 1); //% SERIAL_RX_BUFFER_SIZE;
     290:	91 89       	ldd	r25, Z+17	; 0x11
     292:	22 89       	ldd	r18, Z+18	; 0x12
     294:	89 2f       	mov	r24, r25
     296:	90 e0       	ldi	r25, 0x00	; 0
     298:	80 5c       	subi	r24, 0xC0	; 192
     29a:	9f 4f       	sbci	r25, 0xFF	; 255
     29c:	82 1b       	sub	r24, r18
     29e:	91 09       	sbc	r25, r1
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:616
  }
     2a0:	8f 73       	andi	r24, 0x3F	; 63
     2a2:	99 27       	eor	r25, r25
     2a4:	08 95       	ret

000002a6 <UartClass::end()>:
_ZN9UartClass3endEv():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:598
    pinMode(_usart_pins[muxrow][3], OUTPUT); // make XDIR output.
  }
  */
}

void UartClass::end() {
     2a6:	cf 93       	push	r28
     2a8:	df 93       	push	r29
     2aa:	ec 01       	movw	r28, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:600
  // wait for transmission of outgoing data
  flush();
     2ac:	e8 81       	ld	r30, Y
     2ae:	f9 81       	ldd	r31, Y+1	; 0x01
     2b0:	06 80       	ldd	r0, Z+6	; 0x06
     2b2:	f7 81       	ldd	r31, Z+7	; 0x07
     2b4:	e0 2d       	mov	r30, r0
     2b6:	09 95       	icall
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:603
  // Disable receiver and transmitter as well as the RX complete and the data register empty interrupts.
  // TXCIE only used in half duplex - we can just turn the damned thing off yo!
  volatile USART_t * temp = _hwserial_module; /* compiler does a slightly better job with this. */
     2b8:	ec 85       	ldd	r30, Y+12	; 0x0c
     2ba:	fd 85       	ldd	r31, Y+13	; 0x0d
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:604
  temp -> CTRLB &= 0; //~(USART_RXEN_bm | USART_TXEN_bm);
     2bc:	86 81       	ldd	r24, Z+6	; 0x06
     2be:	16 82       	std	Z+6, r1	; 0x06
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:605
  temp -> CTRLA &= 0; //~(USART_RXCIE_bm | USART_DREIE_bm | USART_TXCIE_bm);
     2c0:	85 81       	ldd	r24, Z+5	; 0x05
     2c2:	15 82       	std	Z+5, r1	; 0x05
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:606
  temp -> STATUS =  USART_TXCIF_bm; // want to make sure no chanceofthat firing in error.
     2c4:	80 e4       	ldi	r24, 0x40	; 64
     2c6:	84 83       	std	Z+4, r24	; 0x04
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:608
  // clear any received data
  _rx_buffer_head = _rx_buffer_tail;
     2c8:	8a 89       	ldd	r24, Y+18	; 0x12
     2ca:	89 8b       	std	Y+17, r24	; 0x11
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:612

  // Note: Does not change output pins
  // though the datasheetsays turning the TX module sets it to input.
  _state = 0;
     2cc:	18 8a       	std	Y+16, r1	; 0x10
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:613
}
     2ce:	df 91       	pop	r29
     2d0:	cf 91       	pop	r28
     2d2:	08 95       	ret

000002d4 <UartClass::_poll_tx_data_empty()>:
_ZN9UartClass19_poll_tx_data_emptyEv():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:352
    uartClass._tx_buffer_tail = txTail;
  }
#endif

// To invoke data empty "interrupt" via a call, use this method
void UartClass::_poll_tx_data_empty(void) {
     2d4:	fc 01       	movw	r30, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:353
  if ((!(SREG & CPU_I_bm)) ||  CPUINT.STATUS) {
     2d6:	0f b6       	in	r0, 0x3f	; 63
     2d8:	07 fe       	sbrs	r0, 7
     2da:	04 c0       	rjmp	.+8      	; 0x2e4 <UartClass::_poll_tx_data_empty()+0x10>
     2dc:	80 91 11 01 	lds	r24, 0x0111	; 0x800111 <vtable for Adafruit_BMP280_Temp+0x7f4d4b>
     2e0:	88 23       	and	r24, r24
     2e2:	a9 f0       	breq	.+42     	; 0x30e <_poll_dre_done>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:370
    // so we'll have to poll the "data register empty" flag ourselves.
    // If it is set, pretend an interrupt has happened and call the handler
    // to free up space for us.
    // -Spence 10/23/20
    // Invoke interrupt handler only if conditions data register is empty
    if ((*_hwserial_module).STATUS & USART_DREIF_bm) {
     2e4:	a4 85       	ldd	r26, Z+12	; 0x0c
     2e6:	b5 85       	ldd	r27, Z+13	; 0x0d
     2e8:	14 96       	adiw	r26, 0x04	; 4
     2ea:	8c 91       	ld	r24, X
     2ec:	14 97       	sbiw	r26, 0x04	; 4
     2ee:	85 ff       	sbrs	r24, 5
     2f0:	0e c0       	rjmp	.+28     	; 0x30e <_poll_dre_done>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:371
      if (_tx_buffer_head != _tx_buffer_tail) {
     2f2:	93 89       	ldd	r25, Z+19	; 0x13
     2f4:	84 89       	ldd	r24, Z+20	; 0x14
     2f6:	98 17       	cp	r25, r24
     2f8:	39 f0       	breq	.+14     	; 0x308 <UartClass::_poll_tx_data_empty()+0x34>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:373
        // Buffer empty, so disable "data register empty" interrupt
        (*_hwserial_module).CTRLA &= (~USART_DREIE_bm);
     2fa:	15 96       	adiw	r26, 0x05	; 5
     2fc:	8c 91       	ld	r24, X
     2fe:	15 97       	sbiw	r26, 0x05	; 5
     300:	8f 7d       	andi	r24, 0xDF	; 223
     302:	15 96       	adiw	r26, 0x05	; 5
     304:	8c 93       	st	X, r24
     306:	08 95       	ret
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:397
#ifdef USART1
                ::"z"((uint16_t)thisSerial)
#else
                ::"z"(&Serial)
#endif
                : "r18","r19","r24","r25","r26","r27");
     308:	e8 94       	clt
     30a:	0c 94 0d 0e 	jmp	0x1c1a	; 0x1c1a <_poll_dre>

0000030e <_poll_dre_done>:
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:404
    }
  }
  // In case interrupts are enabled, the interrupt routine will be invoked by itself
  // Note that this currently does not handle cases where the DRE interruopt becomes
  // disabled, yet you are actually attempting to send. I don't think it can happen.
}
     30e:	08 95       	ret

00000310 <UartClass::write(unsigned char)>:
_ZN9UartClass5writeEh():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:682
    // When we get here, nothing is queued anymore (DREIE is disabled) and
    // the hardware finished transmission (TXCIF is set).
  }


  size_t UartClass::write(uint8_t c) {
     310:	0f 93       	push	r16
     312:	1f 93       	push	r17
     314:	cf 93       	push	r28
     316:	df 93       	push	r29
     318:	ec 01       	movw	r28, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:683
    _state |= 1; // Record that we have written to serial since it was begun.
     31a:	88 89       	ldd	r24, Y+16	; 0x10
     31c:	98 2f       	mov	r25, r24
     31e:	91 60       	ori	r25, 0x01	; 1
     320:	98 8b       	std	Y+16, r25	; 0x10
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:688
    // If the buffer and the data register is empty, just write the byte
    // to the data register and be done. This shortcut helps
    // significantly improve the effective data rate at high (>
    // 500kbit/s) bit rates, where interrupt overhead becomes a slowdown.
    if ((_tx_buffer_head == _tx_buffer_tail) && ((*_hwserial_module).STATUS & USART_DREIF_bm)) {
     322:	2b 89       	ldd	r18, Y+19	; 0x13
     324:	9c 89       	ldd	r25, Y+20	; 0x14
     326:	29 13       	cpse	r18, r25
     328:	0a c0       	rjmp	.+20     	; 0x33e <UartClass::write(unsigned char)+0x2e>
     32a:	ec 85       	ldd	r30, Y+12	; 0x0c
     32c:	fd 85       	ldd	r31, Y+13	; 0x0d
     32e:	94 81       	ldd	r25, Z+4	; 0x04
     330:	95 ff       	sbrs	r25, 5
     332:	05 c0       	rjmp	.+10     	; 0x33e <UartClass::write(unsigned char)+0x2e>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:689
      if (_state & 2) { // in half duplex mode, we turn off RXC interrupt
     334:	81 fd       	sbrc	r24, 1
     336:	0d c0       	rjmp	.+26     	; 0x352 <UartClass::write(unsigned char)+0x42>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:696
        ctrla &= ~USART_RXCIE_bm;
        ctrla |=  USART_TXCIE_bm;
        (*_hwserial_module).STATUS = USART_TXCIF_bm;
        (*_hwserial_module).CTRLA = ctrla;
      } else {
        (*_hwserial_module).STATUS = USART_TXCIF_bm;
     338:	80 e4       	ldi	r24, 0x40	; 64
     33a:	84 83       	std	Z+4, r24	; 0x04
     33c:	12 c0       	rjmp	.+36     	; 0x362 <UartClass::write(unsigned char)+0x52>
     33e:	06 2f       	mov	r16, r22
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:714
       * // that the interrupt handler is called in this situation
       * (*_hwserial_module).CTRLA &= (~USART_DREIE_bm);
       */
      return 1;
    }
    tx_buffer_index_t i = (_tx_buffer_head + 1) & (SERIAL_TX_BUFFER_SIZE - 1);  // % SERIAL_TX_BUFFER_SIZE;
     340:	1b 89       	ldd	r17, Y+19	; 0x13
     342:	1f 5f       	subi	r17, 0xFF	; 255
     344:	1f 73       	andi	r17, 0x3F	; 63
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:718

    // If the output buffer is full, there's nothing we can do other than to
    // wait for the interrupt handler to empty it a bit (or emulate interrupts)
    while (i == _tx_buffer_tail) {
     346:	8c 89       	ldd	r24, Y+20	; 0x14
     348:	81 13       	cpse	r24, r17
     34a:	15 c0       	rjmp	.+42     	; 0x376 <UartClass::write(unsigned char)+0x66>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:719
      _poll_tx_data_empty();
     34c:	ce 01       	movw	r24, r28
     34e:	c2 df       	rcall	.-124    	; 0x2d4 <UartClass::_poll_tx_data_empty()>
     350:	fa cf       	rjmp	.-12     	; 0x346 <UartClass::write(unsigned char)+0x36>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:690
    // to the data register and be done. This shortcut helps
    // significantly improve the effective data rate at high (>
    // 500kbit/s) bit rates, where interrupt overhead becomes a slowdown.
    if ((_tx_buffer_head == _tx_buffer_tail) && ((*_hwserial_module).STATUS & USART_DREIF_bm)) {
      if (_state & 2) { // in half duplex mode, we turn off RXC interrupt
        uint8_t ctrla = (*_hwserial_module).CTRLA;
     352:	85 81       	ldd	r24, Z+5	; 0x05
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:691
        ctrla &= ~USART_RXCIE_bm;
     354:	8f 77       	andi	r24, 0x7F	; 127
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:692
        ctrla |=  USART_TXCIE_bm;
     356:	80 64       	ori	r24, 0x40	; 64
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:693
        (*_hwserial_module).STATUS = USART_TXCIF_bm;
     358:	90 e4       	ldi	r25, 0x40	; 64
     35a:	94 83       	std	Z+4, r25	; 0x04
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:694
        (*_hwserial_module).CTRLA = ctrla;
     35c:	ec 85       	ldd	r30, Y+12	; 0x0c
     35e:	fd 85       	ldd	r31, Y+13	; 0x0d
     360:	85 83       	std	Z+5, r24	; 0x05
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:699
      } else {
        (*_hwserial_module).STATUS = USART_TXCIF_bm;
      }
      // MUST clear TXCIF **before** writing new char, otherwise ill-timed interrupt can cause it to erase the flag after the new charchter has been sent!
      (*_hwserial_module).TXDATAL = c;
     362:	ec 85       	ldd	r30, Y+12	; 0x0c
     364:	fd 85       	ldd	r31, Y+13	; 0x0d
     366:	62 83       	std	Z+2, r22	; 0x02
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:734
    } else {
      // Enable "data register empty interrupt"
      (*_hwserial_module).CTRLA |= USART_DREIE_bm;
    }
    return 1;
  }
     368:	81 e0       	ldi	r24, 0x01	; 1
     36a:	90 e0       	ldi	r25, 0x00	; 0
     36c:	df 91       	pop	r29
     36e:	cf 91       	pop	r28
     370:	1f 91       	pop	r17
     372:	0f 91       	pop	r16
     374:	08 95       	ret
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:721
    // If the output buffer is full, there's nothing we can do other than to
    // wait for the interrupt handler to empty it a bit (or emulate interrupts)
    while (i == _tx_buffer_tail) {
      _poll_tx_data_empty();
    }
    _tx_buffer[_tx_buffer_head] = c;
     376:	eb 89       	ldd	r30, Y+19	; 0x13
     378:	ec 0f       	add	r30, r28
     37a:	fd 2f       	mov	r31, r29
     37c:	f1 1d       	adc	r31, r1
     37e:	eb 5a       	subi	r30, 0xAB	; 171
     380:	ff 4f       	sbci	r31, 0xFF	; 255
     382:	00 83       	st	Z, r16
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:722
    _tx_buffer_head = i;
     384:	1b 8b       	std	Y+19, r17	; 0x13
     386:	ec 85       	ldd	r30, Y+12	; 0x0c
     388:	fd 85       	ldd	r31, Y+13	; 0x0d
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:723
    if (_state & 2) { // in half duplex mode, we turn off RXC interrupt
     38a:	88 89       	ldd	r24, Y+16	; 0x10
     38c:	81 ff       	sbrs	r24, 1
     38e:	09 c0       	rjmp	.+18     	; 0x3a2 <UartClass::write(unsigned char)+0x92>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:724
      uint8_t ctrla = (*_hwserial_module).CTRLA;
     390:	85 81       	ldd	r24, Z+5	; 0x05
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:725
      ctrla &= ~USART_RXCIE_bm;
     392:	8f 77       	andi	r24, 0x7F	; 127
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:726
      ctrla |= USART_TXCIE_bm | USART_DREIE_bm;
     394:	80 66       	ori	r24, 0x60	; 96
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:727
      (*_hwserial_module).STATUS = USART_TXCIF_bm;
     396:	90 e4       	ldi	r25, 0x40	; 64
     398:	94 83       	std	Z+4, r25	; 0x04
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:728
      (*_hwserial_module).CTRLA = ctrla;
     39a:	ec 85       	ldd	r30, Y+12	; 0x0c
     39c:	fd 85       	ldd	r31, Y+13	; 0x0d
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:731
    } else {
      // Enable "data register empty interrupt"
      (*_hwserial_module).CTRLA |= USART_DREIE_bm;
     39e:	85 83       	std	Z+5, r24	; 0x05
     3a0:	e3 cf       	rjmp	.-58     	; 0x368 <UartClass::write(unsigned char)+0x58>
     3a2:	85 81       	ldd	r24, Z+5	; 0x05
     3a4:	80 62       	ori	r24, 0x20	; 32
     3a6:	fb cf       	rjmp	.-10     	; 0x39e <UartClass::write(unsigned char)+0x8e>

000003a8 <UartClass::flush()>:
_ZN9UartClass5flushEv():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:651
      return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
    }
    return tail - head - 1;
  }

  void UartClass::flush() {
     3a8:	cf 93       	push	r28
     3aa:	df 93       	push	r29
     3ac:	ec 01       	movw	r28, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:655
    // If we have never written a byte, no need to flush. This special
    // case is needed since there is no way to force the TXCIF (transmit
    // complete) bit to 1 during initialization
    if (!_state & 1) {
     3ae:	88 89       	ldd	r24, Y+16	; 0x10
     3b0:	88 23       	and	r24, r24
     3b2:	59 f0       	breq	.+22     	; 0x3ca <UartClass::flush()+0x22>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:670
    // it's appropriate to use for applications where it has only very small benefits, and significant risk of surprising the user and causing
    // breakage of code that would otherwise work. Finally, the previous implementation didn't check if it was called from the current lvl1 ISR
    // and in that case flush(), and write() with full buffer would just straight up hang...

    // Spin until the data-register-empty-interrupt is disabled and TX complete interrupt flag is raised
    while (((*_hwserial_module).CTRLA & USART_DREIE_bm) || (!((*_hwserial_module).STATUS & USART_TXCIF_bm))) {
     3b4:	ec 85       	ldd	r30, Y+12	; 0x0c
     3b6:	fd 85       	ldd	r31, Y+13	; 0x0d
     3b8:	85 81       	ldd	r24, Z+5	; 0x05
     3ba:	85 fd       	sbrc	r24, 5
     3bc:	03 c0       	rjmp	.+6      	; 0x3c4 <UartClass::flush()+0x1c>
     3be:	84 81       	ldd	r24, Z+4	; 0x04
     3c0:	86 fd       	sbrc	r24, 6
     3c2:	03 c0       	rjmp	.+6      	; 0x3ca <UartClass::flush()+0x22>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:675

      // If interrupts are globally disabled or the and DR empty interrupt is disabled,
      // poll the "data register empty" interrupt flag to prevent deadlock

      _poll_tx_data_empty();
     3c4:	ce 01       	movw	r24, r28
     3c6:	86 df       	rcall	.-244    	; 0x2d4 <UartClass::_poll_tx_data_empty()>
     3c8:	f5 cf       	rjmp	.-22     	; 0x3b4 <UartClass::flush()+0xc>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:679
    }
    // When we get here, nothing is queued anymore (DREIE is disabled) and
    // the hardware finished transmission (TXCIF is set).
  }
     3ca:	df 91       	pop	r29
     3cc:	cf 91       	pop	r28
     3ce:	08 95       	ret

000003d0 <UartClass::operator bool()>:
_ZN9UartClasscvbEv():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.h:293
    inline   size_t write(unsigned int n)   {return write((uint8_t)n);}
    inline   size_t write(int n)            {return write((uint8_t)n);}
    using Print::write; // pull in write(str) and write(buf, size) from Print
    explicit operator bool() {
      return true;
    }
     3d0:	81 e0       	ldi	r24, 0x01	; 1
     3d2:	08 95       	ret

000003d4 <_delayMicroseconds>:
_delayMicroseconds():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:962
  // we just burned 24 (22) cycles above, remove 3
  us -= 3; // 2 cycles

#elif F_CPU >= 20000000L
  // for a one-microsecond delay, burn 4 clocks and then return
  __asm__ __volatile__ (
     3d4:	00 c0       	rjmp	.+0      	; 0x3d6 <_delayMicroseconds+0x2>
     3d6:	00 00       	nop
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:966
    "rjmp .+0" "\n\t"     // 2 cycles
    "nop" );              // 1 cycle
                          // wait 3 cycles with 2 words
  if (us <= 1) return; //  = 3 cycles, (4 when true)
     3d8:	82 30       	cpi	r24, 0x02	; 2
     3da:	91 05       	cpc	r25, r1
     3dc:	40 f0       	brcs	.+16     	; 0x3ee <_delayMicroseconds+0x1a>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:969
  // the loop takes a 1/2 of a microsecond (10 cycles) per iteration
  // so execute it twice for each microsecond of delay requested.
  us = us << 1; // x2 us, = 2 cycles
     3de:	88 0f       	add	r24, r24
     3e0:	99 1f       	adc	r25, r25
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:972
  // we just burned 21 (23) cycles above, remove 2
  // us is at least 4 so we can subtract 2.
  us -= 2; // 2 cycles
     3e2:	02 97       	sbiw	r24, 0x02	; 2
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:1074
    "rjmp .+0"      "\n\t"            // 2 cycles
    "rjmp .+0"      "\n\t"            // 2 cycles
    "brne 1b" : "=w" (us) : "0" (us)  // 2 cycles
  );
#elif defined(DELAYMICROS_TEN)
  __asm__ __volatile__ (
     3e4:	01 97       	sbiw	r24, 0x01	; 1
     3e6:	00 c0       	rjmp	.+0      	; 0x3e8 <_delayMicroseconds+0x14>
     3e8:	00 c0       	rjmp	.+0      	; 0x3ea <_delayMicroseconds+0x16>
     3ea:	00 c0       	rjmp	.+0      	; 0x3ec <_delayMicroseconds+0x18>
     3ec:	d9 f7       	brne	.-10     	; 0x3e4 <_delayMicroseconds+0x10>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:1116
    "1: sbiw %0, 1" "\n\t"            // 2 cycles
    "brne 1b" : "=w" (us) : "0" (us)  // 2 cycles
  );
#endif
  // return = 4 cycles
}
     3ee:	08 95       	ret

000003f0 <micros>:
micros():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:271
    #else
      uint8_t ticks;
    #endif
    uint8_t flags;
    /* Save current state and disable interrupts */
    uint8_t oldSREG = SREG;
     3f0:	9f b7       	in	r25, 0x3f	; 63
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:272
    cli(); /* INTERRUPTS OFF */
     3f2:	f8 94       	cli
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:282
      TCD0.CTRLE = TCD_SCAPTUREA_bm;
      while (!(TCD0.STATUS & TCD_CMDRDY_bm)); // wait for sync - should be only one iteration of this loop
      flags = TCD0.INTFLAGS;
      ticks = TCD0.CAPTUREA;
    #else
      ticks = _timer->CNT;
     3f4:	e0 91 9a 0a 	lds	r30, 0x0A9A	; 0x800a9a <vtable for Adafruit_BMP280_Temp+0x7f56d4>
     3f8:	f0 91 9b 0a 	lds	r31, 0x0A9B	; 0x800a9b <vtable for Adafruit_BMP280_Temp+0x7f56d5>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:283
      flags = _timer->INTFLAGS;
     3fc:	80 91 96 0a 	lds	r24, 0x0A96	; 0x800a96 <vtable for Adafruit_BMP280_Temp+0x7f56d0>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:293
     * doesn't matter.
     * Get current number of overflows and timer count */
    #if !(defined(MILLIS_USE_TIMERB0) || defined(MILLIS_USE_TIMERB1))
      overflows = timer_overflow_count;
    #else
      overflows = timer_millis;
     400:	20 91 0a 38 	lds	r18, 0x380A	; 0x80380a <timer_millis>
     404:	30 91 0b 38 	lds	r19, 0x380B	; 0x80380b <timer_millis+0x1>
     408:	40 91 0c 38 	lds	r20, 0x380C	; 0x80380c <timer_millis+0x2>
     40c:	50 91 0d 38 	lds	r21, 0x380D	; 0x80380d <timer_millis+0x3>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:296
    #endif
    /* Turn interrupts back on, assuming they were on when micros was called. */
    SREG = oldSREG; /* INTERRUPTS ON */
     410:	9f bf       	out	0x3f, r25	; 63
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:303
      if ((flags & TCD_OVF_bm) && (ticks < 0x07)) {
    #elif defined(MILLIS_USE_TIMERA0)
      ticks = (TIME_TRACKING_TIMER_PERIOD) - ticks;
      if ((flags & TCA_SPLIT_HUNF_bm) && (ticks < 0x4)) {
    #else // timerb
      if ((flags & TCB_CAPT_bm) && !(ticks & 0xFF00)) {
     412:	80 ff       	sbrs	r24, 0
     414:	08 c0       	rjmp	.+16     	; 0x426 <__LOCK_REGION_LENGTH__+0x26>
     416:	cf 01       	movw	r24, r30
     418:	88 27       	eor	r24, r24
     41a:	89 2b       	or	r24, r25
     41c:	21 f4       	brne	.+8      	; 0x426 <__LOCK_REGION_LENGTH__+0x26>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:308
    #endif
      #if ((defined(MILLIS_USE_TIMERB0) || defined(MILLIS_USE_TIMERB1)) && (F_CPU <= 1000000))
        overflows += 2;
      #else
        overflows++;
     41e:	2f 5f       	subi	r18, 0xFF	; 255
     420:	3f 4f       	sbci	r19, 0xFF	; 255
     422:	4f 4f       	sbci	r20, 0xFF	; 255
     424:	5f 4f       	sbci	r21, 0xFF	; 255
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:530
       * 46 replaced with 25 save 21 clocks @ 10 = 2.5 us saved
       * 56 replaced with 27 save 29 clocks @ 20 = 1.5 us saved
       * 66 replaced with 29 save 37 clocks @ 40 = 1 us saved
       */
      #elif (F_CPU == 40000000UL || F_CPU == 20000000UL || F_CPU == 10000000UL || F_CPU == 5000000UL)
        __asm__ __volatile__(
     426:	0f 01       	movw	r0, r30
     428:	16 94       	lsr	r1
     42a:	07 94       	ror	r0
     42c:	16 94       	lsr	r1
     42e:	07 94       	ror	r0
     430:	16 94       	lsr	r1
     432:	07 94       	ror	r0
     434:	f0 01       	movw	r30, r0
     436:	16 94       	lsr	r1
     438:	07 94       	ror	r0
     43a:	16 94       	lsr	r1
     43c:	07 94       	ror	r0
     43e:	e0 19       	sub	r30, r0
     440:	f1 09       	sbc	r31, r1
     442:	16 94       	lsr	r1
     444:	07 94       	ror	r0
     446:	06 94       	lsr	r0
     448:	10 2c       	mov	r1, r0
     44a:	16 94       	lsr	r1
     44c:	16 94       	lsr	r1
     44e:	01 18       	sub	r0, r1
     450:	16 94       	lsr	r1
     452:	16 94       	lsr	r1
     454:	01 0c       	add	r0, r1
     456:	11 24       	eor	r1, r1
     458:	e0 0d       	add	r30, r0
     45a:	f1 1d       	adc	r31, r1
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:567
          "add r0,r1"     "\n\t"  // + ticks >> 8
          "eor r1,r1"     "\n\t"  // restore zero_reg
          "add %A0,r0"    "\n\t"  // add to the shifted ticks
          "adc %B0,r1"    "\n"    // carry
          : "+r" (ticks));        // Do the rest in C
        microseconds = overflows * 1000 + ticks;
     45c:	a8 ee       	ldi	r26, 0xE8	; 232
     45e:	b3 e0       	ldi	r27, 0x03	; 3
     460:	0e 94 08 17 	call	0x2e10	; 0x2e10 <__muluhisi3>
     464:	6e 0f       	add	r22, r30
     466:	7f 1f       	adc	r23, r31
     468:	81 1d       	adc	r24, r1
     46a:	91 1d       	adc	r25, r1
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:656
        microseconds = ((overflows * millisClockCyclesToMicroseconds(TIME_TRACKING_CYCLES_PER_OVF))
                      + (ticks * (millisClockCyclesToMicroseconds(TIME_TRACKING_CYCLES_PER_OVF) / TIME_TRACKING_TIMER_PERIOD)));
      #endif
    #endif // end of timer-specific part of micros calculations
    return microseconds;
  }
     46c:	08 95       	ret

0000046e <delay>:
delay():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:724
        _delay_ms(1);
      }
    }
  }
#elif (PROGMEM_SIZE >= 16384 && !defined(MILLIS_USE_TIMERRTC))
  void delay(uint32_t ms) { /* Interrupts will not prolong this less flash-efficient delay */
     46e:	cf 92       	push	r12
     470:	df 92       	push	r13
     472:	ef 92       	push	r14
     474:	ff 92       	push	r15
     476:	cf 93       	push	r28
     478:	df 93       	push	r29
     47a:	6b 01       	movw	r12, r22
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:725
    uint16_t start = (uint16_t) micros();
     47c:	7c 01       	movw	r14, r24
     47e:	b8 df       	rcall	.-144    	; 0x3f0 <micros>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:727
    while (ms > 0) {
      while (((uint16_t) micros() - start) >= 1000 && ms) {
     480:	eb 01       	movw	r28, r22
     482:	b6 df       	rcall	.-148    	; 0x3f0 <micros>
     484:	6c 1b       	sub	r22, r28
     486:	7d 0b       	sbc	r23, r29
     488:	68 3e       	cpi	r22, 0xE8	; 232
     48a:	73 40       	sbci	r23, 0x03	; 3
     48c:	a0 f0       	brcs	.+40     	; 0x4b6 <delay+0x48>
     48e:	c1 14       	cp	r12, r1
     490:	d1 04       	cpc	r13, r1
     492:	e1 04       	cpc	r14, r1
     494:	f1 04       	cpc	r15, r1
     496:	39 f4       	brne	.+14     	; 0x4a6 <delay+0x38>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:732
        ms-- ;
        start += 1000;
      }
    }
  }
     498:	df 91       	pop	r29
     49a:	cf 91       	pop	r28
     49c:	ff 90       	pop	r15
     49e:	ef 90       	pop	r14
     4a0:	df 90       	pop	r13
     4a2:	cf 90       	pop	r12
     4a4:	08 95       	ret
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:728
#elif (PROGMEM_SIZE >= 16384 && !defined(MILLIS_USE_TIMERRTC))
  void delay(uint32_t ms) { /* Interrupts will not prolong this less flash-efficient delay */
    uint16_t start = (uint16_t) micros();
    while (ms > 0) {
      while (((uint16_t) micros() - start) >= 1000 && ms) {
        ms-- ;
     4a6:	81 e0       	ldi	r24, 0x01	; 1
     4a8:	c8 1a       	sub	r12, r24
     4aa:	d1 08       	sbc	r13, r1
     4ac:	e1 08       	sbc	r14, r1
     4ae:	f1 08       	sbc	r15, r1
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:729
        start += 1000;
     4b0:	c8 51       	subi	r28, 0x18	; 24
     4b2:	dc 4f       	sbci	r29, 0xFC	; 252
     4b4:	e6 cf       	rjmp	.-52     	; 0x482 <delay+0x14>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:726
    }
  }
#elif (PROGMEM_SIZE >= 16384 && !defined(MILLIS_USE_TIMERRTC))
  void delay(uint32_t ms) { /* Interrupts will not prolong this less flash-efficient delay */
    uint16_t start = (uint16_t) micros();
    while (ms > 0) {
     4b6:	c1 14       	cp	r12, r1
     4b8:	d1 04       	cpc	r13, r1
     4ba:	e1 04       	cpc	r14, r1
     4bc:	f1 04       	cpc	r15, r1
     4be:	09 f7       	brne	.-62     	; 0x482 <delay+0x14>
     4c0:	eb cf       	rjmp	.-42     	; 0x498 <delay+0x2a>

000004c2 <TwoWire::flush()>:
_ZN7TwoWire5flushEv():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:153
    _data->_module->SCTRLA  = 0x00;
    _data->_module->MCTRLA  = temp_MCTRLA;
    _data->_module->MSTATUS = 0x01;  // force TWI state machine into idle state
    _data->_module->SCTRLA  = temp_SCTRLA;
  #else
  _data->_module->MCTRLB |= TWI_FLUSH_bm;
     4c2:	dc 01       	movw	r26, r24
     4c4:	1c 96       	adiw	r26, 0x0c	; 12
     4c6:	ed 91       	ld	r30, X+
     4c8:	fc 91       	ld	r31, X
     4ca:	84 81       	ldd	r24, Z+4	; 0x04
     4cc:	88 60       	ori	r24, 0x08	; 8
     4ce:	84 83       	std	Z+4, r24	; 0x04
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:545
 *@return     void
 */
void TwoWire::flush(void) {
  /* Turn off and on TWI module */
  TWI_Flush(&vars);
}
     4d0:	08 95       	ret

000004d2 <TwoWire::peek()>:
_ZN7TwoWire4peekEv():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:523
      rxTail   = &(vars._bytesReadWritten);
      rxBuffer =   vars._trBuffer;
    #else                                        // Separate tx/rx Buffers
      rxHead   = &(vars._bytesToRead);
      rxTail   = &(vars._bytesRead);
      rxBuffer =   vars._rxBuffer;
     4d2:	9c 01       	movw	r18, r24
     4d4:	28 5c       	subi	r18, 0xC8	; 200
     4d6:	3f 4f       	sbci	r19, 0xFF	; 255
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:527
    #endif
  }

  if ((*rxTail) < (*rxHead)) {   // if there are bytes to read
     4d8:	dc 01       	movw	r26, r24
     4da:	52 96       	adiw	r26, 0x12	; 18
     4dc:	ec 91       	ld	r30, X
     4de:	52 97       	sbiw	r26, 0x12	; 18
     4e0:	51 96       	adiw	r26, 0x11	; 17
     4e2:	8c 91       	ld	r24, X
     4e4:	e8 17       	cp	r30, r24
     4e6:	30 f4       	brcc	.+12     	; 0x4f4 <TwoWire::peek()+0x22>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:528
    return rxBuffer[(*rxTail)];
     4e8:	e2 0f       	add	r30, r18
     4ea:	f3 2f       	mov	r31, r19
     4ec:	f1 1d       	adc	r31, r1
     4ee:	80 81       	ld	r24, Z
     4f0:	90 e0       	ldi	r25, 0x00	; 0
     4f2:	08 95       	ret
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:530
  } else {      // No bytes to read
    return -1;
     4f4:	8f ef       	ldi	r24, 0xFF	; 255
     4f6:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:532
  }
}
     4f8:	08 95       	ret

000004fa <TwoWire::read()>:
_ZN7TwoWire4readEv():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:454
 *@param      void
 *
 *@return     int
 *@retval     byte in the buffer or -1 if buffer is empty
 */
int TwoWire::read(void) {
     4fa:	fc 01       	movw	r30, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:475
      rxTail   = &(vars._bytesReadWritten);
      rxBuffer =   vars._trBuffer;
    #else                                        // Separate tx/rx Buffers
      rxHead   = &(vars._bytesToRead);
      rxTail   = &(vars._bytesRead);
      rxBuffer =   vars._rxBuffer;
     4fc:	dc 01       	movw	r26, r24
     4fe:	d8 96       	adiw	r26, 0x38	; 56
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:480
    #endif
  }


  if ((*rxTail) < (*rxHead)) {   // if there are bytes to read
     500:	92 89       	ldd	r25, Z+18	; 0x12
     502:	81 89       	ldd	r24, Z+17	; 0x11
     504:	98 17       	cp	r25, r24
     506:	40 f4       	brcc	.+16     	; 0x518 <TwoWire::read()+0x1e>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:481
    uint8_t c = rxBuffer[(*rxTail)];
     508:	a9 0f       	add	r26, r25
     50a:	b1 1d       	adc	r27, r1
     50c:	2c 91       	ld	r18, X
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:482
    (*rxTail)++;
     50e:	9f 5f       	subi	r25, 0xFF	; 255
     510:	92 8b       	std	Z+18, r25	; 0x12
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:483
    return c;
     512:	82 2f       	mov	r24, r18
     514:	90 e0       	ldi	r25, 0x00	; 0
     516:	08 95       	ret
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:485
  } else {                      // No bytes to read. At this point, rxTail moved up to
    return -1;                  // rxHead. To reset both to 0, a MasterRead or AddrWrite has to be called
     518:	8f ef       	ldi	r24, 0xFF	; 255
     51a:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:487
  }
}
     51c:	08 95       	ret

0000051e <TwoWire::available()>:
_ZN7TwoWire9availableEv():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:423
 *@param      void
 *
 *@return     int
 *@retval     amount of bytes available to read from the host buffer
 */
int TwoWire::available(void) {
     51e:	fc 01       	movw	r30, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:434
  #endif
  {
    #if defined(TWI_MERGE_BUFFERS)                // Same Buffers for tx/rx
      rxHead  = vars._bytesToReadWrite - vars._bytesReadWritten;
    #else                                         // Separate tx/rx Buffers
      rxHead  = vars._bytesToRead - vars._bytesRead;
     520:	81 89       	ldd	r24, Z+17	; 0x11
     522:	92 89       	ldd	r25, Z+18	; 0x12
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:438
    #endif
  }
  return rxHead;
}
     524:	89 1b       	sub	r24, r25
     526:	99 0b       	sbc	r25, r25
     528:	08 95       	ret

0000052a <TwoWire::write(unsigned char const*, unsigned int)>:
_ZN7TwoWire5writeEPKhj():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:399
 *
 *
 *@return     uint8_t
 *@retval     amount of bytes copied
 */
size_t TwoWire::write(const uint8_t *data, size_t quantity) {
     52a:	cf 92       	push	r12
     52c:	df 92       	push	r13
     52e:	ef 92       	push	r14
     530:	ff 92       	push	r15
     532:	0f 93       	push	r16
     534:	1f 93       	push	r17
     536:	cf 93       	push	r28
     538:	6c 01       	movw	r12, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:401
  uint8_t i = 0;  // uint8_t since we don't use bigger buffers
  uint8_t qty = quantity > BUFFER_LENGTH ? BUFFER_LENGTH : quantity; //Don't overfill the buffer.
     53a:	41 32       	cpi	r20, 0x21	; 33
     53c:	51 05       	cpc	r21, r1
     53e:	10 f0       	brcs	.+4      	; 0x544 <TwoWire::write(unsigned char const*, unsigned int)+0x1a>
     540:	40 e2       	ldi	r20, 0x20	; 32
     542:	50 e0       	ldi	r21, 0x00	; 0
     544:	c4 2f       	mov	r28, r20
     546:	7b 01       	movw	r14, r22
     548:	10 e0       	ldi	r17, 0x00	; 0
     54a:	00 e0       	ldi	r16, 0x00	; 0
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:402
  for (; i < qty; i++) {
     54c:	0c 17       	cp	r16, r28
     54e:	80 f4       	brcc	.+32     	; 0x570 <TwoWire::write(unsigned char const*, unsigned int)+0x46>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:403
    if (write(*(data + i)) == 0) break;   // break if buffer full
     550:	d7 01       	movw	r26, r14
     552:	6d 91       	ld	r22, X+
     554:	7d 01       	movw	r14, r26
     556:	d6 01       	movw	r26, r12
     558:	ed 91       	ld	r30, X+
     55a:	fc 91       	ld	r31, X
     55c:	01 90       	ld	r0, Z+
     55e:	f0 81       	ld	r31, Z
     560:	e0 2d       	mov	r30, r0
     562:	c6 01       	movw	r24, r12
     564:	09 95       	icall
     566:	98 01       	movw	r18, r16
     568:	2f 5f       	subi	r18, 0xFF	; 255
     56a:	3f 4f       	sbci	r19, 0xFF	; 255
     56c:	89 2b       	or	r24, r25
     56e:	49 f4       	brne	.+18     	; 0x582 <TwoWire::write(unsigned char const*, unsigned int)+0x58>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:407
  }

  return i;
}
     570:	c8 01       	movw	r24, r16
     572:	cf 91       	pop	r28
     574:	1f 91       	pop	r17
     576:	0f 91       	pop	r16
     578:	ff 90       	pop	r15
     57a:	ef 90       	pop	r14
     57c:	df 90       	pop	r13
     57e:	cf 90       	pop	r12
     580:	08 95       	ret
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:403
 */
size_t TwoWire::write(const uint8_t *data, size_t quantity) {
  uint8_t i = 0;  // uint8_t since we don't use bigger buffers
  uint8_t qty = quantity > BUFFER_LENGTH ? BUFFER_LENGTH : quantity; //Don't overfill the buffer.
  for (; i < qty; i++) {
    if (write(*(data + i)) == 0) break;   // break if buffer full
     582:	89 01       	movw	r16, r18
     584:	e3 cf       	rjmp	.-58     	; 0x54c <TwoWire::write(unsigned char const*, unsigned int)+0x22>

00000586 <TwoWire::write(unsigned char)>:
_ZN7TwoWire5writeEh():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:355
 *
 *
 *@return     uint8_t
 *@retval     1 if successful, 0 if the buffer is full
 */
size_t TwoWire::write(uint8_t data) {
     586:	fc 01       	movw	r30, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:377
    #endif
  }

  /* Put byte in txBuffer */

  if ((*txHead) < BUFFER_LENGTH) {      // while buffer not full, write to it
     588:	a0 89       	ldd	r26, Z+16	; 0x10
     58a:	a0 32       	cpi	r26, 0x20	; 32
     58c:	58 f4       	brcc	.+22     	; 0x5a4 <TwoWire::write(unsigned char)+0x1e>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:378
    txBuffer[(*txHead)] = data;             // Load data into the buffer
     58e:	a8 0f       	add	r26, r24
     590:	b9 2f       	mov	r27, r25
     592:	b1 1d       	adc	r27, r1
     594:	58 96       	adiw	r26, 0x18	; 24
     596:	6c 93       	st	X, r22
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:379
    (*txHead)++;                            // advancing the head
     598:	80 89       	ldd	r24, Z+16	; 0x10
     59a:	8f 5f       	subi	r24, 0xFF	; 255
     59c:	80 8b       	std	Z+16, r24	; 0x10
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:380
    return 1;
     59e:	81 e0       	ldi	r24, 0x01	; 1
     5a0:	90 e0       	ldi	r25, 0x00	; 0
     5a2:	08 95       	ret
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:382
  } else {
    return 0;
     5a4:	90 e0       	ldi	r25, 0x00	; 0
     5a6:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:384
  }
}
     5a8:	08 95       	ret

000005aa <Print::availableForWrite()>:
_ZN5Print17availableForWriteEv():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.h:65
      return write((const uint8_t *)buffer, size);
    }

    // default to zero, meaning "a single write may block"
    // should be overridden by subclasses with buffering
    virtual int availableForWrite() { return 0; }
     5aa:	90 e0       	ldi	r25, 0x00	; 0
     5ac:	80 e0       	ldi	r24, 0x00	; 0
     5ae:	08 95       	ret

000005b0 <TWI_MasterRead>:
TWI_MasterRead():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:374
 *            bool send_stop enables the STOP condition at the end of a write
 *
 *@return     uint8_t
 *@retval     amount of bytes that were actually read. If 0, no read took place due to a bus error
 */
uint8_t TWI_MasterRead(struct twiData *_data, uint8_t bytesToRead, bool send_stop) {
     5b0:	1f 93       	push	r17
     5b2:	cf 93       	push	r28
     5b4:	df 93       	push	r29
     5b6:	dc 01       	movw	r26, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:385
    uint8_t* rxHead   = &(_data->_bytesToRead);
    uint8_t* rxTail   = &(_data->_bytesRead);
    uint8_t* rxBuffer =   _data->_rxBuffer;
  #endif

  (*rxTail) = 0;                      // Reset counter
     5b8:	16 96       	adiw	r26, 0x06	; 6
     5ba:	1c 92       	st	X, r1
     5bc:	16 97       	sbiw	r26, 0x06	; 6
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:387

  TWI_t *module = _data->_module;     // Compiler treats the pointer to the TWI module as volatile and
     5be:	ed 91       	ld	r30, X+
     5c0:	fc 91       	ld	r31, X
     5c2:	11 97       	sbiw	r26, 0x01	; 1
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:392
                                      // creates bloat-y code, using a local variable fixes that

  TWIR_INIT_ERROR;             // local variable for errors
  uint8_t dataRead = 0;
  if ((module->MSTATUS & TWI_BUSSTATE_gm) != TWI_BUSSTATE_UNKNOWN_gc) {
     5c4:	85 81       	ldd	r24, Z+5	; 0x05
     5c6:	83 70       	andi	r24, 0x03	; 3
     5c8:	09 f4       	brne	.+2      	; 0x5cc <TWI_MasterRead+0x1c>
     5ca:	41 c0       	rjmp	.+130    	; 0x64e <TWI_MasterRead+0x9e>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:398
    uint8_t currentSM;
    uint8_t currentStatus;
    uint8_t command  = 0;
    uint16_t timeout = 0;

    module->MADDR = ADD_READ_BIT(_data->_clientAddress);  // Send Address with read bit
     5cc:	13 96       	adiw	r26, 0x03	; 3
     5ce:	8c 91       	ld	r24, X
     5d0:	13 97       	sbiw	r26, 0x03	; 3
     5d2:	81 60       	ori	r24, 0x01	; 1
     5d4:	87 83       	std	Z+7, r24	; 0x07
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:396
  uint8_t dataRead = 0;
  if ((module->MSTATUS & TWI_BUSSTATE_gm) != TWI_BUSSTATE_UNKNOWN_gc) {
    uint8_t currentSM;
    uint8_t currentStatus;
    uint8_t command  = 0;
    uint16_t timeout = 0;
     5d6:	30 e0       	ldi	r19, 0x00	; 0
     5d8:	20 e0       	ldi	r18, 0x00	; 0
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:395
  TWIR_INIT_ERROR;             // local variable for errors
  uint8_t dataRead = 0;
  if ((module->MSTATUS & TWI_BUSSTATE_gm) != TWI_BUSSTATE_UNKNOWN_gc) {
    uint8_t currentSM;
    uint8_t currentStatus;
    uint8_t command  = 0;
     5da:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:391

  TWI_t *module = _data->_module;     // Compiler treats the pointer to the TWI module as volatile and
                                      // creates bloat-y code, using a local variable fixes that

  TWIR_INIT_ERROR;             // local variable for errors
  uint8_t dataRead = 0;
     5dc:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:439
            rxBuffer[dataRead] = module->MDATA;      // save byte in the Buffer.
            dataRead++;                              // increment read counter
            timeout = 0;                             // reset timeout

            if (dataRead < bytesToRead) {            // expecting more bytes, so
              module->MCTRLB = TWI_MCMD_RECVTRANS_gc;  // send an ACK so the Slave so it can send the next byte
     5de:	12 e0       	ldi	r17, 0x02	; 2
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:401
    uint16_t timeout = 0;

    module->MADDR = ADD_READ_BIT(_data->_clientAddress);  // Send Address with read bit

    while (true) {
      currentStatus = module->MSTATUS;
     5e0:	55 81       	ldd	r21, Z+5	; 0x05
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:402
      currentSM = currentStatus & TWI_BUSSTATE_gm;  // get the current mode of the state machine
     5e2:	75 2f       	mov	r23, r21
     5e4:	73 70       	andi	r23, 0x03	; 3
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:405

      #if defined(TWI_TIMEOUT_ENABLE)
        if (++timeout > (F_CPU/1000)) {
     5e6:	2f 5f       	subi	r18, 0xFF	; 255
     5e8:	3f 4f       	sbci	r19, 0xFF	; 255
     5ea:	21 32       	cpi	r18, 0x21	; 33
     5ec:	ce e4       	ldi	r28, 0x4E	; 78
     5ee:	3c 07       	cpc	r19, r28
     5f0:	28 f4       	brcc	.+10     	; 0x5fc <TWI_MasterRead+0x4c>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:417
          }
          break;
        }
      #endif

      if (currentStatus & (TWI_ARBLOST_bm | TWI_BUSERR_bm)) {   // Check for Bus error
     5f2:	d5 2f       	mov	r29, r21
     5f4:	dc 70       	andi	r29, 0x0C	; 12
     5f6:	41 f0       	breq	.+16     	; 0x608 <TWI_MasterRead+0x58>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:418
        module->MSTATUS = (TWI_ARBLOST_bm | TWI_BUSERR_bm);     // reset error flags
     5f8:	9c e0       	ldi	r25, 0x0C	; 12
     5fa:	95 83       	std	Z+5, r25	; 0x05
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:458
          TWIR_SET_ERROR(TWI_ERR_RXACK);          // set error flag
          command = TWI_MCMD_STOP_gc;             // free the bus
        }
      }
    }
    (*rxHead) = dataRead;
     5fc:	15 96       	adiw	r26, 0x05	; 5
     5fe:	8c 93       	st	X, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:466
  }
  #if defined(TWI_READ_ERROR_ENABLED) && defined(TWI_ERROR_ENABLED)
    _data->_errors = TWIR_GET_ERROR;                // save error flags
  #endif
  return dataRead;
}
     600:	df 91       	pop	r29
     602:	cf 91       	pop	r28
     604:	1f 91       	pop	r17
     606:	08 95       	ret
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:423
        module->MSTATUS = (TWI_ARBLOST_bm | TWI_BUSERR_bm);     // reset error flags
        TWIR_SET_ERROR(TWI_ERR_BUS_ARB);                        // set error flag
        break;                                                  // leave TX loop
      }

      if (command != 0) {
     608:	99 23       	and	r25, r25
     60a:	a1 f0       	breq	.+40     	; 0x634 <TWI_MasterRead+0x84>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:424
        if (currentSM == TWI_BUSSTATE_OWNER_gc) {
     60c:	72 30       	cpi	r23, 0x02	; 2
     60e:	b1 f7       	brne	.-20     	; 0x5fc <TWI_MasterRead+0x4c>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:425
          module->MCTRLB = command;
     610:	94 83       	std	Z+4, r25	; 0x04
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:432
          break;
        }
      }

      if (currentSM == TWI_BUSSTATE_OWNER_gc) {  // Address sent, check for WIF/RIF
        if (currentStatus & TWI_RIF_bm) {         // data received
     612:	57 ff       	sbrs	r21, 7
     614:	18 c0       	rjmp	.+48     	; 0x646 <TWI_MasterRead+0x96>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:433
          if (dataRead < BUFFER_LENGTH) {          // Buffer still free
     616:	80 32       	cpi	r24, 0x20	; 32
     618:	a0 f4       	brcc	.+40     	; 0x642 <TWI_MasterRead+0x92>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:434
            rxBuffer[dataRead] = module->MDATA;      // save byte in the Buffer.
     61a:	50 85       	ldd	r21, Z+8	; 0x08
     61c:	9d 01       	movw	r18, r26
     61e:	28 0f       	add	r18, r24
     620:	31 1d       	adc	r19, r1
     622:	e9 01       	movw	r28, r18
     624:	5c a7       	std	Y+44, r21	; 0x2c
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:435
            dataRead++;                              // increment read counter
     626:	8f 5f       	subi	r24, 0xFF	; 255
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:438
            timeout = 0;                             // reset timeout

            if (dataRead < bytesToRead) {            // expecting more bytes, so
     628:	86 17       	cp	r24, r22
     62a:	38 f4       	brcc	.+14     	; 0x63a <TWI_MasterRead+0x8a>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:439
              module->MCTRLB = TWI_MCMD_RECVTRANS_gc;  // send an ACK so the Slave so it can send the next byte
     62c:	14 83       	std	Z+4, r17	; 0x04
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:436
      if (currentSM == TWI_BUSSTATE_OWNER_gc) {  // Address sent, check for WIF/RIF
        if (currentStatus & TWI_RIF_bm) {         // data received
          if (dataRead < BUFFER_LENGTH) {          // Buffer still free
            rxBuffer[dataRead] = module->MDATA;      // save byte in the Buffer.
            dataRead++;                              // increment read counter
            timeout = 0;                             // reset timeout
     62e:	30 e0       	ldi	r19, 0x00	; 0
     630:	20 e0       	ldi	r18, 0x00	; 0
     632:	d6 cf       	rjmp	.-84     	; 0x5e0 <TWI_MasterRead+0x30>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:431
        } else {
          break;
        }
      }

      if (currentSM == TWI_BUSSTATE_OWNER_gc) {  // Address sent, check for WIF/RIF
     634:	72 30       	cpi	r23, 0x02	; 2
     636:	a1 f6       	brne	.-88     	; 0x5e0 <TWI_MasterRead+0x30>
     638:	ec cf       	rjmp	.-40     	; 0x612 <TWI_MasterRead+0x62>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:441
            timeout = 0;                             // reset timeout

            if (dataRead < bytesToRead) {            // expecting more bytes, so
              module->MCTRLB = TWI_MCMD_RECVTRANS_gc;  // send an ACK so the Slave so it can send the next byte
            } else {                                 // Otherwise,
              if (send_stop != 0) {
     63a:	44 23       	and	r20, r20
     63c:	f9 f2       	breq	.-66     	; 0x5fc <TWI_MasterRead+0x4c>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:436
      if (currentSM == TWI_BUSSTATE_OWNER_gc) {  // Address sent, check for WIF/RIF
        if (currentStatus & TWI_RIF_bm) {         // data received
          if (dataRead < BUFFER_LENGTH) {          // Buffer still free
            rxBuffer[dataRead] = module->MDATA;      // save byte in the Buffer.
            dataRead++;                              // increment read counter
            timeout = 0;                             // reset timeout
     63e:	30 e0       	ldi	r19, 0x00	; 0
     640:	20 e0       	ldi	r18, 0x00	; 0
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:442

            if (dataRead < bytesToRead) {            // expecting more bytes, so
              module->MCTRLB = TWI_MCMD_RECVTRANS_gc;  // send an ACK so the Slave so it can send the next byte
            } else {                                 // Otherwise,
              if (send_stop != 0) {
                command = TWI_ACKACT_bm | TWI_MCMD_STOP_gc;   // send STOP + NACK
     642:	97 e0       	ldi	r25, 0x07	; 7
     644:	cd cf       	rjmp	.-102    	; 0x5e0 <TWI_MasterRead+0x30>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:452

          } else {                                        // Buffer overflow with the incoming byte
            TWIR_SET_ERROR(TWI_ERR_BUF_OVERFLOW);         // Set Error and
            command = TWI_ACKACT_bm | TWI_MCMD_STOP_gc;   // send STOP + NACK
          }
        } else if (currentStatus & TWI_WIF_bm) {  // Address NACKed
     646:	56 ff       	sbrs	r21, 6
     648:	cb cf       	rjmp	.-106    	; 0x5e0 <TWI_MasterRead+0x30>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:454
          TWIR_SET_ERROR(TWI_ERR_RXACK);          // set error flag
          command = TWI_MCMD_STOP_gc;             // free the bus
     64a:	93 e0       	ldi	r25, 0x03	; 3
     64c:	c9 cf       	rjmp	.-110    	; 0x5e0 <TWI_MasterRead+0x30>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:391

  TWI_t *module = _data->_module;     // Compiler treats the pointer to the TWI module as volatile and
                                      // creates bloat-y code, using a local variable fixes that

  TWIR_INIT_ERROR;             // local variable for errors
  uint8_t dataRead = 0;
     64e:	80 e0       	ldi	r24, 0x00	; 0
     650:	d7 cf       	rjmp	.-82     	; 0x600 <TWI_MasterRead+0x50>

00000652 <TWI_MasterWrite>:
TWI_MasterWrite():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:275
 *
 *@return     uint8_t
 *@retval     amount of bytes that were written. If 0, no write took place, either due
 *            to an error or because of an empty txBuffer
 */
uint8_t TWI_MasterWrite(struct twiData *_data, bool send_stop)  {
     652:	cf 93       	push	r28
     654:	df 93       	push	r29
     656:	dc 01       	movw	r26, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:284
  #else                                                       // Separate tx/rx Buffers
    uint8_t* txHead   = &(_data->_bytesToWrite);
    uint8_t* txBuffer =   _data->_txBuffer;
  #endif

  TWI_t *module = _data->_module;     // Compiler treats the pointer to the TWI module as volatile and
     658:	ed 91       	ld	r30, X+
     65a:	fc 91       	ld	r31, X
     65c:	11 97       	sbiw	r26, 0x01	; 1
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:293
  uint8_t currentStatus;
  uint8_t dataWritten = 0;
  uint16_t timeout = 0;


  if ((module->MSTATUS & TWI_BUSSTATE_gm) == TWI_BUSSTATE_UNKNOWN_gc) {
     65e:	85 81       	ldd	r24, Z+5	; 0x05
     660:	83 70       	andi	r24, 0x03	; 3
     662:	09 f4       	brne	.+2      	; 0x666 <TWI_MasterWrite+0x14>
     664:	41 c0       	rjmp	.+130    	; 0x6e8 <TWI_MasterWrite+0x96>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:290
                                      // creates bloat-y code, this fixes it
  TWI_INIT_ERROR;
  uint8_t currentSM;
  uint8_t currentStatus;
  uint8_t dataWritten = 0;
  uint16_t timeout = 0;
     666:	30 e0       	ldi	r19, 0x00	; 0
     668:	20 e0       	ldi	r18, 0x00	; 0
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:289
  TWI_t *module = _data->_module;     // Compiler treats the pointer to the TWI module as volatile and
                                      // creates bloat-y code, this fixes it
  TWI_INIT_ERROR;
  uint8_t currentSM;
  uint8_t currentStatus;
  uint8_t dataWritten = 0;
     66a:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:299
    return TWI_ERR_UNINIT;                     // If the bus was not initialized, return
  }


  while (true) {
    currentStatus = module->MSTATUS;
     66c:	45 81       	ldd	r20, Z+5	; 0x05
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:300
    currentSM = currentStatus & TWI_BUSSTATE_gm;  // get the current mode of the state machine
     66e:	84 2f       	mov	r24, r20
     670:	83 70       	andi	r24, 0x03	; 3
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:303

    #if defined(TWI_TIMEOUT_ENABLE)
      if (++timeout > (F_CPU/1000)) {
     672:	2f 5f       	subi	r18, 0xFF	; 255
     674:	3f 4f       	sbci	r19, 0xFF	; 255
     676:	21 32       	cpi	r18, 0x21	; 33
     678:	5e e4       	ldi	r21, 0x4E	; 78
     67a:	35 07       	cpc	r19, r21
     67c:	50 f0       	brcs	.+20     	; 0x692 <TWI_MasterWrite+0x40>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:304
        if        (currentSM == TWI_BUSSTATE_OWNER_gc) {
     67e:	82 30       	cpi	r24, 0x02	; 2
     680:	79 f1       	breq	.+94     	; 0x6e0 <TWI_MasterWrite+0x8e>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:306
          TWI_SET_ERROR(TWI_ERR_TIMEOUT);
        } else if (currentSM == TWI_BUSSTATE_IDLE_gc) {
     682:	81 30       	cpi	r24, 0x01	; 1
     684:	79 f1       	breq	.+94     	; 0x6e4 <TWI_MasterWrite+0x92>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:309
          TWI_SET_ERROR(TWI_ERR_PULLUP);
        } else {
          TWI_SET_ERROR(TWI_ERR_UNDEFINED);
     686:	84 e0       	ldi	r24, 0x04	; 4
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:346
    }
  }


  if ((send_stop != 0) || (TWI_ERR_SUCCESS != TWI_GET_ERROR)) {
    module->MCTRLB = TWI_MCMD_STOP_gc;                        // Send STOP
     688:	93 e0       	ldi	r25, 0x03	; 3
     68a:	94 83       	std	Z+4, r25	; 0x04
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:349
  }
  return TWI_GET_ERROR;
}
     68c:	df 91       	pop	r29
     68e:	cf 91       	pop	r28
     690:	08 95       	ret
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:315
        }
        break;
      }
    #endif

    if   (currentStatus & (TWI_ARBLOST_bm | TWI_BUSERR_bm)) {     // Check for Bus error
     692:	54 2f       	mov	r21, r20
     694:	5c 70       	andi	r21, 0x0C	; 12
     696:	21 f0       	breq	.+8      	; 0x6a0 <TWI_MasterWrite+0x4e>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:316
        module->MSTATUS = (TWI_ARBLOST_bm | TWI_BUSERR_bm);       // reset error flags
     698:	8c e0       	ldi	r24, 0x0C	; 12
     69a:	85 83       	std	Z+5, r24	; 0x05
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:317
        TWI_SET_ERROR(TWI_ERR_BUS_ARB);                           // set error flag
     69c:	82 e1       	ldi	r24, 0x12	; 18
     69e:	f4 cf       	rjmp	.-24     	; 0x688 <TWI_MasterWrite+0x36>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:321
        break;                                                    // leave RX loop
    }

    if (currentSM == TWI_BUSSTATE_IDLE_gc) {                      // Bus has not sent START yet and is not BUSY
     6a0:	81 30       	cpi	r24, 0x01	; 1
     6a2:	41 f4       	brne	.+16     	; 0x6b4 <TWI_MasterWrite+0x62>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:322
        module->MADDR = ADD_WRITE_BIT(_data->_clientAddress);
     6a4:	13 96       	adiw	r26, 0x03	; 3
     6a6:	8c 91       	ld	r24, X
     6a8:	13 97       	sbiw	r26, 0x03	; 3
     6aa:	8e 7f       	andi	r24, 0xFE	; 254
     6ac:	87 83       	std	Z+7, r24	; 0x07
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:334
          break;                                                  // leave loop
        } else {                                                  // otherwise WRITE was ACKed
          if (dataWritten < (*txHead)) {                          // check if there is data to be written
            module->MDATA = txBuffer[dataWritten];                // Writing to the register to send data
            dataWritten++;                                        // data was Written
            timeout = 0;                                          // reset timeout
     6ae:	30 e0       	ldi	r19, 0x00	; 0
     6b0:	20 e0       	ldi	r18, 0x00	; 0
     6b2:	dc cf       	rjmp	.-72     	; 0x66c <TWI_MasterWrite+0x1a>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:324
    }

    if (currentSM == TWI_BUSSTATE_IDLE_gc) {                      // Bus has not sent START yet and is not BUSY
        module->MADDR = ADD_WRITE_BIT(_data->_clientAddress);
        timeout = 0;
    } else if (currentSM == TWI_BUSSTATE_OWNER_gc) {              // Address was sent, host is owner
     6b4:	82 30       	cpi	r24, 0x02	; 2
     6b6:	d1 f6       	brne	.-76     	; 0x66c <TWI_MasterWrite+0x1a>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:325
      if     (currentStatus & TWI_WIF_bm) {                       // data sent
     6b8:	46 ff       	sbrs	r20, 6
     6ba:	d8 cf       	rjmp	.-80     	; 0x66c <TWI_MasterWrite+0x1a>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:326
        if   (currentStatus & TWI_RXACK_bm) {                     // AND the RXACK bit is set, last byte has failed
     6bc:	44 ff       	sbrs	r20, 4
     6be:	04 c0       	rjmp	.+8      	; 0x6c8 <TWI_MasterWrite+0x76>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:327
          if (dataWritten == 0) TWI_SET_ERROR(TWI_ERR_ACK_ADR);   // if dataWritten is 0, no payload was sent, so address was NACKed
     6c0:	99 23       	and	r25, r25
     6c2:	11 f3       	breq	.-60     	; 0x688 <TWI_MasterWrite+0x36>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:328
          else                  TWI_SET_ERROR(TWI_ERR_ACK_DAT);   // else payload was NACKed
     6c4:	83 e0       	ldi	r24, 0x03	; 3
     6c6:	e0 cf       	rjmp	.-64     	; 0x688 <TWI_MasterWrite+0x36>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:331
          break;                                                  // leave loop
        } else {                                                  // otherwise WRITE was ACKed
          if (dataWritten < (*txHead)) {                          // check if there is data to be written
     6c8:	14 96       	adiw	r26, 0x04	; 4
     6ca:	8c 91       	ld	r24, X
     6cc:	14 97       	sbiw	r26, 0x04	; 4
     6ce:	98 17       	cp	r25, r24
     6d0:	68 f4       	brcc	.+26     	; 0x6ec <TWI_MasterWrite+0x9a>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:332
            module->MDATA = txBuffer[dataWritten];                // Writing to the register to send data
     6d2:	ed 01       	movw	r28, r26
     6d4:	c9 0f       	add	r28, r25
     6d6:	d1 1d       	adc	r29, r1
     6d8:	8c 85       	ldd	r24, Y+12	; 0x0c
     6da:	80 87       	std	Z+8, r24	; 0x08
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:333
            dataWritten++;                                        // data was Written
     6dc:	9f 5f       	subi	r25, 0xFF	; 255
     6de:	e7 cf       	rjmp	.-50     	; 0x6ae <TWI_MasterWrite+0x5c>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:305
    currentSM = currentStatus & TWI_BUSSTATE_gm;  // get the current mode of the state machine

    #if defined(TWI_TIMEOUT_ENABLE)
      if (++timeout > (F_CPU/1000)) {
        if        (currentSM == TWI_BUSSTATE_OWNER_gc) {
          TWI_SET_ERROR(TWI_ERR_TIMEOUT);
     6e0:	85 e0       	ldi	r24, 0x05	; 5
     6e2:	d2 cf       	rjmp	.-92     	; 0x688 <TWI_MasterWrite+0x36>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:307
        } else if (currentSM == TWI_BUSSTATE_IDLE_gc) {
          TWI_SET_ERROR(TWI_ERR_PULLUP);
     6e4:	81 e1       	ldi	r24, 0x11	; 17
     6e6:	d0 cf       	rjmp	.-96     	; 0x688 <TWI_MasterWrite+0x36>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:294
  uint8_t dataWritten = 0;
  uint16_t timeout = 0;


  if ((module->MSTATUS & TWI_BUSSTATE_gm) == TWI_BUSSTATE_UNKNOWN_gc) {
    return TWI_ERR_UNINIT;                     // If the bus was not initialized, return
     6e8:	80 e1       	ldi	r24, 0x10	; 16
     6ea:	d0 cf       	rjmp	.-96     	; 0x68c <TWI_MasterWrite+0x3a>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:286
    uint8_t* txBuffer =   _data->_txBuffer;
  #endif

  TWI_t *module = _data->_module;     // Compiler treats the pointer to the TWI module as volatile and
                                      // creates bloat-y code, this fixes it
  TWI_INIT_ERROR;
     6ec:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:345
      }
    }
  }


  if ((send_stop != 0) || (TWI_ERR_SUCCESS != TWI_GET_ERROR)) {
     6ee:	66 23       	and	r22, r22
     6f0:	69 f2       	breq	.-102    	; 0x68c <TWI_MasterWrite+0x3a>
     6f2:	ca cf       	rjmp	.-108    	; 0x688 <TWI_MasterWrite+0x36>

000006f4 <Adafruit_SPIDevice::transfer(unsigned char)>:
_ZN18Adafruit_SPIDevice8transferEh():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:262
/*!
 *    @brief  Transfer (send/receive) one byte over hard/soft SPI
 *    @param  send The byte to send
 *    @return The byte received while transmitting
 */
uint8_t Adafruit_SPIDevice::transfer(uint8_t send) {
     6f4:	af 92       	push	r10
     6f6:	bf 92       	push	r11
     6f8:	cf 92       	push	r12
     6fa:	df 92       	push	r13
     6fc:	ef 92       	push	r14
     6fe:	ff 92       	push	r15
     700:	0f 93       	push	r16
     702:	1f 93       	push	r17
     704:	cf 93       	push	r28
     706:	df 93       	push	r29
     708:	ec 01       	movw	r28, r24
transfer():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:126
 *    @brief  Transfer (send/receive) one byte over hard/soft SPI
 *    @param  buffer The buffer to send and receive at the same time
 *    @param  len    The number of bytes to transfer
 */
void Adafruit_SPIDevice::transfer(uint8_t *buffer, size_t len) {
  if (_spi) {
     70a:	88 81       	ld	r24, Y
     70c:	99 81       	ldd	r25, Y+1	; 0x01
     70e:	89 2b       	or	r24, r25
     710:	a9 f0       	breq	.+42     	; 0x73c <Adafruit_SPIDevice::transfer(unsigned char)+0x48>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:310
    The following NOP introduces a small delay that can prevent the wait
    loop from iterating when running at the maximum speed. This gives
    about 10% more speed, even if it seems counter-intuitive. At lower
    speeds it is unnoticed.
  */
  asm volatile("nop");
     712:	00 00       	nop
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:312

  SPI0.DATA = data;
     714:	60 93 c4 08 	sts	0x08C4, r22	; 0x8008c4 <vtable for Adafruit_BMP280_Temp+0x7f54fe>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:313
  while ((SPI0.INTFLAGS & SPI_RXCIF_bm) == 0);  // wait for complete send
     718:	80 91 c3 08 	lds	r24, 0x08C3	; 0x8008c3 <vtable for Adafruit_BMP280_Temp+0x7f54fd>
     71c:	87 ff       	sbrs	r24, 7
     71e:	fc cf       	rjmp	.-8      	; 0x718 <Adafruit_SPIDevice::transfer(unsigned char)+0x24>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:314
  return SPI0.DATA;                             // read data back
     720:	b0 90 c4 08 	lds	r11, 0x08C4	; 0x8008c4 <vtable for Adafruit_BMP280_Temp+0x7f54fe>
_ZN18Adafruit_SPIDevice8transferEh():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:266
 */
uint8_t Adafruit_SPIDevice::transfer(uint8_t send) {
  uint8_t data = send;
  transfer(&data, 1);
  return data;
}
     724:	8b 2d       	mov	r24, r11
     726:	df 91       	pop	r29
     728:	cf 91       	pop	r28
     72a:	1f 91       	pop	r17
     72c:	0f 91       	pop	r16
     72e:	ff 90       	pop	r15
     730:	ef 90       	pop	r14
     732:	df 90       	pop	r13
     734:	cf 90       	pop	r12
     736:	bf 90       	pop	r11
     738:	af 90       	pop	r10
     73a:	08 95       	ret
transfer():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:142
#endif
    return;
  }

  uint8_t startbit;
  if (_dataOrder == SPI_BITORDER_LSBFIRST) {
     73c:	88 85       	ldd	r24, Y+8	; 0x08
     73e:	99 85       	ldd	r25, Y+9	; 0x09
_ZN18Adafruit_SPIDevice8transferEh():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:143
    startbit = 0x1;
     740:	11 e0       	ldi	r17, 0x01	; 1
transfer():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:142
#endif
    return;
  }

  uint8_t startbit;
  if (_dataOrder == SPI_BITORDER_LSBFIRST) {
     742:	89 2b       	or	r24, r25
     744:	09 f0       	breq	.+2      	; 0x748 <Adafruit_SPIDevice::transfer(unsigned char)+0x54>
_ZN18Adafruit_SPIDevice8transferEh():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:145
    startbit = 0x1;
  } else {
    startbit = 0x80;
     746:	10 e8       	ldi	r17, 0x80	; 128
transfer():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:148
  }

  bool towrite, lastmosi = !(buffer[0] & startbit);
     748:	aa 24       	eor	r10, r10
     74a:	a3 94       	inc	r10
     74c:	86 2f       	mov	r24, r22
     74e:	81 23       	and	r24, r17
     750:	09 f0       	breq	.+2      	; 0x754 <Adafruit_SPIDevice::transfer(unsigned char)+0x60>
     752:	a1 2c       	mov	r10, r1
     754:	06 2f       	mov	r16, r22
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:149
  uint8_t bitdelay_us = (1000000 / _freq) / 2;
     756:	2c 81       	ldd	r18, Y+4	; 0x04
     758:	3d 81       	ldd	r19, Y+5	; 0x05
     75a:	4e 81       	ldd	r20, Y+6	; 0x06
     75c:	5f 81       	ldd	r21, Y+7	; 0x07
     75e:	60 e2       	ldi	r22, 0x20	; 32
     760:	71 ea       	ldi	r23, 0xA1	; 161
     762:	87 e0       	ldi	r24, 0x07	; 7
     764:	90 e0       	ldi	r25, 0x00	; 0
     766:	0e 94 e6 16 	call	0x2dcc	; 0x2dcc <__udivmodsi4>
     76a:	f2 2e       	mov	r15, r18
_ZN18Adafruit_SPIDevice8transferEh():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:263
 *    @brief  Transfer (send/receive) one byte over hard/soft SPI
 *    @param  send The byte to send
 *    @return The byte received while transmitting
 */
uint8_t Adafruit_SPIDevice::transfer(uint8_t send) {
  uint8_t data = send;
     76c:	b0 2e       	mov	r11, r16
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:154
  uint8_t bitdelay_us = (1000000 / _freq) / 2;

  // for softSPI we'll do it by hand
  for (size_t i = 0; i < len; i++) {
    // software SPI
    uint8_t reply = 0;
     76e:	e1 2c       	mov	r14, r1
transfer():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:168
    // Serial.print(send, HEX);
    for (uint8_t b = startbit; b != 0;
         b = (_dataOrder == SPI_BITORDER_LSBFIRST) ? b << 1 : b >> 1) {

      if (bitdelay_us) {
        delayMicroseconds(bitdelay_us);
     770:	c2 2e       	mov	r12, r18
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:167

    // Serial.print(send, HEX);
    for (uint8_t b = startbit; b != 0;
         b = (_dataOrder == SPI_BITORDER_LSBFIRST) ? b << 1 : b >> 1) {

      if (bitdelay_us) {
     772:	d1 2c       	mov	r13, r1
     774:	ff 20       	and	r15, r15
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:753
inline __attribute__((always_inline)) void delayMicroseconds(unsigned int us) {
  // This function gets optimized away, but to what depends on whether us is constant.
  if (__builtin_constant_p(us)) {
    _delay_us(us); // Constant microseconds use the avr-libc _delay_us() which is highly accurate for all values and efficient!
  } else { // If it is not, we have to use the Arduino style implementation.
    _delayMicroseconds(us);
     776:	11 f0       	breq	.+4      	; 0x77c <Adafruit_SPIDevice::transfer(unsigned char)+0x88>
delayMicroseconds():
     778:	c6 01       	movw	r24, r12
     77a:	2c de       	rcall	.-936    	; 0x3d4 <_delayMicroseconds>
transfer():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:171
        delayMicroseconds(bitdelay_us);
      }

      if (_dataMode == SPI_MODE0 || _dataMode == SPI_MODE2) {
     77c:	8a 85       	ldd	r24, Y+10	; 0x0a
     77e:	8d 7f       	andi	r24, 0xFD	; 253
     780:	09 f0       	breq	.+2      	; 0x784 <Adafruit_SPIDevice::transfer(unsigned char)+0x90>
     782:	41 c0       	rjmp	.+130    	; 0x806 <__DATA_REGION_LENGTH__+0x6>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:173
        towrite = send & b;
        if ((_mosi != -1) && (lastmosi != towrite)) {
     784:	8d 85       	ldd	r24, Y+13	; 0x0d
     786:	8f 3f       	cpi	r24, 0xFF	; 255
     788:	89 f0       	breq	.+34     	; 0x7ac <Adafruit_SPIDevice::transfer(unsigned char)+0xb8>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:172
      if (bitdelay_us) {
        delayMicroseconds(bitdelay_us);
      }

      if (_dataMode == SPI_MODE0 || _dataMode == SPI_MODE2) {
        towrite = send & b;
     78a:	90 2f       	mov	r25, r16
     78c:	91 23       	and	r25, r17
     78e:	81 e0       	ldi	r24, 0x01	; 1
     790:	09 f4       	brne	.+2      	; 0x794 <Adafruit_SPIDevice::transfer(unsigned char)+0xa0>
     792:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:173
        if ((_mosi != -1) && (lastmosi != towrite)) {
     794:	8a 15       	cp	r24, r10
     796:	51 f0       	breq	.+20     	; 0x7ac <Adafruit_SPIDevice::transfer(unsigned char)+0xb8>
     798:	ef 85       	ldd	r30, Y+15	; 0x0f
     79a:	f8 89       	ldd	r31, Y+16	; 0x10
     79c:	8f 89       	ldd	r24, Y+23	; 0x17
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:175
#ifdef BUSIO_USE_FAST_PINIO
          if (towrite)
     79e:	99 23       	and	r25, r25
     7a0:	61 f1       	breq	.+88     	; 0x7fa <Adafruit_SPIDevice::transfer(unsigned char)+0x106>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:176
            *mosiPort |= mosiPinMask;
     7a2:	90 81       	ld	r25, Z
     7a4:	89 2b       	or	r24, r25
     7a6:	80 83       	st	Z, r24
     7a8:	aa 24       	eor	r10, r10
     7aa:	a3 94       	inc	r10
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:186
#endif
          lastmosi = towrite;
        }

#ifdef BUSIO_USE_FAST_PINIO
        *clkPort |= clkPinMask; // Clock high
     7ac:	e9 89       	ldd	r30, Y+17	; 0x11
     7ae:	fa 89       	ldd	r31, Y+18	; 0x12
     7b0:	80 81       	ld	r24, Z
     7b2:	99 8d       	ldd	r25, Y+25	; 0x19
     7b4:	89 2b       	or	r24, r25
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:191
#else
        digitalWrite(_sck, HIGH);
#endif

        if (bitdelay_us) {
     7b6:	80 83       	st	Z, r24
     7b8:	ff 20       	and	r15, r15
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:753
     7ba:	11 f0       	breq	.+4      	; 0x7c0 <Adafruit_SPIDevice::transfer(unsigned char)+0xcc>
delayMicroseconds():
     7bc:	c6 01       	movw	r24, r12
     7be:	0a de       	rcall	.-1004   	; 0x3d4 <_delayMicroseconds>
transfer():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:195
          delayMicroseconds(bitdelay_us);
        }

        if (_miso != -1) {
     7c0:	8e 85       	ldd	r24, Y+14	; 0x0e
     7c2:	8f 3f       	cpi	r24, 0xFF	; 255
     7c4:	39 f0       	breq	.+14     	; 0x7d4 <Adafruit_SPIDevice::transfer(unsigned char)+0xe0>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:197
#ifdef BUSIO_USE_FAST_PINIO
          if (*misoPort & misoPinMask) {
     7c6:	eb 89       	ldd	r30, Y+19	; 0x13
     7c8:	fc 89       	ldd	r31, Y+20	; 0x14
     7ca:	80 81       	ld	r24, Z
     7cc:	98 8d       	ldd	r25, Y+24	; 0x18
     7ce:	89 23       	and	r24, r25
     7d0:	09 f0       	breq	.+2      	; 0x7d4 <Adafruit_SPIDevice::transfer(unsigned char)+0xe0>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:201
#else
          if (digitalRead(_miso)) {
#endif
            reply |= b;
     7d2:	e1 2a       	or	r14, r17
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:206
          }
        }

#ifdef BUSIO_USE_FAST_PINIO
        *clkPort &= ~clkPinMask; // Clock low
     7d4:	e9 89       	ldd	r30, Y+17	; 0x11
     7d6:	fa 89       	ldd	r31, Y+18	; 0x12
     7d8:	90 81       	ld	r25, Z
     7da:	89 8d       	ldd	r24, Y+25	; 0x19
     7dc:	80 95       	com	r24
     7de:	89 23       	and	r24, r25
     7e0:	80 83       	st	Z, r24
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:249
#endif
            reply |= b;
          }
        }
      }
      if (_miso != -1) {
     7e2:	8e 85       	ldd	r24, Y+14	; 0x0e
     7e4:	8f 3f       	cpi	r24, 0xFF	; 255
     7e6:	09 f0       	breq	.+2      	; 0x7ea <Adafruit_SPIDevice::transfer(unsigned char)+0xf6>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:250
        buffer[i] = reply;
     7e8:	be 2c       	mov	r11, r14
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:164
    Serial.print(send, HEX);
    Serial.print(" -> 0x");
    */

    // Serial.print(send, HEX);
    for (uint8_t b = startbit; b != 0;
     7ea:	88 85       	ldd	r24, Y+8	; 0x08
     7ec:	99 85       	ldd	r25, Y+9	; 0x09
     7ee:	89 2b       	or	r24, r25
     7f0:	b1 f5       	brne	.+108    	; 0x85e <__DATA_REGION_LENGTH__+0x5e>
     7f2:	11 0f       	add	r17, r17
     7f4:	11 11       	cpse	r17, r1
     7f6:	be cf       	rjmp	.-132    	; 0x774 <Adafruit_SPIDevice::transfer(unsigned char)+0x80>
     7f8:	95 cf       	rjmp	.-214    	; 0x724 <Adafruit_SPIDevice::transfer(unsigned char)+0x30>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:178
        if ((_mosi != -1) && (lastmosi != towrite)) {
#ifdef BUSIO_USE_FAST_PINIO
          if (towrite)
            *mosiPort |= mosiPinMask;
          else
            *mosiPort &= ~mosiPinMask;
     7fa:	90 81       	ld	r25, Z
     7fc:	80 95       	com	r24
     7fe:	89 23       	and	r24, r25
     800:	80 83       	st	Z, r24
     802:	a1 2c       	mov	r10, r1
     804:	d3 cf       	rjmp	.-90     	; 0x7ac <Adafruit_SPIDevice::transfer(unsigned char)+0xb8>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:213
        digitalWrite(_sck, LOW);
#endif
      } else { // if (_dataMode == SPI_MODE1 || _dataMode == SPI_MODE3)

#ifdef BUSIO_USE_FAST_PINIO
        *clkPort |= clkPinMask; // Clock high
     806:	e9 89       	ldd	r30, Y+17	; 0x11
     808:	fa 89       	ldd	r31, Y+18	; 0x12
     80a:	80 81       	ld	r24, Z
     80c:	99 8d       	ldd	r25, Y+25	; 0x19
     80e:	89 2b       	or	r24, r25
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:218
#else
        digitalWrite(_sck, HIGH);
#endif

        if (bitdelay_us) {
     810:	80 83       	st	Z, r24
     812:	ff 20       	and	r15, r15
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:753
     814:	11 f0       	breq	.+4      	; 0x81a <__DATA_REGION_LENGTH__+0x1a>
delayMicroseconds():
     816:	c6 01       	movw	r24, r12
     818:	dd dd       	rcall	.-1094   	; 0x3d4 <_delayMicroseconds>
transfer():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:222
          delayMicroseconds(bitdelay_us);
        }

        if (_mosi != -1) {
     81a:	8d 85       	ldd	r24, Y+13	; 0x0d
     81c:	8f 3f       	cpi	r24, 0xFF	; 255
     81e:	49 f0       	breq	.+18     	; 0x832 <__DATA_REGION_LENGTH__+0x32>
     820:	ef 85       	ldd	r30, Y+15	; 0x0f
     822:	f8 89       	ldd	r31, Y+16	; 0x10
     824:	8f 89       	ldd	r24, Y+23	; 0x17
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:224
#ifdef BUSIO_USE_FAST_PINIO
          if (send & b)
     826:	90 2f       	mov	r25, r16
     828:	91 23       	and	r25, r17
     82a:	a9 f0       	breq	.+42     	; 0x856 <__DATA_REGION_LENGTH__+0x56>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:225
            *mosiPort |= mosiPinMask;
     82c:	90 81       	ld	r25, Z
     82e:	89 2b       	or	r24, r25
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:227
          else
            *mosiPort &= ~mosiPinMask;
     830:	80 83       	st	Z, r24
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:234
          digitalWrite(_mosi, send & b);
#endif
        }

#ifdef BUSIO_USE_FAST_PINIO
        *clkPort &= ~clkPinMask; // Clock low
     832:	e9 89       	ldd	r30, Y+17	; 0x11
     834:	fa 89       	ldd	r31, Y+18	; 0x12
     836:	90 81       	ld	r25, Z
     838:	89 8d       	ldd	r24, Y+25	; 0x19
     83a:	80 95       	com	r24
     83c:	89 23       	and	r24, r25
     83e:	80 83       	st	Z, r24
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:239
#else
        digitalWrite(_sck, LOW);
#endif

        if (_miso != -1) {
     840:	8e 85       	ldd	r24, Y+14	; 0x0e
     842:	8f 3f       	cpi	r24, 0xFF	; 255
     844:	71 f2       	breq	.-100    	; 0x7e2 <Adafruit_SPIDevice::transfer(unsigned char)+0xee>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:241
#ifdef BUSIO_USE_FAST_PINIO
          if (*misoPort & misoPinMask) {
     846:	eb 89       	ldd	r30, Y+19	; 0x13
     848:	fc 89       	ldd	r31, Y+20	; 0x14
     84a:	80 81       	ld	r24, Z
     84c:	98 8d       	ldd	r25, Y+24	; 0x18
     84e:	89 23       	and	r24, r25
     850:	41 f2       	breq	.-112    	; 0x7e2 <Adafruit_SPIDevice::transfer(unsigned char)+0xee>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:245
#else
          if (digitalRead(_miso)) {
#endif
            reply |= b;
     852:	e1 2a       	or	r14, r17
     854:	c6 cf       	rjmp	.-116    	; 0x7e2 <Adafruit_SPIDevice::transfer(unsigned char)+0xee>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:227
        if (_mosi != -1) {
#ifdef BUSIO_USE_FAST_PINIO
          if (send & b)
            *mosiPort |= mosiPinMask;
          else
            *mosiPort &= ~mosiPinMask;
     856:	90 81       	ld	r25, Z
     858:	80 95       	com	r24
     85a:	89 23       	and	r24, r25
     85c:	e9 cf       	rjmp	.-46     	; 0x830 <__DATA_REGION_LENGTH__+0x30>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:164
    Serial.print(send, HEX);
    Serial.print(" -> 0x");
    */

    // Serial.print(send, HEX);
    for (uint8_t b = startbit; b != 0;
     85e:	16 95       	lsr	r17
     860:	c9 cf       	rjmp	.-110    	; 0x7f4 <Adafruit_SPIDevice::transfer(unsigned char)+0x100>

00000862 <Adafruit_BMP280_Temp::~Adafruit_BMP280_Temp()>:
_ZN24Adafruit_BMP280_PressureD2Ev():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.h:105
  int _sensorID = 280;
  Adafruit_BMP280 *_theBMP280 = NULL;
};

/** Adafruit Unified Sensor interface for pressure component of BMP280 */
class Adafruit_BMP280_Pressure : public Adafruit_Sensor {
     862:	08 95       	ret

00000864 <Adafruit_Sensor::enableAutoRange(bool)>:
_ZN15Adafruit_Sensor15enableAutoRangeEb():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_Unified_Sensor/Adafruit_Sensor.h:174
  /*! @brief Whether we should automatically change the range (if possible) for
     higher precision
      @param enabled True if we will try to autorange */
  virtual void enableAutoRange(bool enabled) {
    (void)enabled; /* suppress unused warning */
  };
     864:	08 95       	ret

00000866 <SPIClass::endTransaction()>:
_ZN8SPIClass14endTransactionEv():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:275
    }
  }
  config(settings);
}

void SPIClass::endTransaction(void) {
     866:	8f 92       	push	r8
     868:	9f 92       	push	r9
     86a:	af 92       	push	r10
     86c:	bf 92       	push	r11
     86e:	cf 92       	push	r12
     870:	df 92       	push	r13
     872:	ef 92       	push	r14
     874:	ff 92       	push	r15
     876:	0f 93       	push	r16
     878:	1f 93       	push	r17
     87a:	cf 93       	push	r28
     87c:	df 93       	push	r29
     87e:	fc 01       	movw	r30, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:276
  if (interruptMode != SPI_IMODE_NONE) {
     880:	86 81       	ldd	r24, Z+6	; 0x06
     882:	88 23       	and	r24, r24
     884:	19 f0       	breq	.+6      	; 0x88c <SPIClass::endTransaction()+0x26>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:277
    if (interruptMode & SPI_IMODE_GLOBAL) {
     886:	81 ff       	sbrs	r24, 1
     888:	0e c0       	rjmp	.+28     	; 0x8a6 <SPIClass::endTransaction()+0x40>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:278
      interrupts();
     88a:	78 94       	sei
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:283
    } else if (interruptMode & SPI_IMODE_EXTINT) {
      reattachMaskedInterrupts();
    }
  }
}
     88c:	df 91       	pop	r29
     88e:	cf 91       	pop	r28
     890:	1f 91       	pop	r17
     892:	0f 91       	pop	r16
     894:	ff 90       	pop	r15
     896:	ef 90       	pop	r14
     898:	df 90       	pop	r13
     89a:	cf 90       	pop	r12
     89c:	bf 90       	pop	r11
     89e:	af 90       	pop	r10
     8a0:	9f 90       	pop	r9
     8a2:	8f 90       	pop	r8
     8a4:	08 95       	ret
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:279

void SPIClass::endTransaction(void) {
  if (interruptMode != SPI_IMODE_NONE) {
    if (interruptMode & SPI_IMODE_GLOBAL) {
      interrupts();
    } else if (interruptMode & SPI_IMODE_EXTINT) {
     8a6:	80 ff       	sbrs	r24, 0
     8a8:	f1 cf       	rjmp	.-30     	; 0x88c <SPIClass::endTransaction()+0x26>
reattachMaskedInterrupts():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:242
    shift++;
  }
}

void SPIClass::reattachMaskedInterrupts() {
  uint64_t temp = interruptMask_lo;
     8aa:	80 84       	ldd	r8, Z+8	; 0x08
     8ac:	91 84       	ldd	r9, Z+9	; 0x09
     8ae:	a2 84       	ldd	r10, Z+10	; 0x0a
     8b0:	b3 84       	ldd	r11, Z+11	; 0x0b
     8b2:	c1 2c       	mov	r12, r1
     8b4:	d1 2c       	mov	r13, r1
     8b6:	76 01       	movw	r14, r12
_ZN8SPIClass14endTransactionEv():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:243
  uint8_t shift = 0;
     8b8:	10 e0       	ldi	r17, 0x00	; 0
reattachMaskedInterrupts():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:244
  while (temp != 0) {
     8ba:	94 01       	movw	r18, r8
     8bc:	a5 01       	movw	r20, r10
     8be:	b6 01       	movw	r22, r12
     8c0:	c7 01       	movw	r24, r14
     8c2:	a0 e0       	ldi	r26, 0x00	; 0
     8c4:	0e 94 49 18 	call	0x3092	; 0x3092 <__cmpdi2_s8>
     8c8:	99 f1       	breq	.+102    	; 0x930 <SPIClass::endTransaction()+0xca>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:245
    if (temp & 1) {
     8ca:	21 70       	andi	r18, 0x01	; 1
     8cc:	30 e0       	ldi	r19, 0x00	; 0
     8ce:	40 e0       	ldi	r20, 0x00	; 0
     8d0:	50 e0       	ldi	r21, 0x00	; 0
     8d2:	60 e0       	ldi	r22, 0x00	; 0
     8d4:	70 e0       	ldi	r23, 0x00	; 0
     8d6:	80 e0       	ldi	r24, 0x00	; 0
     8d8:	90 e0       	ldi	r25, 0x00	; 0
     8da:	0e 94 49 18 	call	0x3092	; 0x3092 <__cmpdi2_s8>
     8de:	d9 f0       	breq	.+54     	; 0x916 <SPIClass::endTransaction()+0xb0>
_ZN8SPIClass14endTransactionEv():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:246
      volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(portToPortStruct(shift / 8), shift % 8);
     8e0:	d0 e0       	ldi	r29, 0x00	; 0
     8e2:	c0 e0       	ldi	r28, 0x00	; 0
reattachMaskedInterrupts():
     8e4:	18 33       	cpi	r17, 0x38	; 56
     8e6:	70 f4       	brcc	.+28     	; 0x904 <SPIClass::endTransaction()+0x9e>
     8e8:	c1 2f       	mov	r28, r17
     8ea:	c6 95       	lsr	r28
     8ec:	c6 95       	lsr	r28
     8ee:	c6 95       	lsr	r28
     8f0:	80 e2       	ldi	r24, 0x20	; 32
     8f2:	c8 9f       	mul	r28, r24
     8f4:	e0 01       	movw	r28, r0
     8f6:	11 24       	eor	r1, r1
     8f8:	c0 5f       	subi	r28, 0xF0	; 240
     8fa:	db 4f       	sbci	r29, 0xFB	; 251
     8fc:	81 2f       	mov	r24, r17
     8fe:	87 70       	andi	r24, 0x07	; 7
     900:	c8 0f       	add	r28, r24
     902:	d1 1d       	adc	r29, r1
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:247
      *pin_ctrl_reg |= irqMap[shift];
     904:	cf 01       	movw	r24, r30
     906:	81 0f       	add	r24, r17
     908:	91 1d       	adc	r25, r1
     90a:	dc 01       	movw	r26, r24
     90c:	50 96       	adiw	r26, 0x10	; 16
     90e:	8c 91       	ld	r24, X
     910:	98 81       	ld	r25, Y
     912:	89 2b       	or	r24, r25
     914:	88 83       	st	Y, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:249
    }
    temp = temp >> 1;
     916:	94 01       	movw	r18, r8
     918:	a5 01       	movw	r20, r10
     91a:	b6 01       	movw	r22, r12
     91c:	c7 01       	movw	r24, r14
     91e:	01 e0       	ldi	r16, 0x01	; 1
     920:	0e 94 1c 18 	call	0x3038	; 0x3038 <__lshrdi3>
     924:	49 01       	movw	r8, r18
     926:	5a 01       	movw	r10, r20
     928:	6b 01       	movw	r12, r22
     92a:	7c 01       	movw	r14, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:250
    shift++;
     92c:	1f 5f       	subi	r17, 0xFF	; 255
     92e:	c5 cf       	rjmp	.-118    	; 0x8ba <SPIClass::endTransaction()+0x54>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:252
  }
  temp = interruptMask_hi;
     930:	84 84       	ldd	r8, Z+12	; 0x0c
     932:	95 84       	ldd	r9, Z+13	; 0x0d
     934:	a6 84       	ldd	r10, Z+14	; 0x0e
     936:	b7 84       	ldd	r11, Z+15	; 0x0f
     938:	c1 2c       	mov	r12, r1
     93a:	d1 2c       	mov	r13, r1
     93c:	76 01       	movw	r14, r12
_ZN8SPIClass14endTransactionEv():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:253
  shift = 32;
     93e:	10 e2       	ldi	r17, 0x20	; 32
reattachMaskedInterrupts():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:254
  while (temp != 0) {
     940:	94 01       	movw	r18, r8
     942:	a5 01       	movw	r20, r10
     944:	b6 01       	movw	r22, r12
     946:	c7 01       	movw	r24, r14
     948:	a0 e0       	ldi	r26, 0x00	; 0
     94a:	0e 94 49 18 	call	0x3092	; 0x3092 <__cmpdi2_s8>
     94e:	09 f4       	brne	.+2      	; 0x952 <SPIClass::endTransaction()+0xec>
     950:	9d cf       	rjmp	.-198    	; 0x88c <SPIClass::endTransaction()+0x26>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:255
    if (temp & 1) {
     952:	21 70       	andi	r18, 0x01	; 1
     954:	30 e0       	ldi	r19, 0x00	; 0
     956:	40 e0       	ldi	r20, 0x00	; 0
     958:	50 e0       	ldi	r21, 0x00	; 0
     95a:	60 e0       	ldi	r22, 0x00	; 0
     95c:	70 e0       	ldi	r23, 0x00	; 0
     95e:	80 e0       	ldi	r24, 0x00	; 0
     960:	90 e0       	ldi	r25, 0x00	; 0
     962:	0e 94 49 18 	call	0x3092	; 0x3092 <__cmpdi2_s8>
     966:	d9 f0       	breq	.+54     	; 0x99e <SPIClass::endTransaction()+0x138>
_ZN8SPIClass14endTransactionEv():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:256
      volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(portToPortStruct(shift / 8), shift % 8);
     968:	d0 e0       	ldi	r29, 0x00	; 0
     96a:	c0 e0       	ldi	r28, 0x00	; 0
reattachMaskedInterrupts():
     96c:	18 33       	cpi	r17, 0x38	; 56
     96e:	70 f4       	brcc	.+28     	; 0x98c <SPIClass::endTransaction()+0x126>
     970:	c1 2f       	mov	r28, r17
     972:	c6 95       	lsr	r28
     974:	c6 95       	lsr	r28
     976:	c6 95       	lsr	r28
     978:	b0 e2       	ldi	r27, 0x20	; 32
     97a:	cb 9f       	mul	r28, r27
     97c:	e0 01       	movw	r28, r0
     97e:	11 24       	eor	r1, r1
     980:	c0 5f       	subi	r28, 0xF0	; 240
     982:	db 4f       	sbci	r29, 0xFB	; 251
     984:	81 2f       	mov	r24, r17
     986:	87 70       	andi	r24, 0x07	; 7
     988:	c8 0f       	add	r28, r24
     98a:	d1 1d       	adc	r29, r1
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:257
      *pin_ctrl_reg |= irqMap[shift];
     98c:	cf 01       	movw	r24, r30
     98e:	81 0f       	add	r24, r17
     990:	91 1d       	adc	r25, r1
     992:	dc 01       	movw	r26, r24
     994:	50 96       	adiw	r26, 0x10	; 16
     996:	8c 91       	ld	r24, X
     998:	98 81       	ld	r25, Y
     99a:	89 2b       	or	r24, r25
     99c:	88 83       	st	Y, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:259
    }
    temp = temp >> 1;
     99e:	94 01       	movw	r18, r8
     9a0:	a5 01       	movw	r20, r10
     9a2:	b6 01       	movw	r22, r12
     9a4:	c7 01       	movw	r24, r14
     9a6:	01 e0       	ldi	r16, 0x01	; 1
     9a8:	0e 94 1c 18 	call	0x3038	; 0x3038 <__lshrdi3>
     9ac:	49 01       	movw	r8, r18
     9ae:	5a 01       	movw	r10, r20
     9b0:	6b 01       	movw	r12, r22
     9b2:	7c 01       	movw	r14, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:260
    shift++;
     9b4:	1f 5f       	subi	r17, 0xFF	; 255
     9b6:	c4 cf       	rjmp	.-120    	; 0x940 <SPIClass::endTransaction()+0xda>

000009b8 <SPIClass::beginTransaction(SPISettings)>:
_ZN8SPIClass16beginTransactionE11SPISettings():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:264
  }
}

void SPIClass::beginTransaction(SPISettings settings) {
     9b8:	8f 92       	push	r8
     9ba:	9f 92       	push	r9
     9bc:	af 92       	push	r10
     9be:	bf 92       	push	r11
     9c0:	cf 92       	push	r12
     9c2:	df 92       	push	r13
     9c4:	ef 92       	push	r14
     9c6:	ff 92       	push	r15
     9c8:	0f 93       	push	r16
     9ca:	1f 93       	push	r17
     9cc:	cf 93       	push	r28
     9ce:	df 93       	push	r29
     9d0:	fc 01       	movw	r30, r24
     9d2:	c6 2f       	mov	r28, r22
     9d4:	17 2f       	mov	r17, r23
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:265
  if (interruptMode != SPI_IMODE_NONE) {
     9d6:	86 81       	ldd	r24, Z+6	; 0x06
     9d8:	88 23       	and	r24, r24
     9da:	19 f0       	breq	.+6      	; 0x9e2 <SPIClass::beginTransaction(SPISettings)+0x2a>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:266
    if (interruptMode & SPI_IMODE_GLOBAL) {
     9dc:	81 ff       	sbrs	r24, 1
     9de:	12 c0       	rjmp	.+36     	; 0xa04 <SPIClass::beginTransaction(SPISettings)+0x4c>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:267
      noInterrupts();
     9e0:	f8 94       	cli
config():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:160
  interruptMask_hi = 0;
  initialized = true;
}

void SPIClass::config(SPISettings settings) {
  SPI0.CTRLA = settings.ctrla;
     9e2:	c0 93 c0 08 	sts	0x08C0, r28	; 0x8008c0 <vtable for Adafruit_BMP280_Temp+0x7f54fa>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:161
  SPI0.CTRLB = settings.ctrlb;
     9e6:	10 93 c1 08 	sts	0x08C1, r17	; 0x8008c1 <vtable for Adafruit_BMP280_Temp+0x7f54fb>
_ZN8SPIClass16beginTransactionE11SPISettings():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:273
    } else if (interruptMode & SPI_IMODE_EXTINT) {
      detachMaskedInterrupts();
    }
  }
  config(settings);
}
     9ea:	df 91       	pop	r29
     9ec:	cf 91       	pop	r28
     9ee:	1f 91       	pop	r17
     9f0:	0f 91       	pop	r16
     9f2:	ff 90       	pop	r15
     9f4:	ef 90       	pop	r14
     9f6:	df 90       	pop	r13
     9f8:	cf 90       	pop	r12
     9fa:	bf 90       	pop	r11
     9fc:	af 90       	pop	r10
     9fe:	9f 90       	pop	r9
     a00:	8f 90       	pop	r8
     a02:	08 95       	ret
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:268

void SPIClass::beginTransaction(SPISettings settings) {
  if (interruptMode != SPI_IMODE_NONE) {
    if (interruptMode & SPI_IMODE_GLOBAL) {
      noInterrupts();
    } else if (interruptMode & SPI_IMODE_EXTINT) {
     a04:	80 ff       	sbrs	r24, 0
     a06:	ed cf       	rjmp	.-38     	; 0x9e2 <SPIClass::beginTransaction(SPISettings)+0x2a>
detachMaskedInterrupts():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:217
    #endif
  }
}

void SPIClass::detachMaskedInterrupts() {
  uint64_t temp = interruptMask_lo;
     a08:	80 84       	ldd	r8, Z+8	; 0x08
     a0a:	91 84       	ldd	r9, Z+9	; 0x09
     a0c:	a2 84       	ldd	r10, Z+10	; 0x0a
     a0e:	b3 84       	ldd	r11, Z+11	; 0x0b
     a10:	c1 2c       	mov	r12, r1
     a12:	d1 2c       	mov	r13, r1
     a14:	76 01       	movw	r14, r12
_ZN8SPIClass16beginTransactionE11SPISettings():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:218
  uint8_t shift = 0;
     a16:	d0 e0       	ldi	r29, 0x00	; 0
detachMaskedInterrupts():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:219
  while (temp != 0) {
     a18:	94 01       	movw	r18, r8
     a1a:	a5 01       	movw	r20, r10
     a1c:	b6 01       	movw	r22, r12
     a1e:	c7 01       	movw	r24, r14
     a20:	a0 e0       	ldi	r26, 0x00	; 0
     a22:	0e 94 49 18 	call	0x3092	; 0x3092 <__cmpdi2_s8>
     a26:	b1 f1       	breq	.+108    	; 0xa94 <SPIClass::beginTransaction(SPISettings)+0xdc>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:220
    if (temp & 1) {
     a28:	21 70       	andi	r18, 0x01	; 1
     a2a:	30 e0       	ldi	r19, 0x00	; 0
     a2c:	40 e0       	ldi	r20, 0x00	; 0
     a2e:	50 e0       	ldi	r21, 0x00	; 0
     a30:	60 e0       	ldi	r22, 0x00	; 0
     a32:	70 e0       	ldi	r23, 0x00	; 0
     a34:	80 e0       	ldi	r24, 0x00	; 0
     a36:	90 e0       	ldi	r25, 0x00	; 0
     a38:	0e 94 49 18 	call	0x3092	; 0x3092 <__cmpdi2_s8>
     a3c:	f1 f0       	breq	.+60     	; 0xa7a <SPIClass::beginTransaction(SPISettings)+0xc2>
_ZN8SPIClass16beginTransactionE11SPISettings():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:221
      volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(portToPortStruct(shift / 8), shift % 8);
     a3e:	90 e0       	ldi	r25, 0x00	; 0
     a40:	80 e0       	ldi	r24, 0x00	; 0
detachMaskedInterrupts():
     a42:	d8 33       	cpi	r29, 0x38	; 56
     a44:	70 f4       	brcc	.+28     	; 0xa62 <SPIClass::beginTransaction(SPISettings)+0xaa>
     a46:	8d 2f       	mov	r24, r29
     a48:	86 95       	lsr	r24
     a4a:	86 95       	lsr	r24
     a4c:	86 95       	lsr	r24
     a4e:	20 e2       	ldi	r18, 0x20	; 32
     a50:	82 9f       	mul	r24, r18
     a52:	c0 01       	movw	r24, r0
     a54:	11 24       	eor	r1, r1
     a56:	80 5f       	subi	r24, 0xF0	; 240
     a58:	9b 4f       	sbci	r25, 0xFB	; 251
     a5a:	2d 2f       	mov	r18, r29
     a5c:	27 70       	andi	r18, 0x07	; 7
     a5e:	82 0f       	add	r24, r18
     a60:	91 1d       	adc	r25, r1
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:222
      irqMap[shift] = *pin_ctrl_reg;
     a62:	dc 01       	movw	r26, r24
     a64:	4c 91       	ld	r20, X
     a66:	9f 01       	movw	r18, r30
     a68:	2d 0f       	add	r18, r29
     a6a:	31 1d       	adc	r19, r1
     a6c:	d9 01       	movw	r26, r18
     a6e:	50 96       	adiw	r26, 0x10	; 16
     a70:	4c 93       	st	X, r20
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:223
      *pin_ctrl_reg &= ~(PORT_ISC_gm);
     a72:	dc 01       	movw	r26, r24
     a74:	2c 91       	ld	r18, X
     a76:	28 7f       	andi	r18, 0xF8	; 248
     a78:	2c 93       	st	X, r18
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:225
    }
    temp = temp >> 1;
     a7a:	94 01       	movw	r18, r8
     a7c:	a5 01       	movw	r20, r10
     a7e:	b6 01       	movw	r22, r12
     a80:	c7 01       	movw	r24, r14
     a82:	01 e0       	ldi	r16, 0x01	; 1
     a84:	0e 94 1c 18 	call	0x3038	; 0x3038 <__lshrdi3>
     a88:	49 01       	movw	r8, r18
     a8a:	5a 01       	movw	r10, r20
     a8c:	6b 01       	movw	r12, r22
     a8e:	7c 01       	movw	r14, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:226
    shift++;
     a90:	df 5f       	subi	r29, 0xFF	; 255
     a92:	c2 cf       	rjmp	.-124    	; 0xa18 <SPIClass::beginTransaction(SPISettings)+0x60>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:228
  }
  temp = interruptMask_hi;
     a94:	84 84       	ldd	r8, Z+12	; 0x0c
     a96:	95 84       	ldd	r9, Z+13	; 0x0d
     a98:	a6 84       	ldd	r10, Z+14	; 0x0e
     a9a:	b7 84       	ldd	r11, Z+15	; 0x0f
     a9c:	c1 2c       	mov	r12, r1
     a9e:	d1 2c       	mov	r13, r1
     aa0:	76 01       	movw	r14, r12
_ZN8SPIClass16beginTransactionE11SPISettings():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:229
  shift = 32;
     aa2:	d0 e2       	ldi	r29, 0x20	; 32
detachMaskedInterrupts():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:230
  while (temp != 0) {
     aa4:	94 01       	movw	r18, r8
     aa6:	a5 01       	movw	r20, r10
     aa8:	b6 01       	movw	r22, r12
     aaa:	c7 01       	movw	r24, r14
     aac:	a0 e0       	ldi	r26, 0x00	; 0
     aae:	0e 94 49 18 	call	0x3092	; 0x3092 <__cmpdi2_s8>
     ab2:	09 f4       	brne	.+2      	; 0xab6 <SPIClass::beginTransaction(SPISettings)+0xfe>
     ab4:	96 cf       	rjmp	.-212    	; 0x9e2 <SPIClass::beginTransaction(SPISettings)+0x2a>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:231
    if (temp & 1) {
     ab6:	21 70       	andi	r18, 0x01	; 1
     ab8:	30 e0       	ldi	r19, 0x00	; 0
     aba:	40 e0       	ldi	r20, 0x00	; 0
     abc:	50 e0       	ldi	r21, 0x00	; 0
     abe:	60 e0       	ldi	r22, 0x00	; 0
     ac0:	70 e0       	ldi	r23, 0x00	; 0
     ac2:	80 e0       	ldi	r24, 0x00	; 0
     ac4:	90 e0       	ldi	r25, 0x00	; 0
     ac6:	0e 94 49 18 	call	0x3092	; 0x3092 <__cmpdi2_s8>
     aca:	f1 f0       	breq	.+60     	; 0xb08 <SPIClass::beginTransaction(SPISettings)+0x150>
_ZN8SPIClass16beginTransactionE11SPISettings():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:232
      volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(portToPortStruct(shift / 8), shift % 8);
     acc:	90 e0       	ldi	r25, 0x00	; 0
     ace:	80 e0       	ldi	r24, 0x00	; 0
detachMaskedInterrupts():
     ad0:	d8 33       	cpi	r29, 0x38	; 56
     ad2:	70 f4       	brcc	.+28     	; 0xaf0 <SPIClass::beginTransaction(SPISettings)+0x138>
     ad4:	8d 2f       	mov	r24, r29
     ad6:	86 95       	lsr	r24
     ad8:	86 95       	lsr	r24
     ada:	86 95       	lsr	r24
     adc:	b0 e2       	ldi	r27, 0x20	; 32
     ade:	8b 9f       	mul	r24, r27
     ae0:	c0 01       	movw	r24, r0
     ae2:	11 24       	eor	r1, r1
     ae4:	80 5f       	subi	r24, 0xF0	; 240
     ae6:	9b 4f       	sbci	r25, 0xFB	; 251
     ae8:	2d 2f       	mov	r18, r29
     aea:	27 70       	andi	r18, 0x07	; 7
     aec:	82 0f       	add	r24, r18
     aee:	91 1d       	adc	r25, r1
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:233
      irqMap[shift] = *pin_ctrl_reg;
     af0:	dc 01       	movw	r26, r24
     af2:	4c 91       	ld	r20, X
     af4:	9f 01       	movw	r18, r30
     af6:	2d 0f       	add	r18, r29
     af8:	31 1d       	adc	r19, r1
     afa:	d9 01       	movw	r26, r18
     afc:	50 96       	adiw	r26, 0x10	; 16
     afe:	4c 93       	st	X, r20
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:234
      *pin_ctrl_reg &= ~(PORT_ISC_gm);
     b00:	dc 01       	movw	r26, r24
     b02:	2c 91       	ld	r18, X
     b04:	28 7f       	andi	r18, 0xF8	; 248
     b06:	2c 93       	st	X, r18
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:236
    }
    temp = temp >> 1;
     b08:	94 01       	movw	r18, r8
     b0a:	a5 01       	movw	r20, r10
     b0c:	b6 01       	movw	r22, r12
     b0e:	c7 01       	movw	r24, r14
     b10:	01 e0       	ldi	r16, 0x01	; 1
     b12:	0e 94 1c 18 	call	0x3038	; 0x3038 <__lshrdi3>
     b16:	49 01       	movw	r8, r18
     b18:	5a 01       	movw	r10, r20
     b1a:	6b 01       	movw	r12, r22
     b1c:	7c 01       	movw	r14, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:237
    shift++;
     b1e:	df 5f       	subi	r29, 0xFF	; 255
     b20:	c1 cf       	rjmp	.-126    	; 0xaa4 <SPIClass::beginTransaction(SPISettings)+0xec>

00000b22 <UartClass::begin(unsigned long)>:
_ZN9UartClass5beginEm():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.h:257

  public:
    inline             UartClass(volatile USART_t *hwserial_module, uint8_t module_number, uint8_t default_pinset);
    bool                    pins(uint8_t tx, uint8_t rx);
    bool                    swap(uint8_t mux_level = 1);
    void                   begin(uint32_t baud) {begin(baud, SERIAL_8N1);}
     b22:	dc 01       	movw	r26, r24
     b24:	ed 91       	ld	r30, X+
     b26:	fc 91       	ld	r31, X
     b28:	00 88       	ldd	r0, Z+16	; 0x10
     b2a:	f1 89       	ldd	r31, Z+17	; 0x11
     b2c:	e0 2d       	mov	r30, r0
     b2e:	23 e0       	ldi	r18, 0x03	; 3
     b30:	30 e0       	ldi	r19, 0x00	; 0
     b32:	09 94       	ijmp

00000b34 <Adafruit_I2CDevice::begin(bool) [clone .constprop.15]>:
_ZN18Adafruit_I2CDevice5beginEb.constprop.15():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:29
 *    @param  addr_detect Whether we should attempt to detect the I2C address
 * with a scan. 99% of sensors/devices don't mind but once in a while, they spaz
 * on a scan!
 *    @return True if I2C initialized and a device with the addr found
 */
bool Adafruit_I2CDevice::begin(bool addr_detect) {
     b34:	cf 93       	push	r28
     b36:	df 93       	push	r29
     b38:	ec 01       	movw	r28, r24
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:30
  _wire->begin();
     b3a:	a9 81       	ldd	r26, Y+1	; 0x01
     b3c:	ba 81       	ldd	r27, Y+2	; 0x02
TWI_MasterInit():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:58
  #if defined(TWI_MANDS)                            // Check if the user wants to use Master AND Slave
    if (_data->_bools._hostEnabled == 1) {          // Slave is allowed to be enabled, don't re-enable the host though
      return;
    }
  #else                                             // Master OR Slave
    if (_data->_bools._hostEnabled    == 1 ||       // If Master was enabled
     b3e:	1e 96       	adiw	r26, 0x0e	; 14
     b40:	8c 91       	ld	r24, X
     b42:	1e 97       	sbiw	r26, 0x0e	; 14
     b44:	80 76       	andi	r24, 0x60	; 96
     b46:	11 f5       	brne	.+68     	; 0xb8c <Adafruit_I2CDevice::begin(bool) [clone .constprop.15]+0x58>
TWI0_ClearPins():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi_pins.c:110
        PORTB.OUTCLR = 0x03;  // else PB0, PB1
      }
    #elif defined(__AVR_ATtinyxy2__)
      PORTA.OUTCLR = 0x06;  // 8-pin parts always have it on PA1/2
    #else
      PORTB.OUTCLR = 0x03;  // else, zero series, no remapping, it's on PB0, PB1
     b48:	83 e0       	ldi	r24, 0x03	; 3
     b4a:	80 93 26 04 	sts	0x0426, r24	; 0x800426 <vtable for Adafruit_BMP280_Temp+0x7f5060>
TWI_MasterInit():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:75
    }
  #else                                             // Only one TWI is used
    TWI0_ClearPins();                               // Only one option is possible
  #endif

  _data->_bools._hostEnabled    = 1;
     b4e:	1e 96       	adiw	r26, 0x0e	; 14
     b50:	8c 91       	ld	r24, X
     b52:	1e 97       	sbiw	r26, 0x0e	; 14
     b54:	80 62       	ori	r24, 0x20	; 32
     b56:	1e 96       	adiw	r26, 0x0e	; 14
     b58:	8c 93       	st	X, r24
     b5a:	1e 97       	sbiw	r26, 0x0e	; 14
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:76
  _data->_module->MCTRLA        = TWI_ENABLE_bm;  // Master Interrupt flags stay disabled
     b5c:	1c 96       	adiw	r26, 0x0c	; 12
     b5e:	ed 91       	ld	r30, X+
     b60:	fc 91       	ld	r31, X
     b62:	1d 97       	sbiw	r26, 0x0d	; 13
     b64:	81 e0       	ldi	r24, 0x01	; 1
     b66:	83 83       	std	Z+3, r24	; 0x03
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:77
  _data->_module->MSTATUS       = TWI_BUSSTATE_IDLE_gc;
     b68:	85 83       	std	Z+5, r24	; 0x05
TWI_MasterSetBaud():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:235
 *              _module
 *
 *@return     void
 */
void TWI_MasterSetBaud(struct twiData *_data, uint32_t frequency) {
  if (_data->_bools._hostEnabled == 1) {                  // Do something only if the host is enabled.
     b6a:	1e 96       	adiw	r26, 0x0e	; 14
     b6c:	9c 91       	ld	r25, X
     b6e:	1e 97       	sbiw	r26, 0x0e	; 14
     b70:	95 ff       	sbrs	r25, 5
     b72:	0c c0       	rjmp	.+24     	; 0xb8c <Adafruit_I2CDevice::begin(bool) [clone .constprop.15]+0x58>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:237
    uint8_t newBaud = TWI_MasterCalcBaud(frequency);      // get the new Baud value
    uint8_t oldBaud = _data->_module->MBAUD;              // load the old Baud value
     b74:	96 81       	ldd	r25, Z+6	; 0x06
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:238
    if (newBaud != oldBaud) {                             // compare both, in case the code is issuing this before every transmission.
     b76:	9b 35       	cpi	r25, 0x5B	; 91
     b78:	49 f0       	breq	.+18     	; 0xb8c <Adafruit_I2CDevice::begin(bool) [clone .constprop.15]+0x58>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:239
      uint8_t restore = _data->_module->MCTRLA;           // Save the old Master state
     b7a:	23 81       	ldd	r18, Z+3	; 0x03
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:240
      _data->_module->MCTRLA    = 0;                      // Disable Master
     b7c:	13 82       	std	Z+3, r1	; 0x03
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:241
      _data->_module->MBAUD     = newBaud;                // update Baud register
     b7e:	9b e5       	ldi	r25, 0x5B	; 91
     b80:	96 83       	std	Z+6, r25	; 0x06
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:245
      if (frequency >= 600000) {
        _data->_module->CTRLA  |=  TWI_FMPEN_bm;          // Enable FastMode+
      } else {
        _data->_module->CTRLA  &= ~TWI_FMPEN_bm;          // Disable FastMode+
     b82:	90 81       	ld	r25, Z
     b84:	9d 7f       	andi	r25, 0xFD	; 253
     b86:	90 83       	st	Z, r25
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:247
      }
      _data->_module->MCTRLA    = restore;                // restore the old register, thus enabling it again
     b88:	23 83       	std	Z+3, r18	; 0x03
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:248
      _data->_module->MSTATUS   = TWI_BUSSTATE_IDLE_gc;   // Force the state machine into Idle according to the data sheet
     b8a:	85 83       	std	Z+5, r24	; 0x05
_ZN18Adafruit_I2CDevice5beginEb.constprop.15():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:31
  _begun = true;
     b8c:	81 e0       	ldi	r24, 0x01	; 1
     b8e:	8b 83       	std	Y+3, r24	; 0x03
beginTransmission():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:307
  if (__builtin_constant_p(address) > 0x7F) {     // Compile-time check if address is actually 7 bit long
    badArg("Supplied address seems to be 8 bit. Only 7-bit-addresses are supported");
    return;
  }
  // set address of targeted client
  vars._clientAddress = address << 1;
     b90:	88 81       	ld	r24, Y
     b92:	88 0f       	add	r24, r24
     b94:	1f 96       	adiw	r26, 0x0f	; 15
     b96:	8c 93       	st	X, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:308
  (*txHead) = 0;  // fill buffer from 0
     b98:	1f 97       	sbiw	r26, 0x0f	; 15
     b9a:	50 96       	adiw	r26, 0x10	; 16
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:338
 *           17 for lines held low or pullups absent.
 *          255 (-1) for TWI not initialized (begin not called) or bus somehow in "unknown" state.
 */
uint8_t TwoWire::endTransmission(bool sendStop) {
  // transmit (blocking)
  return TWI_MasterWrite(&vars, sendStop);
     b9c:	1c 92       	st	X, r1
endTransmission():
     b9e:	89 81       	ldd	r24, Y+1	; 0x01
     ba0:	9a 81       	ldd	r25, Y+2	; 0x02
     ba2:	61 e0       	ldi	r22, 0x01	; 1
     ba4:	0c 96       	adiw	r24, 0x0c	; 12
     ba6:	55 dd       	rcall	.-1366   	; 0x652 <TWI_MasterWrite>
detected():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:52
    return false;
  }

  // A basic scanner, see if it ACK's
  _wire->beginTransmission(_addr);
  if (_wire->endTransmission() == 0) {
     ba8:	91 e0       	ldi	r25, 0x01	; 1
     baa:	81 11       	cpse	r24, r1
     bac:	90 e0       	ldi	r25, 0x00	; 0
_ZN18Adafruit_I2CDevice5beginEb.constprop.15():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:37

  if (addr_detect) {
    return detected();
  }
  return true;
}
     bae:	89 2f       	mov	r24, r25
     bb0:	df 91       	pop	r29
     bb2:	cf 91       	pop	r28
     bb4:	08 95       	ret

00000bb6 <digitalWrite>:
digitalWrite():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:257
    default:
      break;
  }
}

void digitalWrite(uint8_t pin, uint8_t val) {
     bb6:	cf 93       	push	r28
     bb8:	df 93       	push	r29
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:260
  check_valid_digital_pin(pin);
  /* Get bit mask for pin */
  uint8_t bit_mask = digitalPinToBitMask(pin);
     bba:	8c 30       	cpi	r24, 0x0C	; 12
     bbc:	d8 f5       	brcc	.+118    	; 0xc34 <digitalWrite+0x7e>
check_valid_digital_pin():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:32
#define ARDUINO_MAIN
#include "wiring_private.h"
#include "pins_arduino.h"

inline __attribute__((always_inline)) void check_valid_digital_pin(pin_size_t pin) {
  if (__builtin_constant_p(pin))
     bbe:	90 e0       	ldi	r25, 0x00	; 0
digitalWrite():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:260
}

void digitalWrite(uint8_t pin, uint8_t val) {
  check_valid_digital_pin(pin);
  /* Get bit mask for pin */
  uint8_t bit_mask = digitalPinToBitMask(pin);
     bc0:	dc 01       	movw	r26, r24
     bc2:	a0 56       	subi	r26, 0x60	; 96
     bc4:	bc 44       	sbci	r27, 0x4C	; 76
     bc6:	2c 91       	ld	r18, X
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:261
  if (bit_mask == NOT_A_PIN) {
     bc8:	2f 3f       	cpi	r18, 0xFF	; 255
     bca:	a1 f1       	breq	.+104    	; 0xc34 <digitalWrite+0x7e>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:266
    return;
  }

  /* Get port */
  PORT_t *port = digitalPinToPortStruct(pin);
     bcc:	fc 01       	movw	r30, r24
     bce:	e4 55       	subi	r30, 0x54	; 84
     bd0:	fc 44       	sbci	r31, 0x4C	; 76
     bd2:	e0 81       	ld	r30, Z
     bd4:	30 e2       	ldi	r19, 0x20	; 32
     bd6:	e3 9f       	mul	r30, r19
     bd8:	f0 01       	movw	r30, r0
     bda:	11 24       	eor	r1, r1
     bdc:	fc 5f       	subi	r31, 0xFC	; 252
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:278
  you could digitalWrite() a pin while it's an input, to ensure
  that the value of the port was set correctly when it was
  changed to an output. Code in the wild relies on this behavior.
  */

  if (val == LOW) { /* If LOW */
     bde:	61 11       	cpse	r22, r1
     be0:	2c c0       	rjmp	.+88     	; 0xc3a <digitalWrite+0x84>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:279
    port->OUTCLR = bit_mask;
     be2:	26 83       	std	Z+6, r18	; 0x06
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:296
  } else {
    port->OUTSET = bit_mask;
  }

  /* Input direction */
  if (!(port->DIR & bit_mask)) {
     be4:	30 81       	ld	r19, Z
     be6:	23 23       	and	r18, r19
     be8:	99 f4       	brne	.+38     	; 0xc10 <digitalWrite+0x5a>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:303
      pull up is enabled if this function is called.
      Should we purposely implement this side effect?
    */

    /* Get bit position for getting pin ctrl reg */
    uint8_t bit_pos = digitalPinToBitPosition(pin);
     bea:	ec 01       	movw	r28, r24
     bec:	c0 5a       	subi	r28, 0xA0	; 160
     bee:	dc 44       	sbci	r29, 0x4C	; 76
     bf0:	28 81       	ld	r18, Y
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:306

    /* Calculate where pin control register is */
    volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(port, bit_pos);
     bf2:	30 97       	sbiw	r30, 0x00	; 0
     bf4:	21 f1       	breq	.+72     	; 0xc3e <digitalWrite+0x88>
     bf6:	2f 3f       	cpi	r18, 0xFF	; 255
     bf8:	11 f1       	breq	.+68     	; 0xc3e <digitalWrite+0x88>
     bfa:	70 96       	adiw	r30, 0x10	; 16
     bfc:	e2 0f       	add	r30, r18
     bfe:	f1 1d       	adc	r31, r1
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:309

    /* Save system status and disable interrupts */
    uint8_t status = SREG;
     c00:	3f b7       	in	r19, 0x3f	; 63
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:310
    cli();
     c02:	f8 94       	cli
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:314

    if (val == LOW) {
      /* Disable pullup */
      *pin_ctrl_reg &= ~PORT_PULLUPEN_bm;
     c04:	20 81       	ld	r18, Z
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:312

    /* Save system status and disable interrupts */
    uint8_t status = SREG;
    cli();

    if (val == LOW) {
     c06:	61 11       	cpse	r22, r1
     c08:	1d c0       	rjmp	.+58     	; 0xc44 <digitalWrite+0x8e>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:314
      /* Disable pullup */
      *pin_ctrl_reg &= ~PORT_PULLUPEN_bm;
     c0a:	27 7f       	andi	r18, 0xF7	; 247
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:317
    } else {
      /* Enable pull-up */
      *pin_ctrl_reg |= PORT_PULLUPEN_bm;
     c0c:	20 83       	st	Z, r18
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:321
    }

    /* Restore system status */
    SREG = status;
     c0e:	3f bf       	out	0x3f, r19	; 63
turnOffPWM():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:176
   * any timers with minimum overhead - critical on these parts
   * Since nothing that will show up here can have more than one
   * one bit set, binary and will give 0x00 if that bit is cleared
   * which is NOT_ON_TIMER.
   */
  uint8_t digital_pin_timer =  digitalPinToTimer(pin) & PeripheralControl;
     c10:	8c 5a       	subi	r24, 0xAC	; 172
     c12:	9c 44       	sbci	r25, 0x4C	; 76
     c14:	fc 01       	movw	r30, r24
     c16:	80 81       	ld	r24, Z
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:178
  /* end megaTinyCore-specific section */
  if (digital_pin_timer== NOT_ON_TIMER) {
     c18:	88 23       	and	r24, r24
     c1a:	61 f0       	breq	.+24     	; 0xc34 <digitalWrite+0x7e>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:185
  }

  uint8_t bit_mask = digitalPinToBitMask(pin);
  // TCB_t *timerB;

  switch (digital_pin_timer) {
     c1c:	80 31       	cpi	r24, 0x10	; 16
     c1e:	51 f4       	brne	.+20     	; 0xc34 <digitalWrite+0x7e>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:182
  /* end megaTinyCore-specific section */
  if (digital_pin_timer== NOT_ON_TIMER) {
    return;
  }

  uint8_t bit_mask = digitalPinToBitMask(pin);
     c20:	8c 91       	ld	r24, X
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:197
      #ifdef __AVR_ATtinyxy2__
        if (bit_mask == 0x80) {
          bit_mask = 1;  // on the xy2, WO0 is on PA7
        }
      #endif
      if (bit_mask > 0x04) { // -> bit_pos > 2 -> output channel controlled by HCMP
     c22:	85 30       	cpi	r24, 0x05	; 5
     c24:	08 f0       	brcs	.+2      	; 0xc28 <digitalWrite+0x72>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:198
        bit_mask <<= 1;      // mind the gap (between LCMP and HCMP)
     c26:	88 0f       	add	r24, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:201
      }
      // since we're turning it off, we don't need to change the CMP register
      TCA0.SPLIT.CTRLB &= ~bit_mask;
     c28:	90 91 01 0a 	lds	r25, 0x0A01	; 0x800a01 <vtable for Adafruit_BMP280_Temp+0x7f563b>
     c2c:	80 95       	com	r24
     c2e:	89 23       	and	r24, r25
     c30:	80 93 01 0a 	sts	0x0A01, r24	; 0x800a01 <vtable for Adafruit_BMP280_Temp+0x7f563b>
digitalWrite():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:334
   * analogWritten() 255, then digitallyWritten() to HIGH, which
   * would turn it off for the time between turnOffPWM() and
   * PORT->OUTCLR)
   * Since there's no penalty, why make a glitch we don't have to? */
  turnOffPWM(pin);
}
     c34:	df 91       	pop	r29
     c36:	cf 91       	pop	r28
     c38:	08 95       	ret
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:292
    // val will now be 0 (LOW) if the toggling made it LOW
    // or bit_mask if not. And further down, we only need to
    // know if it's
  /* If HIGH OR  > TOGGLE  */
  } else {
    port->OUTSET = bit_mask;
     c3a:	25 83       	std	Z+5, r18	; 0x05
     c3c:	d3 cf       	rjmp	.-90     	; 0xbe4 <digitalWrite+0x2e>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:306

    /* Get bit position for getting pin ctrl reg */
    uint8_t bit_pos = digitalPinToBitPosition(pin);

    /* Calculate where pin control register is */
    volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(port, bit_pos);
     c3e:	f0 e0       	ldi	r31, 0x00	; 0
     c40:	e0 e0       	ldi	r30, 0x00	; 0
     c42:	de cf       	rjmp	.-68     	; 0xc00 <digitalWrite+0x4a>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:317
    if (val == LOW) {
      /* Disable pullup */
      *pin_ctrl_reg &= ~PORT_PULLUPEN_bm;
    } else {
      /* Enable pull-up */
      *pin_ctrl_reg |= PORT_PULLUPEN_bm;
     c44:	28 60       	ori	r18, 0x08	; 8
     c46:	e2 cf       	rjmp	.-60     	; 0xc0c <digitalWrite+0x56>

00000c48 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char) [clone .constprop.35]>:
_ZN18Adafruit_SPIDevice15write_then_readEPhjS0_jh.constprop.35():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:391
 *    @param  sendvalue The 8-bits of data to write when doing the data read,
 * defaults to 0xFF
 *    @return Always returns true because there's no way to test success of SPI
 * writes
 */
bool Adafruit_SPIDevice::write_then_read(uint8_t *write_buffer,
     c48:	cf 92       	push	r12
     c4a:	df 92       	push	r13
     c4c:	ef 92       	push	r14
     c4e:	ff 92       	push	r15
     c50:	0f 93       	push	r16
     c52:	1f 93       	push	r17
     c54:	cf 93       	push	r28
     c56:	df 93       	push	r29
     c58:	ec 01       	movw	r28, r24
     c5a:	8b 01       	movw	r16, r22
     c5c:	6a 01       	movw	r12, r20
     c5e:	79 01       	movw	r14, r18
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:394
                                         size_t write_len, uint8_t *read_buffer,
                                         size_t read_len, uint8_t sendvalue) {
  if (_spi) {
     c60:	88 81       	ld	r24, Y
     c62:	99 81       	ldd	r25, Y+1	; 0x01
     c64:	00 97       	sbiw	r24, 0x00	; 0
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:395
    _spi->beginTransaction(*_spiSetting);
     c66:	29 f0       	breq	.+10     	; 0xc72 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char) [clone .constprop.35]+0x2a>
     c68:	ea 81       	ldd	r30, Y+2	; 0x02
     c6a:	fb 81       	ldd	r31, Y+3	; 0x03
     c6c:	60 81       	ld	r22, Z
     c6e:	71 81       	ldd	r23, Z+1	; 0x01
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:398
  }

  digitalWrite(_cs, LOW);
     c70:	a3 de       	rcall	.-698    	; 0x9b8 <SPIClass::beginTransaction(SPISettings)>
     c72:	60 e0       	ldi	r22, 0x00	; 0
     c74:	8b 85       	ldd	r24, Y+11	; 0x0b
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:401
  // do the writing
  for (size_t i = 0; i < write_len; i++) {
    transfer(write_buffer[i]);
     c76:	9f df       	rcall	.-194    	; 0xbb6 <digitalWrite>
     c78:	f8 01       	movw	r30, r16
     c7a:	60 81       	ld	r22, Z
     c7c:	ce 01       	movw	r24, r28
     c7e:	3a dd       	rcall	.-1420   	; 0x6f4 <Adafruit_SPIDevice::transfer(unsigned char)>
     c80:	86 01       	movw	r16, r12
     c82:	ec 0c       	add	r14, r12
     c84:	fd 1c       	adc	r15, r13
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:419
  DEBUG_SERIAL.println();
#endif

  // do the reading
  for (size_t i = 0; i < read_len; i++) {
    read_buffer[i] = transfer(sendvalue);
     c86:	6f ef       	ldi	r22, 0xFF	; 255
     c88:	ce 01       	movw	r24, r28
     c8a:	34 dd       	rcall	.-1432   	; 0x6f4 <Adafruit_SPIDevice::transfer(unsigned char)>
     c8c:	f8 01       	movw	r30, r16
     c8e:	81 93       	st	Z+, r24
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:418
  }
  DEBUG_SERIAL.println();
#endif

  // do the reading
  for (size_t i = 0; i < read_len; i++) {
     c90:	8f 01       	movw	r16, r30
     c92:	ee 15       	cp	r30, r14
     c94:	ff 05       	cpc	r31, r15
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:435
    }
  }
  DEBUG_SERIAL.println();
#endif

  digitalWrite(_cs, HIGH);
     c96:	b9 f7       	brne	.-18     	; 0xc86 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char) [clone .constprop.35]+0x3e>
     c98:	61 e0       	ldi	r22, 0x01	; 1
     c9a:	8b 85       	ldd	r24, Y+11	; 0x0b
     c9c:	8c df       	rcall	.-232    	; 0xbb6 <digitalWrite>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:437

  if (_spi) {
     c9e:	88 81       	ld	r24, Y
     ca0:	99 81       	ldd	r25, Y+1	; 0x01
     ca2:	00 97       	sbiw	r24, 0x00	; 0
     ca4:	09 f0       	breq	.+2      	; 0xca8 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char) [clone .constprop.35]+0x60>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:438
    _spi->endTransaction();
     ca6:	df dd       	rcall	.-1090   	; 0x866 <SPIClass::endTransaction()>
     ca8:	81 e0       	ldi	r24, 0x01	; 1
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:442
  }

  return true;
}
     caa:	df 91       	pop	r29
     cac:	cf 91       	pop	r28
     cae:	1f 91       	pop	r17
     cb0:	0f 91       	pop	r16
     cb2:	ff 90       	pop	r15
     cb4:	ef 90       	pop	r14
     cb6:	df 90       	pop	r13
     cb8:	cf 90       	pop	r12
     cba:	08 95       	ret

00000cbc <pinMode>:
pinMode():
     cbc:	8c 30       	cpi	r24, 0x0C	; 12
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:136
  return port << 1;
}
void pinMode(uint8_t pin, uint8_t mode) {
  check_valid_digital_pin(pin);         /* generate compile error if a constant that is not a valid pin is used as the pin */
  check_valid_pin_mode(mode);           /* generate compile error if a constant that is not a valid pin mode is used as the mode */
  uint8_t bit_mask = digitalPinToBitMask(pin);
     cbe:	f0 f4       	brcc	.+60     	; 0xcfc <pinMode+0x40>
check_valid_digital_pin():
     cc0:	90 e0       	ldi	r25, 0x00	; 0
pinMode():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:32
#define ARDUINO_MAIN
#include "wiring_private.h"
#include "pins_arduino.h"

inline __attribute__((always_inline)) void check_valid_digital_pin(pin_size_t pin) {
  if (__builtin_constant_p(pin))
     cc2:	fc 01       	movw	r30, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:136
  return port << 1;
}
void pinMode(uint8_t pin, uint8_t mode) {
  check_valid_digital_pin(pin);         /* generate compile error if a constant that is not a valid pin is used as the pin */
  check_valid_pin_mode(mode);           /* generate compile error if a constant that is not a valid pin mode is used as the mode */
  uint8_t bit_mask = digitalPinToBitMask(pin);
     cc4:	e0 56       	subi	r30, 0x60	; 96
     cc6:	fc 44       	sbci	r31, 0x4C	; 76
     cc8:	20 81       	ld	r18, Z
     cca:	2f 3f       	cpi	r18, 0xFF	; 255
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:137
  if ((bit_mask == NOT_A_PIN) || (mode > 3)) {
     ccc:	b9 f0       	breq	.+46     	; 0xcfc <pinMode+0x40>
     cce:	fc 01       	movw	r30, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:140
    return;                             /* ignore invalid pins passed at runtime */
  }
  volatile uint8_t * port_base = ((volatile uint8_t *) (uint16_t)(0x0400 | portToPortBaseOffset(digitalPinToPort(pin))));
     cd0:	e4 55       	subi	r30, 0x54	; 84
     cd2:	fc 44       	sbci	r31, 0x4C	; 76
portToPortBaseOffset():
     cd4:	e0 81       	ld	r30, Z
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:130
  SREG = oldSREG; // re-enable interrupts
}

static inline uint8_t portToPortBaseOffset(uint8_t port);
static inline uint8_t portToPortBaseOffset(uint8_t port) {
  _SWAP(port);
     cd6:	e2 95       	swap	r30
     cd8:	ee 0f       	add	r30, r30
pinMode():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:131
  return port << 1;
     cda:	f0 e0       	ldi	r31, 0x00	; 0
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:140
  check_valid_pin_mode(mode);           /* generate compile error if a constant that is not a valid pin mode is used as the mode */
  uint8_t bit_mask = digitalPinToBitMask(pin);
  if ((bit_mask == NOT_A_PIN) || (mode > 3)) {
    return;                             /* ignore invalid pins passed at runtime */
  }
  volatile uint8_t * port_base = ((volatile uint8_t *) (uint16_t)(0x0400 | portToPortBaseOffset(digitalPinToPort(pin))));
     cdc:	f4 60       	ori	r31, 0x04	; 4
     cde:	60 ff       	sbrs	r22, 0
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:141
  if (mode & 0x01) {
     ce0:	0e c0       	rjmp	.+28     	; 0xcfe <pinMode+0x42>
     ce2:	21 83       	std	Z+1, r18	; 0x01
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:143
    // OUTPUT mode, so write DIRSET with the mask.
    *(port_base + 1) = bit_mask;
     ce4:	80 5a       	subi	r24, 0xA0	; 160
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:152
      *(port_base + 5) = bit_mask;
    } else if (mode == 0) {
      *(port_base + 6) = bit_mask;
    }
  }
  port_base +=(uint8_t) digitalPinToBitPosition(pin) | (uint8_t) 0x10;
     ce6:	9c 44       	sbci	r25, 0x4C	; 76
     ce8:	dc 01       	movw	r26, r24
     cea:	8c 91       	ld	r24, X
     cec:	80 61       	ori	r24, 0x10	; 16
     cee:	e8 0f       	add	r30, r24
     cf0:	f1 1d       	adc	r31, r1
     cf2:	80 81       	ld	r24, Z
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:153
  bit_mask = *port_base;
     cf4:	61 ff       	sbrs	r22, 1
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:154
  if (mode & 2) {
     cf6:	0c c0       	rjmp	.+24     	; 0xd10 <pinMode+0x54>
     cf8:	88 60       	ori	r24, 0x08	; 8
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:155
    bit_mask |= 0x08;
     cfa:	80 83       	st	Z, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:159
  } else {
    bit_mask &= 0xF7;
  }
  *port_base = bit_mask;
     cfc:	08 95       	ret
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:160
}
     cfe:	22 83       	std	Z+2, r18	; 0x02
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:145
  volatile uint8_t * port_base = ((volatile uint8_t *) (uint16_t)(0x0400 | portToPortBaseOffset(digitalPinToPort(pin))));
  if (mode & 0x01) {
    // OUTPUT mode, so write DIRSET with the mask.
    *(port_base + 1) = bit_mask;
  } else {
    *(port_base + 2) = bit_mask;
     d00:	62 30       	cpi	r22, 0x02	; 2
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:146
    if (mode == 2) {
     d02:	11 f4       	brne	.+4      	; 0xd08 <pinMode+0x4c>
     d04:	25 83       	std	Z+5, r18	; 0x05
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:147
      *(port_base + 5) = bit_mask;
     d06:	ee cf       	rjmp	.-36     	; 0xce4 <pinMode+0x28>
     d08:	61 11       	cpse	r22, r1
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:148
    } else if (mode == 0) {
     d0a:	ec cf       	rjmp	.-40     	; 0xce4 <pinMode+0x28>
     d0c:	26 83       	std	Z+6, r18	; 0x06
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:149
      *(port_base + 6) = bit_mask;
     d0e:	ea cf       	rjmp	.-44     	; 0xce4 <pinMode+0x28>
     d10:	87 7f       	andi	r24, 0xF7	; 247
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:157
  port_base +=(uint8_t) digitalPinToBitPosition(pin) | (uint8_t) 0x10;
  bit_mask = *port_base;
  if (mode & 2) {
    bit_mask |= 0x08;
  } else {
    bit_mask &= 0xF7;
     d12:	f3 cf       	rjmp	.-26     	; 0xcfa <pinMode+0x3e>

00000d14 <UartClass::begin(unsigned long, unsigned int)>:
_ZN9UartClass5beginEmj():
     d14:	8f 92       	push	r8
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:470
    _pin_set = 0;
  }
  return false;
}

void UartClass::begin(unsigned long baud, uint16_t options) {
     d16:	9f 92       	push	r9
     d18:	af 92       	push	r10
     d1a:	bf 92       	push	r11
     d1c:	ef 92       	push	r14
     d1e:	ff 92       	push	r15
     d20:	0f 93       	push	r16
     d22:	1f 93       	push	r17
     d24:	cf 93       	push	r28
     d26:	df 93       	push	r29
     d28:	8c 01       	movw	r16, r24
     d2a:	4a 01       	movw	r8, r20
     d2c:	5b 01       	movw	r10, r22
     d2e:	e9 01       	movw	r28, r18
     d30:	dc 01       	movw	r26, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:473
  // Make sure no transmissions are ongoing and USART is disabled in case begin() is called by accident
  // without first calling end()
  if (_state & 1) {
     d32:	50 96       	adiw	r26, 0x10	; 16
     d34:	8c 91       	ld	r24, X
     d36:	50 97       	sbiw	r26, 0x10	; 16
     d38:	80 ff       	sbrs	r24, 0
     d3a:	07 c0       	rjmp	.+14     	; 0xd4a <UartClass::begin(unsigned long, unsigned int)+0x36>
     d3c:	ed 91       	ld	r30, X+
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:474
    this->end();
     d3e:	fc 91       	ld	r31, X
     d40:	02 88       	ldd	r0, Z+18	; 0x12
     d42:	f3 89       	ldd	r31, Z+19	; 0x13
     d44:	e0 2d       	mov	r30, r0
     d46:	c8 01       	movw	r24, r16
     d48:	09 95       	icall
     d4a:	c1 11       	cpse	r28, r1
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:478
  }

  uint8_t ctrlc = (uint8_t) options;
  if (ctrlc == 0) {                         // see if they passed anything in low byte or SERIAL_CONFIG_VALID.
     d4c:	01 c0       	rjmp	.+2      	; 0xd50 <UartClass::begin(unsigned long, unsigned int)+0x3c>
     d4e:	c3 e0       	ldi	r28, 0x03	; 3
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:479
    ctrlc = (uint8_t)SERIAL_8N1;            // low byte of 0 could mean they want SERIAL_5N1. Or that they thought they'd
     d50:	ec 2e       	mov	r14, r28
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:481
  }
  ctrlc &= ~0x04; // Now unset that 0x04 bit if it's set, because none of the values with it set are supported. We use that to smuggle in a "this constant was specified" for 5N1
     d52:	e8 94       	clt
     d54:	e2 f8       	bld	r14, 2
     d56:	fd 2e       	mov	r15, r29
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:482
  uint8_t ctrla = (uint8_t) (options >> 8);// CTRLA will get the remains of the options high byte.
     d58:	cd 2f       	mov	r28, r29
     d5a:	d0 95       	com	r29
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:484
  uint16_t baud_setting = 0;                // at this point it should be able to reuse those 2 registers that it received options in!
  uint8_t   ctrlb = (~ctrla & 0xC0);        // Top two bits (TXEN RXEN), inverted so they match he sense in the registers.
     d5c:	d0 7c       	andi	r29, 0xC0	; 192
     d5e:	b1 ed       	ldi	r27, 0xD1	; 209
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:485
  if (baud   > F_CPU / 16) {            // if this baud is too fast for non-U2X
     d60:	8b 16       	cp	r8, r27
     d62:	b2 e1       	ldi	r27, 0x12	; 18
     d64:	9b 06       	cpc	r9, r27
     d66:	b3 e1       	ldi	r27, 0x13	; 19
     d68:	ab 06       	cpc	r10, r27
     d6a:	b1 04       	cpc	r11, r1
     d6c:	28 f0       	brcs	.+10     	; 0xd78 <UartClass::begin(unsigned long, unsigned int)+0x64>
     d6e:	d2 60       	ori	r29, 0x02	; 2
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:486
        ctrlb   |= USART_RXMODE0_bm;        // set the U2X bit in what will become CTRLB
     d70:	b6 94       	lsr	r11
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:487
        baud   >>= 1;                       // And lower the baud rate by haldf
     d72:	a7 94       	ror	r10
     d74:	97 94       	ror	r9
     d76:	87 94       	ror	r8
     d78:	60 e0       	ldi	r22, 0x00	; 0
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:489
  }
  baud_setting = (((4 * F_CPU) / baud));  // And now the registers that baud was passed in are done.
     d7a:	74 eb       	ldi	r23, 0xB4	; 180
     d7c:	84 ec       	ldi	r24, 0xC4	; 196
     d7e:	94 e0       	ldi	r25, 0x04	; 4
     d80:	a5 01       	movw	r20, r10
     d82:	94 01       	movw	r18, r8
     d84:	0e 94 e6 16 	call	0x2dcc	; 0x2dcc <__udivmodsi4>
     d88:	20 34       	cpi	r18, 0x40	; 64
     d8a:	31 05       	cpc	r19, r1
     d8c:	10 f4       	brcc	.+4      	; 0xd92 <UartClass::begin(unsigned long, unsigned int)+0x7e>
     d8e:	20 e4       	ldi	r18, 0x40	; 64
     d90:	30 e0       	ldi	r19, 0x00	; 0
     d92:	f2 fc       	sbrc	r15, 2
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:495
  if (baud_setting < 64)                      // so set to the maximum baud rate setting.
    baud_setting= 64;       // set the U2X bit in what will become CTRLB
  //} else if (baud < (F_CPU / 16800)) {      // Baud rate is too low
  //  baud_setting = 65535;                   // minimum baud rate.'
                                            // Baud setting done now we do the other options not in CTRLC;
  if (ctrla & 0x04) {                       // is ODME option set?
     d94:	d8 60       	ori	r29, 0x08	; 8
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:496
    ctrlb |= USART_ODME_bm;                 // set the bit in what will become CTRLB
     d96:	8c 2f       	mov	r24, r28
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:498
  }
  ctrla &= 0x2B;                            // Only LBME and RS485 (both of them); will get written to CTRLA, but we leave the event bit.
     d98:	8b 72       	andi	r24, 0x2B	; 43
     d9a:	d7 fd       	sbrc	r29, 7
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:499
  if (ctrlb & USART_RXEN_bm) {              // if RX is to be enabled
     d9c:	80 68       	ori	r24, 0x80	; 128
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:500
    ctrla  |= USART_RXCIE_bm;               // we will want to enable the ISR.
     d9e:	cd 2f       	mov	r28, r29
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:502
  }
  uint8_t setpinmask = ctrlb & 0xC8;        // ODME in bit 3, TX and RX enabled in bit 6, 7
     da0:	c8 7c       	andi	r28, 0xC8	; 200
     da2:	83 ff       	sbrs	r24, 3
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:503
  if ((ctrla & USART_LBME_bm) && (setpinmask == 0xC8)) { // if it's open-drain and loopback, need to set state bit 2.
     da4:	07 c0       	rjmp	.+14     	; 0xdb4 <UartClass::begin(unsigned long, unsigned int)+0xa0>
     da6:	c8 3c       	cpi	r28, 0xC8	; 200
     da8:	29 f4       	brne	.+10     	; 0xdb4 <UartClass::begin(unsigned long, unsigned int)+0xa0>
     daa:	f8 01       	movw	r30, r16
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:504
    _state                 |= 2;            // since that changes some behavior (RXC disabled while sending) // Now we should be able to ST _state.
     dac:	90 89       	ldd	r25, Z+16	; 0x10
     dae:	92 60       	ori	r25, 0x02	; 2
     db0:	90 8b       	std	Z+16, r25	; 0x10
     db2:	c8 ed       	ldi	r28, 0xD8	; 216
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:505
    setpinmask             |= 0x10;         // this tells _set_pins not to disturb the configuration on the RX pin.
     db4:	80 fd       	sbrc	r24, 0
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:507
  }
  if (ctrla & USART_RS485_bm) {             // RS485 mode recorded here too... because we need to set
     db6:	c1 60       	ori	r28, 0x01	; 1
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:508
    setpinmask             |= 0x01;         // set pin output if we need to do that. Datasheet isn't clear
     db8:	ff b6       	in	r15, 0x3f	; 63
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:510
  }
  uint8_t oldSREG = SREG;
     dba:	f8 94       	cli
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:511
  cli();
     dbc:	d8 01       	movw	r26, r16
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:512
  volatile USART_t* MyUSART = _hwserial_module;
     dbe:	1c 96       	adiw	r26, 0x0c	; 12
     dc0:	ed 91       	ld	r30, X+
     dc2:	fc 91       	ld	r31, X
     dc4:	16 82       	std	Z+6, r1	; 0x06
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:513
  (*MyUSART).CTRLB          = 0;            // gotta disable first - some things are enable-locked.
     dc6:	e7 82       	std	Z+7, r14	; 0x07
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:514
  (*MyUSART).CTRLC          = ctrlc;        // No reason not to set first.
     dc8:	20 87       	std	Z+8, r18	; 0x08
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:515
  (*MyUSART).BAUD           = baud_setting; // Wish I could have set it long ago
     dca:	31 87       	std	Z+9, r19	; 0x09
     dcc:	85 ff       	sbrs	r24, 5
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:516
  if (ctrla & 0x20) {                       // Now we have to do a bit of work
     dce:	4d c0       	rjmp	.+154    	; 0xe6a <UartClass::begin(unsigned long, unsigned int)+0x156>
     dd0:	cf 77       	andi	r28, 0x7F	; 127
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:517
    setpinmask             &= 0x7F;         // Remove the RX pin in this case because we get the input from elsewhere.
     dd2:	91 e0       	ldi	r25, 0x01	; 1
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:518
    (*MyUSART).EVCTRL       = 1;            // enable event input - not clear from datasheet what's needed to
     dd4:	94 87       	std	Z+12, r25	; 0x0c
     dd6:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:519
    (*MyUSART).TXPLCTRL     = 0xFF;         // Disable pulse length encoding.
     dd8:	95 87       	std	Z+13, r25	; 0x0d
     dda:	8f 7d       	andi	r24, 0xDF	; 223
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:523
  } else {
    (*MyUSART).EVCTRL       = 0;            // This needs to be turned off when not in use.
  }                                         // finally strip out the SERIAL_EVENT_RX bit which is in the DREIE
  (*MyUSART).CTRLA          = ctrla & 0xDF; // position, which we never set in begin.
     ddc:	85 83       	std	Z+5, r24	; 0x05
     dde:	d6 83       	std	Z+6, r29	; 0x06
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:524
  (*MyUSART).CTRLB          = ctrlb;        // Set the all important CTRLB...
     de0:	f8 01       	movw	r30, r16
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:525
  _set_pins(_module_number, _pin_set, setpinmask); // set up the pin(s)
     de2:	47 85       	ldd	r20, Z+15	; 0x0f
     de4:	86 85       	ldd	r24, Z+14	; 0x0e
_set_pins():
     de6:	90 91 e2 05 	lds	r25, 0x05E2	; 0x8005e2 <vtable for Adafruit_BMP280_Temp+0x7f521c>
_ZN9UartClass5beginEmj():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:532
}

void UartClass::_set_pins(uint8_t mod_nbr, uint8_t mux_set, uint8_t enmask) {
  // Set the mux register
  #if defined(PORTMUX_USARTROUTEA)
    uint8_t muxregval    = PORTMUX.USARTROUTEA;
     dea:	2c ef       	ldi	r18, 0xFC	; 252
_set_pins():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:533
    muxregval           &= ~(mod_nbr ? 0x0C : 0x03);
     dec:	81 11       	cpse	r24, r1
_ZN9UartClass5beginEmj():
     dee:	23 ef       	ldi	r18, 0xF3	; 243
_set_pins():
     df0:	92 23       	and	r25, r18
     df2:	24 2f       	mov	r18, r20
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:534
    PORTMUX.USARTROUTEA  = (muxregval) | (mux_set << (mod_nbr ? 2 : 0)); // shift muxset left if needed.
     df4:	30 e0       	ldi	r19, 0x00	; 0
_ZN9UartClass5beginEmj():
     df6:	50 e0       	ldi	r21, 0x00	; 0
_set_pins():
     df8:	81 11       	cpse	r24, r1
_ZN9UartClass5beginEmj():
     dfa:	52 e0       	ldi	r21, 0x02	; 2
_set_pins():
     dfc:	b9 01       	movw	r22, r18
     dfe:	01 c0       	rjmp	.+2      	; 0xe02 <UartClass::begin(unsigned long, unsigned int)+0xee>
     e00:	66 0f       	add	r22, r22
     e02:	5a 95       	dec	r21
     e04:	ea f7       	brpl	.-6      	; 0xe00 <UartClass::begin(unsigned long, unsigned int)+0xec>
     e06:	96 2b       	or	r25, r22
     e08:	90 93 e2 05 	sts	0x05E2, r25	; 0x8005e2 <vtable for Adafruit_BMP280_Temp+0x7f521c>
     e0c:	43 30       	cpi	r20, 0x03	; 3
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:544
    } else {
      PORTMUX.CTRLB       &= 0xFE;
    }
  #endif
  #if MEGATINYCORE_SERIES == 2
    if (mux_set == 3) { // not connected to pins...
     e0e:	09 f1       	breq	.+66     	; 0xe52 <UartClass::begin(unsigned long, unsigned int)+0x13e>
     e10:	82 0f       	add	r24, r18
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:548
      return;           // so we are done!
    }
  #endif
  const uint8_t* muxrow = &(_usart_pins[mod_nbr + mux_set][0]);
     e12:	93 2f       	mov	r25, r19
     e14:	91 1d       	adc	r25, r1
     e16:	88 0f       	add	r24, r24
     e18:	99 1f       	adc	r25, r25
     e1a:	88 0f       	add	r24, r24
     e1c:	99 1f       	adc	r25, r25
     e1e:	8c 01       	movw	r16, r24
     e20:	04 59       	subi	r16, 0x94	; 148
     e22:	1c 44       	sbci	r17, 0x4C	; 76
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:549
  if ((enmask & 0x40 && !(enmask & 0x08))) {
     e24:	c6 ff       	sbrs	r28, 6
     e26:	23 c0       	rjmp	.+70     	; 0xe6e <UartClass::begin(unsigned long, unsigned int)+0x15a>
     e28:	c3 fd       	sbrc	r28, 3
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:550
    pinMode(muxrow[0], OUTPUT); // If and only if TX is enabled and open drain isn't should the TX pin be output.
     e2a:	21 c0       	rjmp	.+66     	; 0xe6e <UartClass::begin(unsigned long, unsigned int)+0x15a>
     e2c:	61 e0       	ldi	r22, 0x01	; 1
     e2e:	d8 01       	movw	r26, r16
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:553
  } else if (enmask & 0x50) { // if it is enabled but is in open drain mode, or is disabled, but loopback is enabled
    // TX should be INPUT_PULLUP.
    pinMode(muxrow[0], INPUT_PULLUP);
     e30:	8c 91       	ld	r24, X
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:555
  }
  if (enmask & 0x80 && !(enmask & 0x10)) {
     e32:	44 df       	rcall	.-376    	; 0xcbc <pinMode>
     e34:	c7 ff       	sbrs	r28, 7
     e36:	07 c0       	rjmp	.+14     	; 0xe46 <UartClass::begin(unsigned long, unsigned int)+0x132>
     e38:	c4 fd       	sbrc	r28, 4
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:557
    // Likewise if RX is enabled, unless loopback mode is too (in which case we caught it above, it should be pulled up
    pinMode(muxrow[1], INPUT_PULLUP);
     e3a:	05 c0       	rjmp	.+10     	; 0xe46 <UartClass::begin(unsigned long, unsigned int)+0x132>
     e3c:	62 e0       	ldi	r22, 0x02	; 2
     e3e:	d8 01       	movw	r26, r16
     e40:	11 96       	adiw	r26, 0x01	; 1
     e42:	8c 91       	ld	r24, X
     e44:	3b df       	rcall	.-394    	; 0xcbc <pinMode>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:559
  }
  if (enmask & 0x01) { // finally if RS485 mode is enabled, we make XDIR output, otherwise it can't drive the pin.
     e46:	c0 ff       	sbrs	r28, 0
     e48:	04 c0       	rjmp	.+8      	; 0xe52 <UartClass::begin(unsigned long, unsigned int)+0x13e>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:560
    pinMode(muxrow[3], OUTPUT); // make XDIR output.
     e4a:	61 e0       	ldi	r22, 0x01	; 1
     e4c:	f8 01       	movw	r30, r16
     e4e:	83 81       	ldd	r24, Z+3	; 0x03
     e50:	35 df       	rcall	.-406    	; 0xcbc <pinMode>
_ZN9UartClass5beginEmj():
     e52:	ff be       	out	0x3f, r15	; 63
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:526
    (*MyUSART).EVCTRL       = 0;            // This needs to be turned off when not in use.
  }                                         // finally strip out the SERIAL_EVENT_RX bit which is in the DREIE
  (*MyUSART).CTRLA          = ctrla & 0xDF; // position, which we never set in begin.
  (*MyUSART).CTRLB          = ctrlb;        // Set the all important CTRLB...
  _set_pins(_module_number, _pin_set, setpinmask); // set up the pin(s)
  SREG = oldSREG;                             // re-enable interrupts, and we're done.
     e54:	df 91       	pop	r29
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:527
}
     e56:	cf 91       	pop	r28
     e58:	1f 91       	pop	r17
     e5a:	0f 91       	pop	r16
     e5c:	ff 90       	pop	r15
     e5e:	ef 90       	pop	r14
     e60:	bf 90       	pop	r11
     e62:	af 90       	pop	r10
     e64:	9f 90       	pop	r9
     e66:	8f 90       	pop	r8
     e68:	08 95       	ret
     e6a:	14 86       	std	Z+12, r1	; 0x0c
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:521
  if (ctrla & 0x20) {                       // Now we have to do a bit of work
    setpinmask             &= 0x7F;         // Remove the RX pin in this case because we get the input from elsewhere.
    (*MyUSART).EVCTRL       = 1;            // enable event input - not clear from datasheet what's needed to
    (*MyUSART).TXPLCTRL     = 0xFF;         // Disable pulse length encoding.
  } else {
    (*MyUSART).EVCTRL       = 0;            // This needs to be turned off when not in use.
     e6c:	b6 cf       	rjmp	.-148    	; 0xdda <UartClass::begin(unsigned long, unsigned int)+0xc6>
_set_pins():
     e6e:	2c 2f       	mov	r18, r28
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:551
    }
  #endif
  const uint8_t* muxrow = &(_usart_pins[mod_nbr + mux_set][0]);
  if ((enmask & 0x40 && !(enmask & 0x08))) {
    pinMode(muxrow[0], OUTPUT); // If and only if TX is enabled and open drain isn't should the TX pin be output.
  } else if (enmask & 0x50) { // if it is enabled but is in open drain mode, or is disabled, but loopback is enabled
     e70:	20 75       	andi	r18, 0x50	; 80
     e72:	01 f3       	breq	.-64     	; 0xe34 <UartClass::begin(unsigned long, unsigned int)+0x120>
     e74:	84 59       	subi	r24, 0x94	; 148
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:553
    // TX should be INPUT_PULLUP.
    pinMode(muxrow[0], INPUT_PULLUP);
     e76:	9c 44       	sbci	r25, 0x4C	; 76
     e78:	62 e0       	ldi	r22, 0x02	; 2
     e7a:	fc 01       	movw	r30, r24
     e7c:	80 81       	ld	r24, Z
     e7e:	d9 cf       	rjmp	.-78     	; 0xe32 <UartClass::begin(unsigned long, unsigned int)+0x11e>

00000e80 <Print::write(char const*) [clone .part.2] [clone .constprop.51]>:
_ZN5Print5writeEPKc.part.2.constprop.51():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.h:56
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) {
        return 0;
      }
      return write((const uint8_t *)str, strlen(str));
     e80:	fc 01       	movw	r30, r24
     e82:	01 90       	ld	r0, Z+
     e84:	00 20       	and	r0, r0
     e86:	e9 f7       	brne	.-6      	; 0xe82 <Print::write(char const*) [clone .part.2] [clone .constprop.51]+0x2>
     e88:	31 97       	sbiw	r30, 0x01	; 1
     e8a:	af 01       	movw	r20, r30
     e8c:	48 1b       	sub	r20, r24
     e8e:	59 0b       	sbc	r21, r25
     e90:	bc 01       	movw	r22, r24
     e92:	8a e1       	ldi	r24, 0x1A	; 26
     e94:	98 e3       	ldi	r25, 0x38	; 56
     e96:	9d c9       	rjmp	.-3270   	; 0x1d2 <Print::write(unsigned char const*, unsigned int)>

00000e98 <Print::printNumber(unsigned long, unsigned char) [clone .constprop.46]>:
_ZN5Print11printNumberEmh.constprop.46():
     e98:	8f 92       	push	r8
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:215
  return vfprintf_P(&f, (const char *)format, ap);
}

// Private Methods /////////////////////////////////////////////////////////////

size_t Print::printNumber(unsigned long n, uint8_t base) {
     e9a:	9f 92       	push	r9
     e9c:	af 92       	push	r10
     e9e:	bf 92       	push	r11
     ea0:	0f 93       	push	r16
     ea2:	1f 93       	push	r17
     ea4:	cf 93       	push	r28
     ea6:	df 93       	push	r29
     ea8:	cd b7       	in	r28, 0x3d	; 61
     eaa:	de b7       	in	r29, 0x3e	; 62
     eac:	a1 97       	sbiw	r28, 0x21	; 33
     eae:	cd bf       	out	0x3d, r28	; 61
     eb0:	de bf       	out	0x3e, r29	; 62
     eb2:	19 a2       	std	Y+33, r1	; 0x21
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:219
  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
     eb4:	42 30       	cpi	r20, 0x02	; 2
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:222

  // prevent crash if called with base == 1
  if (base < 2) {
     eb6:	08 f4       	brcc	.+2      	; 0xeba <Print::printNumber(unsigned long, unsigned char) [clone .constprop.46]+0x22>
     eb8:	4a e0       	ldi	r20, 0x0A	; 10
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:223
    base = 10;
     eba:	8e 01       	movw	r16, r28
     ebc:	0f 5d       	subi	r16, 0xDF	; 223
     ebe:	1f 4f       	sbci	r17, 0xFF	; 255
     ec0:	84 2e       	mov	r8, r20
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:227
  }

  do {
    char c = n % base;
     ec2:	91 2c       	mov	r9, r1
     ec4:	b1 2c       	mov	r11, r1
     ec6:	a1 2c       	mov	r10, r1
     ec8:	a5 01       	movw	r20, r10
     eca:	94 01       	movw	r18, r8
     ecc:	0e 94 e6 16 	call	0x2dcc	; 0x2dcc <__udivmodsi4>
     ed0:	e6 2f       	mov	r30, r22
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:228
    n /= base;
     ed2:	b9 01       	movw	r22, r18
     ed4:	ca 01       	movw	r24, r20
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:230

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
     ed6:	ea 30       	cpi	r30, 0x0A	; 10
     ed8:	d4 f4       	brge	.+52     	; 0xf0e <Print::printNumber(unsigned long, unsigned char) [clone .constprop.46]+0x76>
     eda:	e0 5d       	subi	r30, 0xD0	; 208
     edc:	d8 01       	movw	r26, r16
     ede:	ee 93       	st	-X, r30
     ee0:	8d 01       	movw	r16, r26
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:231
  } while (n);
     ee2:	23 2b       	or	r18, r19
     ee4:	24 2b       	or	r18, r20
     ee6:	25 2b       	or	r18, r21
     ee8:	79 f7       	brne	.-34     	; 0xec8 <Print::printNumber(unsigned long, unsigned char) [clone .constprop.46]+0x30>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.h:54
    }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) {
        return 0;
     eea:	90 e0       	ldi	r25, 0x00	; 0
     eec:	80 e0       	ldi	r24, 0x00	; 0
write():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.h:53
      setWriteError(0);
    }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) {
     eee:	10 97       	sbiw	r26, 0x00	; 0
     ef0:	11 f0       	breq	.+4      	; 0xef6 <Print::printNumber(unsigned long, unsigned char) [clone .constprop.46]+0x5e>
     ef2:	cd 01       	movw	r24, r26
     ef4:	c5 df       	rcall	.-118    	; 0xe80 <Print::write(char const*) [clone .part.2] [clone .constprop.51]>
_ZN5Print11printNumberEmh.constprop.46():
     ef6:	a1 96       	adiw	r28, 0x21	; 33
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:234

  return write(str);
}
     ef8:	cd bf       	out	0x3d, r28	; 61
     efa:	de bf       	out	0x3e, r29	; 62
     efc:	df 91       	pop	r29
     efe:	cf 91       	pop	r28
     f00:	1f 91       	pop	r17
     f02:	0f 91       	pop	r16
     f04:	bf 90       	pop	r11
     f06:	af 90       	pop	r10
     f08:	9f 90       	pop	r9
     f0a:	8f 90       	pop	r8
     f0c:	08 95       	ret
     f0e:	e9 5c       	subi	r30, 0xC9	; 201
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:230

  do {
    char c = n % base;
    n /= base;

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
     f10:	e5 cf       	rjmp	.-54     	; 0xedc <Print::printNumber(unsigned long, unsigned char) [clone .constprop.46]+0x44>

00000f12 <Print::printFloat(double, unsigned char) [clone .constprop.41]>:
_ZN5Print10printFloatEdh.constprop.41():
     f12:	4f 92       	push	r4
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:236
  } while (n);

  return write(str);
}

size_t Print::printFloat(double number, uint8_t digits) {
     f14:	5f 92       	push	r5
     f16:	6f 92       	push	r6
     f18:	7f 92       	push	r7
     f1a:	8f 92       	push	r8
     f1c:	9f 92       	push	r9
     f1e:	af 92       	push	r10
     f20:	bf 92       	push	r11
     f22:	cf 92       	push	r12
     f24:	df 92       	push	r13
     f26:	ef 92       	push	r14
     f28:	ff 92       	push	r15
     f2a:	0f 93       	push	r16
     f2c:	1f 93       	push	r17
     f2e:	cf 93       	push	r28
     f30:	6b 01       	movw	r12, r22
     f32:	7c 01       	movw	r14, r24
     f34:	74 2e       	mov	r7, r20
     f36:	ac 01       	movw	r20, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:239
  size_t n = 0;

  if (isnan(number)) {
     f38:	9b 01       	movw	r18, r22
     f3a:	0e 94 ba 15 	call	0x2b74	; 0x2b74 <__unordsf2>
     f3e:	88 23       	and	r24, r24
     f40:	91 f0       	breq	.+36     	; 0xf66 <Print::printFloat(double, unsigned char) [clone .constprop.41]+0x54>
write():
     f42:	84 ed       	ldi	r24, 0xD4	; 212
     f44:	93 eb       	ldi	r25, 0xB3	; 179
_ZN5Print10printFloatEdh.constprop.41():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:285
    n += print(toPrint);
    remainder -= toPrint;
  }

  return n;
}
     f46:	cf 91       	pop	r28
     f48:	1f 91       	pop	r17
     f4a:	0f 91       	pop	r16
     f4c:	ff 90       	pop	r15
     f4e:	ef 90       	pop	r14
     f50:	df 90       	pop	r13
     f52:	cf 90       	pop	r12
     f54:	bf 90       	pop	r11
     f56:	af 90       	pop	r10
     f58:	9f 90       	pop	r9
     f5a:	8f 90       	pop	r8
     f5c:	7f 90       	pop	r7
     f5e:	6f 90       	pop	r6
     f60:	5f 90       	pop	r5
     f62:	4f 90       	pop	r4
write():
     f64:	8d cf       	rjmp	.-230    	; 0xe80 <Print::write(char const*) [clone .part.2] [clone .constprop.51]>
_ZN5Print10printFloatEdh.constprop.41():
     f66:	46 01       	movw	r8, r12
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:242
  size_t n = 0;

  if (isnan(number)) {
    return print("nan");
  }
  if (isinf(number)) {
     f68:	57 01       	movw	r10, r14
     f6a:	e8 94       	clt
     f6c:	b7 f8       	bld	r11, 7
     f6e:	2f ef       	ldi	r18, 0xFF	; 255
     f70:	3f ef       	ldi	r19, 0xFF	; 255
     f72:	4f e7       	ldi	r20, 0x7F	; 127
     f74:	5f e7       	ldi	r21, 0x7F	; 127
     f76:	c5 01       	movw	r24, r10
     f78:	b4 01       	movw	r22, r8
     f7a:	0e 94 ba 15 	call	0x2b74	; 0x2b74 <__unordsf2>
     f7e:	81 11       	cpse	r24, r1
     f80:	0d c0       	rjmp	.+26     	; 0xf9c <Print::printFloat(double, unsigned char) [clone .constprop.41]+0x8a>
     f82:	2f ef       	ldi	r18, 0xFF	; 255
     f84:	3f ef       	ldi	r19, 0xFF	; 255
     f86:	4f e7       	ldi	r20, 0x7F	; 127
     f88:	5f e7       	ldi	r21, 0x7F	; 127
     f8a:	c5 01       	movw	r24, r10
     f8c:	b4 01       	movw	r22, r8
     f8e:	0e 94 6b 13 	call	0x26d6	; 0x26d6 <__cmpsf2>
     f92:	18 16       	cp	r1, r24
     f94:	1c f4       	brge	.+6      	; 0xf9c <Print::printFloat(double, unsigned char) [clone .constprop.41]+0x8a>
write():
     f96:	88 ed       	ldi	r24, 0xD8	; 216
     f98:	93 eb       	ldi	r25, 0xB3	; 179
     f9a:	d5 cf       	rjmp	.-86     	; 0xf46 <Print::printFloat(double, unsigned char) [clone .constprop.41]+0x34>
_ZN5Print10printFloatEdh.constprop.41():
     f9c:	2f ef       	ldi	r18, 0xFF	; 255
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:245
    return print("inf");
  }
  if (number > 4294967040.0) {
     f9e:	3f ef       	ldi	r19, 0xFF	; 255
     fa0:	4f e7       	ldi	r20, 0x7F	; 127
     fa2:	5f e4       	ldi	r21, 0x4F	; 79
     fa4:	c7 01       	movw	r24, r14
     fa6:	b6 01       	movw	r22, r12
     fa8:	0e 94 07 15 	call	0x2a0e	; 0x2a0e <__gesf2>
     fac:	18 16       	cp	r1, r24
     fae:	1c f4       	brge	.+6      	; 0xfb6 <Print::printFloat(double, unsigned char) [clone .constprop.41]+0xa4>
write():
     fb0:	8c ed       	ldi	r24, 0xDC	; 220
     fb2:	93 eb       	ldi	r25, 0xB3	; 179
     fb4:	c8 cf       	rjmp	.-112    	; 0xf46 <Print::printFloat(double, unsigned char) [clone .constprop.41]+0x34>
_ZN5Print10printFloatEdh.constprop.41():
     fb6:	2f ef       	ldi	r18, 0xFF	; 255
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:248
    return print("ovf");  // constant determined empirically
  }
  if (number < -4294967040.0) {
     fb8:	3f ef       	ldi	r19, 0xFF	; 255
     fba:	4f e7       	ldi	r20, 0x7F	; 127
     fbc:	5f ec       	ldi	r21, 0xCF	; 207
     fbe:	c7 01       	movw	r24, r14
     fc0:	b6 01       	movw	r22, r12
     fc2:	0e 94 6b 13 	call	0x26d6	; 0x26d6 <__cmpsf2>
     fc6:	87 fd       	sbrc	r24, 7
     fc8:	f3 cf       	rjmp	.-26     	; 0xfb0 <Print::printFloat(double, unsigned char) [clone .constprop.41]+0x9e>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:253
    return print("ovf");  // constant determined empirically
  }

  // Handle negative numbers
  if (number < 0.0) {
     fca:	20 e0       	ldi	r18, 0x00	; 0
     fcc:	30 e0       	ldi	r19, 0x00	; 0
     fce:	a9 01       	movw	r20, r18
     fd0:	c7 01       	movw	r24, r14
     fd2:	b6 01       	movw	r22, r12
     fd4:	0e 94 6b 13 	call	0x26d6	; 0x26d6 <__cmpsf2>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:237

  return write(str);
}

size_t Print::printFloat(double number, uint8_t digits) {
  size_t n = 0;
     fd8:	10 e0       	ldi	r17, 0x00	; 0
     fda:	00 e0       	ldi	r16, 0x00	; 0
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:253
  if (number < -4294967040.0) {
    return print("ovf");  // constant determined empirically
  }

  // Handle negative numbers
  if (number < 0.0) {
     fdc:	87 ff       	sbrs	r24, 7
     fde:	09 c0       	rjmp	.+18     	; 0xff2 <Print::printFloat(double, unsigned char) [clone .constprop.41]+0xe0>
print():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:71
size_t Print::print(const char str[]) {
  return write(str);
}

size_t Print::print(char c) {
  return write(c);
     fe0:	6d e2       	ldi	r22, 0x2D	; 45
     fe2:	8a e1       	ldi	r24, 0x1A	; 26
     fe4:	98 e3       	ldi	r25, 0x38	; 56
     fe6:	94 d9       	rcall	.-3288   	; 0x310 <UartClass::write(unsigned char)>
     fe8:	8c 01       	movw	r16, r24
_ZN5Print10printFloatEdh.constprop.41():
     fea:	f7 fa       	bst	r15, 7
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:255
  }

  // Handle negative numbers
  if (number < 0.0) {
    n += print('-');
    number = -number;
     fec:	f0 94       	com	r15
     fee:	f7 f8       	bld	r15, 7
     ff0:	f0 94       	com	r15
     ff2:	c0 e0       	ldi	r28, 0x00	; 0
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:260
  }

  // Round correctly so that print(1.999, 2) prints as "2.00"
  double rounding = 0.5;
  for (uint8_t i = 0; i < digits; ++i) {
     ff4:	60 e0       	ldi	r22, 0x00	; 0
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:259
    n += print('-');
    number = -number;
  }

  // Round correctly so that print(1.999, 2) prints as "2.00"
  double rounding = 0.5;
     ff6:	70 e0       	ldi	r23, 0x00	; 0
     ff8:	80 e0       	ldi	r24, 0x00	; 0
     ffa:	9f e3       	ldi	r25, 0x3F	; 63
     ffc:	7c 16       	cp	r7, r28
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:260
  for (uint8_t i = 0; i < digits; ++i) {
     ffe:	41 f0       	breq	.+16     	; 0x1010 <Print::printFloat(double, unsigned char) [clone .constprop.41]+0xfe>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:261
    rounding /= 10.0;
    1000:	20 e0       	ldi	r18, 0x00	; 0
    1002:	30 e0       	ldi	r19, 0x00	; 0
    1004:	40 e2       	ldi	r20, 0x20	; 32
    1006:	51 e4       	ldi	r21, 0x41	; 65
    1008:	0e 94 6f 13 	call	0x26de	; 0x26de <__divsf3>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:260
    number = -number;
  }

  // Round correctly so that print(1.999, 2) prints as "2.00"
  double rounding = 0.5;
  for (uint8_t i = 0; i < digits; ++i) {
    100c:	cf 5f       	subi	r28, 0xFF	; 255
    100e:	f6 cf       	rjmp	.-20     	; 0xffc <Print::printFloat(double, unsigned char) [clone .constprop.41]+0xea>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:264
    rounding /= 10.0;
  }

  number += rounding;
    1010:	a7 01       	movw	r20, r14
    1012:	96 01       	movw	r18, r12
    1014:	0e 94 07 13 	call	0x260e	; 0x260e <__addsf3>
    1018:	2b 01       	movw	r4, r22
    101a:	3c 01       	movw	r6, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:267

  // Extract the integer part of the number and print it
  unsigned long int_part = (unsigned long)number;
    101c:	0e 94 d7 13 	call	0x27ae	; 0x27ae <__fixunssfsi>
    1020:	4b 01       	movw	r8, r22
    1022:	5c 01       	movw	r10, r24
print():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:105

size_t Print::print(unsigned long n, int base) {
  if (base == 0) {
    return write(n);
  } else {
    return printNumber(n, base);
    1024:	4a e0       	ldi	r20, 0x0A	; 10
    1026:	38 df       	rcall	.-400    	; 0xe98 <Print::printNumber(unsigned long, unsigned char) [clone .constprop.46]>
_ZN5Print10printFloatEdh.constprop.41():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:269
  number += rounding;

  // Extract the integer part of the number and print it
  unsigned long int_part = (unsigned long)number;
  double remainder = number - (double)int_part;
  n += print(int_part);
    1028:	7c 01       	movw	r14, r24
    102a:	e0 0e       	add	r14, r16
    102c:	f1 1e       	adc	r15, r17
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:272

  // Print the decimal point, but only if there are digits beyond
  if (digits > 0) {
    102e:	cc 23       	and	r28, r28
    1030:	a9 f1       	breq	.+106    	; 0x109c <Print::printFloat(double, unsigned char) [clone .constprop.41]+0x18a>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:268

  number += rounding;

  // Extract the integer part of the number and print it
  unsigned long int_part = (unsigned long)number;
  double remainder = number - (double)int_part;
    1032:	c5 01       	movw	r24, r10
    1034:	b4 01       	movw	r22, r8
    1036:	0e 94 07 14 	call	0x280e	; 0x280e <__floatunsisf>
    103a:	9b 01       	movw	r18, r22
    103c:	ac 01       	movw	r20, r24
    103e:	c3 01       	movw	r24, r6
    1040:	b2 01       	movw	r22, r4
    1042:	0e 94 06 13 	call	0x260c	; 0x260c <__subsf3>
    1046:	4b 01       	movw	r8, r22
    1048:	5c 01       	movw	r10, r24
write():
    104a:	80 ee       	ldi	r24, 0xE0	; 224
    104c:	93 eb       	ldi	r25, 0xB3	; 179
    104e:	18 df       	rcall	.-464    	; 0xe80 <Print::write(char const*) [clone .part.2] [clone .constprop.51]>
_ZN5Print10printFloatEdh.constprop.41():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:273
  n += print(int_part);

  // Print the decimal point, but only if there are digits beyond
  if (digits > 0) {
    n += print(".");
    1050:	e8 0e       	add	r14, r24
    1052:	f9 1e       	adc	r15, r25
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:277
  }

  // Extract digits from the remainder one at a time
  while (digits-- > 0) {
    1054:	c1 50       	subi	r28, 0x01	; 1
    1056:	10 f1       	brcs	.+68     	; 0x109c <Print::printFloat(double, unsigned char) [clone .constprop.41]+0x18a>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:278
    remainder *= 10.0;
    1058:	20 e0       	ldi	r18, 0x00	; 0
    105a:	30 e0       	ldi	r19, 0x00	; 0
    105c:	40 e2       	ldi	r20, 0x20	; 32
    105e:	51 e4       	ldi	r21, 0x41	; 65
    1060:	c5 01       	movw	r24, r10
    1062:	b4 01       	movw	r22, r8
    1064:	0e 94 0b 15 	call	0x2a16	; 0x2a16 <__mulsf3>
    1068:	2b 01       	movw	r4, r22
    106a:	3c 01       	movw	r6, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:279
    unsigned int toPrint = (unsigned int)remainder;
    106c:	0e 94 d7 13 	call	0x27ae	; 0x27ae <__fixunssfsi>
print():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:83
size_t Print::print(int n, int base) {
  return print((long) n, base);
}

size_t Print::print(unsigned int n, int base) {
  return print((unsigned long) n, base);
    1070:	4b 01       	movw	r8, r22
    1072:	b1 2c       	mov	r11, r1
    1074:	a1 2c       	mov	r10, r1
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:105

size_t Print::print(unsigned long n, int base) {
  if (base == 0) {
    return write(n);
  } else {
    return printNumber(n, base);
    1076:	4a e0       	ldi	r20, 0x0A	; 10
    1078:	c5 01       	movw	r24, r10
    107a:	b4 01       	movw	r22, r8
    107c:	0d df       	rcall	.-486    	; 0xe98 <Print::printNumber(unsigned long, unsigned char) [clone .constprop.46]>
_ZN5Print10printFloatEdh.constprop.41():
    107e:	e8 0e       	add	r14, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:280

  // Extract digits from the remainder one at a time
  while (digits-- > 0) {
    remainder *= 10.0;
    unsigned int toPrint = (unsigned int)remainder;
    n += print(toPrint);
    1080:	f9 1e       	adc	r15, r25
    1082:	c5 01       	movw	r24, r10
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:281
    remainder -= toPrint;
    1084:	b4 01       	movw	r22, r8
    1086:	0e 94 07 14 	call	0x280e	; 0x280e <__floatunsisf>
    108a:	9b 01       	movw	r18, r22
    108c:	ac 01       	movw	r20, r24
    108e:	c3 01       	movw	r24, r6
    1090:	b2 01       	movw	r22, r4
    1092:	0e 94 06 13 	call	0x260c	; 0x260c <__subsf3>
    1096:	4b 01       	movw	r8, r22
    1098:	5c 01       	movw	r10, r24
    109a:	dc cf       	rjmp	.-72     	; 0x1054 <Print::printFloat(double, unsigned char) [clone .constprop.41]+0x142>
    109c:	c7 01       	movw	r24, r14
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:285
  }

  return n;
}
    109e:	cf 91       	pop	r28
    10a0:	1f 91       	pop	r17
    10a2:	0f 91       	pop	r16
    10a4:	ff 90       	pop	r15
    10a6:	ef 90       	pop	r14
    10a8:	df 90       	pop	r13
    10aa:	cf 90       	pop	r12
    10ac:	bf 90       	pop	r11
    10ae:	af 90       	pop	r10
    10b0:	9f 90       	pop	r9
    10b2:	8f 90       	pop	r8
    10b4:	7f 90       	pop	r7
    10b6:	6f 90       	pop	r6
    10b8:	5f 90       	pop	r5
    10ba:	4f 90       	pop	r4
    10bc:	08 95       	ret

000010be <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int) [clone .constprop.33]>:
_ZN18Adafruit_I2CDevice5writeEPKhjbS1_j.constprop.33():
    10be:	2f 92       	push	r2
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:77
 *            ensure the content of this buffer doesn't change.
 *    @param  prefix_len Number of bytes from prefix buffer to write
 *    @param  stop Whether to send an I2C STOP signal on write
 *    @return True if write was successful, otherwise false.
 */
bool Adafruit_I2CDevice::write(const uint8_t *buffer, size_t len, bool stop,
    10c0:	3f 92       	push	r3
    10c2:	4f 92       	push	r4
    10c4:	5f 92       	push	r5
    10c6:	6f 92       	push	r6
    10c8:	7f 92       	push	r7
    10ca:	8f 92       	push	r8
    10cc:	9f 92       	push	r9
    10ce:	af 92       	push	r10
    10d0:	bf 92       	push	r11
    10d2:	cf 92       	push	r12
    10d4:	df 92       	push	r13
    10d6:	ef 92       	push	r14
    10d8:	ff 92       	push	r15
    10da:	0f 93       	push	r16
    10dc:	1f 93       	push	r17
    10de:	cf 93       	push	r28
    10e0:	df 93       	push	r29
    10e2:	00 d0       	rcall	.+0      	; 0x10e4 <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int) [clone .constprop.33]+0x26>
    10e4:	1f 92       	push	r1
    10e6:	cd b7       	in	r28, 0x3d	; 61
    10e8:	de b7       	in	r29, 0x3e	; 62
    10ea:	8c 01       	movw	r16, r24
    10ec:	4b 01       	movw	r8, r22
    10ee:	6a 01       	movw	r12, r20
    10f0:	2b 83       	std	Y+3, r18	; 0x03
    10f2:	2d b6       	in	r2, 0x3d	; 61
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:158
#ifdef DEBUG_SERIAL
    DEBUG_SERIAL.println("Failed to send!");
#endif
    return false;
  }
}
    10f4:	3e b6       	in	r3, 0x3e	; 62
    10f6:	dc 01       	movw	r26, r24
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:80
 *    @return True if write was successful, otherwise false.
 */
bool Adafruit_I2CDevice::write(const uint8_t *buffer, size_t len, bool stop,
                               const uint8_t *prefix_buffer,
                               size_t prefix_len) {
  _wire->beginTransmission(_addr);
    10f8:	11 96       	adiw	r26, 0x01	; 1
    10fa:	ed 91       	ld	r30, X+
    10fc:	fc 91       	ld	r31, X
    10fe:	12 97       	sbiw	r26, 0x02	; 2
beginTransmission():
    1100:	8c 91       	ld	r24, X
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:307
  if (__builtin_constant_p(address) > 0x7F) {     // Compile-time check if address is actually 7 bit long
    badArg("Supplied address seems to be 8 bit. Only 7-bit-addresses are supported");
    return;
  }
  // set address of targeted client
  vars._clientAddress = address << 1;
    1102:	88 0f       	add	r24, r24
    1104:	87 87       	std	Z+15, r24	; 0x0f
    1106:	10 8a       	std	Z+16, r1	; 0x10
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:308
  (*txHead) = 0;  // fill buffer from 0
    1108:	14 96       	adiw	r26, 0x04	; 4
    110a:	6d 90       	ld	r6, X+
    110c:	7c 90       	ld	r7, X
    110e:	15 97       	sbiw	r26, 0x05	; 5
_ZN18Adafruit_I2CDevice5writeEPKhjbS1_j.constprop.33():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:95
    }
  }

  // Write the data itself, chunkify if needed
  size_t bufferSize = maxBufferSize();
  if (bufferSize >= len) {
    1110:	64 16       	cp	r6, r20
    1112:	75 06       	cpc	r7, r21
    1114:	80 f1       	brcs	.+96     	; 0x1176 <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int) [clone .constprop.33]+0xb8>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:97
    // can just write
    if (_wire->write(buffer, len) != len) {
    1116:	11 96       	adiw	r26, 0x01	; 1
    1118:	8d 91       	ld	r24, X+
    111a:	9c 91       	ld	r25, X
    111c:	dc 01       	movw	r26, r24
    111e:	ed 91       	ld	r30, X+
    1120:	fc 91       	ld	r31, X
    1122:	02 80       	ldd	r0, Z+2	; 0x02
    1124:	f3 81       	ldd	r31, Z+3	; 0x03
    1126:	e0 2d       	mov	r30, r0
    1128:	09 95       	icall
    112a:	c8 16       	cp	r12, r24
    112c:	d9 06       	cpc	r13, r25
    112e:	09 f0       	breq	.+2      	; 0x1132 <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int) [clone .constprop.33]+0x74>
    1130:	62 c0       	rjmp	.+196    	; 0x11f6 <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int) [clone .constprop.33]+0x138>
endTransmission():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:338
 *           17 for lines held low or pullups absent.
 *          255 (-1) for TWI not initialized (begin not called) or bus somehow in "unknown" state.
 */
uint8_t TwoWire::endTransmission(bool sendStop) {
  // transmit (blocking)
  return TWI_MasterWrite(&vars, sendStop);
    1132:	f8 01       	movw	r30, r16
    1134:	81 81       	ldd	r24, Z+1	; 0x01
    1136:	92 81       	ldd	r25, Z+2	; 0x02
    1138:	6b 81       	ldd	r22, Y+3	; 0x03
    113a:	0c 96       	adiw	r24, 0x0c	; 12
    113c:	8a da       	rcall	.-2796   	; 0x652 <TWI_MasterWrite>
_ZN18Adafruit_I2CDevice5writeEPKhjbS1_j.constprop.33():
    113e:	91 e0       	ldi	r25, 0x01	; 1
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:147
#ifdef DEBUG_SERIAL
  DEBUG_SERIAL.print("Stop: ");
  DEBUG_SERIAL.println(stop);
#endif

  if (_wire->endTransmission(stop) == 0) {
    1140:	81 11       	cpse	r24, r1
    1142:	59 c0       	rjmp	.+178    	; 0x11f6 <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int) [clone .constprop.33]+0x138>
    1144:	89 2f       	mov	r24, r25
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:158
#ifdef DEBUG_SERIAL
    DEBUG_SERIAL.println("Failed to send!");
#endif
    return false;
  }
}
    1146:	2d be       	out	0x3d, r2	; 61
    1148:	3e be       	out	0x3e, r3	; 62
    114a:	23 96       	adiw	r28, 0x03	; 3
    114c:	cd bf       	out	0x3d, r28	; 61
    114e:	de bf       	out	0x3e, r29	; 62
    1150:	df 91       	pop	r29
    1152:	cf 91       	pop	r28
    1154:	1f 91       	pop	r17
    1156:	0f 91       	pop	r16
    1158:	ff 90       	pop	r15
    115a:	ef 90       	pop	r14
    115c:	df 90       	pop	r13
    115e:	cf 90       	pop	r12
    1160:	bf 90       	pop	r11
    1162:	af 90       	pop	r10
    1164:	9f 90       	pop	r9
    1166:	8f 90       	pop	r8
    1168:	7f 90       	pop	r7
    116a:	6f 90       	pop	r6
    116c:	5f 90       	pop	r5
    116e:	4f 90       	pop	r4
    1170:	3f 90       	pop	r3
    1172:	2f 90       	pop	r2
    1174:	08 95       	ret
    1176:	4d b6       	in	r4, 0x3d	; 61
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:117
#ifdef DEBUG_SERIAL
        DEBUG_SERIAL.println(F("\tI2CDevice failed to write"));
#endif
        return false;
      }
    }
    1178:	5e b6       	in	r5, 0x3e	; 62
    117a:	ed b7       	in	r30, 0x3d	; 61
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:106
      return false;
    }
  } else {
    // must chunkify
    size_t pos = 0;
    uint8_t write_buffer[bufferSize];
    117c:	fe b7       	in	r31, 0x3e	; 62
    117e:	e6 19       	sub	r30, r6
    1180:	f7 09       	sbc	r31, r7
    1182:	ed bf       	out	0x3d, r30	; 61
    1184:	fe bf       	out	0x3e, r31	; 62
    1186:	8d b7       	in	r24, 0x3d	; 61
    1188:	9e b7       	in	r25, 0x3e	; 62
    118a:	01 96       	adiw	r24, 0x01	; 1
    118c:	89 83       	std	Y+1, r24	; 0x01
    118e:	9a 83       	std	Y+2, r25	; 0x02
    1190:	b1 2c       	mov	r11, r1
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:105
#endif
      return false;
    }
  } else {
    // must chunkify
    size_t pos = 0;
    1192:	a1 2c       	mov	r10, r1
    1194:	76 01       	movw	r14, r12
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:108
    uint8_t write_buffer[bufferSize];
    while (pos < len) {
      size_t write_len = len - pos > bufferSize ? bufferSize : len - pos;
    1196:	ea 18       	sub	r14, r10
    1198:	fb 08       	sbc	r15, r11
    119a:	6e 14       	cp	r6, r14
    119c:	7f 04       	cpc	r7, r15
    119e:	08 f4       	brcc	.+2      	; 0x11a2 <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int) [clone .constprop.33]+0xe4>
    11a0:	73 01       	movw	r14, r6
    11a2:	f4 01       	movw	r30, r8
    11a4:	ea 0d       	add	r30, r10
    11a6:	fb 1d       	adc	r31, r11
    11a8:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:109
      for (size_t i = 0; i < write_len; i++)
    11aa:	80 e0       	ldi	r24, 0x00	; 0
    11ac:	5f 01       	movw	r10, r30
    11ae:	a8 18       	sub	r10, r8
    11b0:	b9 08       	sbc	r11, r9
    11b2:	8e 15       	cp	r24, r14
    11b4:	9f 05       	cpc	r25, r15
    11b6:	68 f4       	brcc	.+26     	; 0x11d2 <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int) [clone .constprop.33]+0x114>
    11b8:	81 91       	ld	r24, Z+
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:110
        write_buffer[i] = buffer[pos++];
    11ba:	a9 81       	ldd	r26, Y+1	; 0x01
    11bc:	ba 81       	ldd	r27, Y+2	; 0x02
    11be:	8c 93       	st	X, r24
    11c0:	81 e0       	ldi	r24, 0x01	; 1
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:109
    // must chunkify
    size_t pos = 0;
    uint8_t write_buffer[bufferSize];
    while (pos < len) {
      size_t write_len = len - pos > bufferSize ? bufferSize : len - pos;
      for (size_t i = 0; i < write_len; i++)
    11c2:	90 e0       	ldi	r25, 0x00	; 0
    11c4:	f3 cf       	rjmp	.-26     	; 0x11ac <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int) [clone .constprop.33]+0xee>
    11c6:	ac 14       	cp	r10, r12
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:107
    }
  } else {
    // must chunkify
    size_t pos = 0;
    uint8_t write_buffer[bufferSize];
    while (pos < len) {
    11c8:	bd 04       	cpc	r11, r13
    11ca:	20 f3       	brcs	.-56     	; 0x1194 <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int) [clone .constprop.33]+0xd6>
    11cc:	4d be       	out	0x3d, r4	; 61
    11ce:	5e be       	out	0x3e, r5	; 62
    11d0:	b0 cf       	rjmp	.-160    	; 0x1132 <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int) [clone .constprop.33]+0x74>
    11d2:	f8 01       	movw	r30, r16
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:111
      size_t write_len = len - pos > bufferSize ? bufferSize : len - pos;
      for (size_t i = 0; i < write_len; i++)
        write_buffer[i] = buffer[pos++];
      if (_wire->write(write_buffer, write_len) != write_len) {
    11d4:	81 81       	ldd	r24, Z+1	; 0x01
    11d6:	92 81       	ldd	r25, Z+2	; 0x02
    11d8:	dc 01       	movw	r26, r24
    11da:	ed 91       	ld	r30, X+
    11dc:	fc 91       	ld	r31, X
    11de:	02 80       	ldd	r0, Z+2	; 0x02
    11e0:	f3 81       	ldd	r31, Z+3	; 0x03
    11e2:	e0 2d       	mov	r30, r0
    11e4:	a7 01       	movw	r20, r14
    11e6:	69 81       	ldd	r22, Y+1	; 0x01
    11e8:	7a 81       	ldd	r23, Y+2	; 0x02
    11ea:	09 95       	icall
    11ec:	e8 16       	cp	r14, r24
    11ee:	f9 06       	cpc	r15, r25
    11f0:	51 f3       	breq	.-44     	; 0x11c6 <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int) [clone .constprop.33]+0x108>
    11f2:	4d be       	out	0x3d, r4	; 61
    11f4:	5e be       	out	0x3e, r5	; 62
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:101
    // can just write
    if (_wire->write(buffer, len) != len) {
#ifdef DEBUG_SERIAL
      DEBUG_SERIAL.println(F("\tI2CDevice failed to write"));
#endif
      return false;
    11f6:	90 e0       	ldi	r25, 0x00	; 0
    11f8:	a5 cf       	rjmp	.-182    	; 0x1144 <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int) [clone .constprop.33]+0x86>

000011fa <Adafruit_BMP280::write8(unsigned char, unsigned char) [clone .constprop.24]>:
_ZN15Adafruit_BMP2806write8Ehh.constprop.24():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:143
/**************************************************************************/
/*!
    @brief  Writes an 8 bit value over I2C/SPI
*/
/**************************************************************************/
void Adafruit_BMP280::write8(byte reg, byte value) {
    11fa:	0f 93       	push	r16
    11fc:	1f 93       	push	r17
    11fe:	cf 93       	push	r28
    1200:	df 93       	push	r29
    1202:	00 d0       	rcall	.+0      	; 0x1204 <Adafruit_BMP280::write8(unsigned char, unsigned char) [clone .constprop.24]+0xa>
    1204:	cd b7       	in	r28, 0x3d	; 61
    1206:	de b7       	in	r29, 0x3e	; 62
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:145
  byte buffer[2];
  buffer[1] = value;
    1208:	6a 83       	std	Y+2, r22	; 0x02
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:146
  if (i2c_dev) {
    120a:	e0 91 0b 39 	lds	r30, 0x390B	; 0x80390b <bmp+0x2>
    120e:	f0 91 0c 39 	lds	r31, 0x390C	; 0x80390c <bmp+0x3>
    1212:	30 97       	sbiw	r30, 0x00	; 0
    1214:	81 f0       	breq	.+32     	; 0x1236 <Adafruit_BMP280::write8(unsigned char, unsigned char) [clone .constprop.24]+0x3c>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:147
    buffer[0] = reg;
    1216:	89 83       	std	Y+1, r24	; 0x01
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:148
    i2c_dev->write(buffer, 2);
    1218:	21 e0       	ldi	r18, 0x01	; 1
    121a:	42 e0       	ldi	r20, 0x02	; 2
    121c:	50 e0       	ldi	r21, 0x00	; 0
    121e:	be 01       	movw	r22, r28
    1220:	6f 5f       	subi	r22, 0xFF	; 255
    1222:	7f 4f       	sbci	r23, 0xFF	; 255
    1224:	cf 01       	movw	r24, r30
    1226:	4b df       	rcall	.-362    	; 0x10be <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int) [clone .constprop.33]>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:153
  } else {
    buffer[0] = reg & ~0x80;
    spi_dev->write(buffer, 2);
  }
}
    1228:	0f 90       	pop	r0
    122a:	0f 90       	pop	r0
    122c:	df 91       	pop	r29
    122e:	cf 91       	pop	r28
    1230:	1f 91       	pop	r17
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:150
  buffer[1] = value;
  if (i2c_dev) {
    buffer[0] = reg;
    i2c_dev->write(buffer, 2);
  } else {
    buffer[0] = reg & ~0x80;
    1232:	0f 91       	pop	r16
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:151
    spi_dev->write(buffer, 2);
    1234:	08 95       	ret
    1236:	8f 77       	andi	r24, 0x7F	; 127
    1238:	89 83       	std	Y+1, r24	; 0x01
    123a:	00 91 0d 39 	lds	r16, 0x390D	; 0x80390d <bmp+0x4>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:299
 *    @return Always returns true because there's no way to test success of SPI
 * writes
 */
bool Adafruit_SPIDevice::write(uint8_t *buffer, size_t len,
                               uint8_t *prefix_buffer, size_t prefix_len) {
  if (_spi) {
    123e:	10 91 0e 39 	lds	r17, 0x390E	; 0x80390e <bmp+0x5>
write():
    1242:	d8 01       	movw	r26, r16
    1244:	8d 91       	ld	r24, X+
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:300
    _spi->beginTransaction(*_spiSetting);
    1246:	9c 91       	ld	r25, X
    1248:	11 97       	sbiw	r26, 0x01	; 1
    124a:	00 97       	sbiw	r24, 0x00	; 0
    124c:	31 f0       	breq	.+12     	; 0x125a <Adafruit_BMP280::write8(unsigned char, unsigned char) [clone .constprop.24]+0x60>
    124e:	12 96       	adiw	r26, 0x02	; 2
    1250:	ed 91       	ld	r30, X+
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:303
  }

  digitalWrite(_cs, LOW);
    1252:	fc 91       	ld	r31, X
    1254:	60 81       	ld	r22, Z
    1256:	71 81       	ldd	r23, Z+1	; 0x01
    1258:	af db       	rcall	.-2210   	; 0x9b8 <SPIClass::beginTransaction(SPISettings)>
    125a:	60 e0       	ldi	r22, 0x00	; 0
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:309
  // do the writing
  for (size_t i = 0; i < prefix_len; i++) {
    transfer(prefix_buffer[i]);
  }
  for (size_t i = 0; i < len; i++) {
    transfer(buffer[i]);
    125c:	f8 01       	movw	r30, r16
    125e:	83 85       	ldd	r24, Z+11	; 0x0b
    1260:	aa dc       	rcall	.-1708   	; 0xbb6 <digitalWrite>
    1262:	69 81       	ldd	r22, Y+1	; 0x01
    1264:	c8 01       	movw	r24, r16
    1266:	46 da       	rcall	.-2932   	; 0x6f4 <Adafruit_SPIDevice::transfer(unsigned char)>
    1268:	6a 81       	ldd	r22, Y+2	; 0x02
    126a:	c8 01       	movw	r24, r16
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:311
  }
  digitalWrite(_cs, HIGH);
    126c:	43 da       	rcall	.-2938   	; 0x6f4 <Adafruit_SPIDevice::transfer(unsigned char)>
    126e:	61 e0       	ldi	r22, 0x01	; 1
    1270:	d8 01       	movw	r26, r16
    1272:	1b 96       	adiw	r26, 0x0b	; 11
    1274:	8c 91       	ld	r24, X
    1276:	9f dc       	rcall	.-1730   	; 0xbb6 <digitalWrite>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:313

  if (_spi) {
    1278:	f8 01       	movw	r30, r16
    127a:	80 81       	ld	r24, Z
    127c:	91 81       	ldd	r25, Z+1	; 0x01
    127e:	00 97       	sbiw	r24, 0x00	; 0
    1280:	99 f2       	breq	.-90     	; 0x1228 <Adafruit_BMP280::write8(unsigned char, unsigned char) [clone .constprop.24]+0x2e>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:314
    _spi->endTransaction();
    1282:	f1 da       	rcall	.-2590   	; 0x866 <SPIClass::endTransaction()>
    1284:	d1 cf       	rjmp	.-94     	; 0x1228 <Adafruit_BMP280::write8(unsigned char, unsigned char) [clone .constprop.24]+0x2e>

00001286 <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool) [clone .constprop.32]>:
_ZN18Adafruit_I2CDevice15write_then_readEPKhjPhjb.constprop.32():
    1286:	2f 92       	push	r2
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:238
 *    @param  read_buffer Pointer to buffer of data to read into.
 *    @param  read_len Number of bytes from buffer to read.
 *    @param  stop Whether to send an I2C STOP signal between the write and read
 *    @return True if write & read was successful, otherwise false.
 */
bool Adafruit_I2CDevice::write_then_read(const uint8_t *write_buffer,
    1288:	3f 92       	push	r3
    128a:	4f 92       	push	r4
    128c:	5f 92       	push	r5
    128e:	6f 92       	push	r6
    1290:	7f 92       	push	r7
    1292:	8f 92       	push	r8
    1294:	9f 92       	push	r9
    1296:	af 92       	push	r10
    1298:	bf 92       	push	r11
    129a:	cf 92       	push	r12
    129c:	df 92       	push	r13
    129e:	ef 92       	push	r14
    12a0:	ff 92       	push	r15
    12a2:	0f 93       	push	r16
    12a4:	1f 93       	push	r17
    12a6:	cf 93       	push	r28
    12a8:	df 93       	push	r29
    12aa:	cd b7       	in	r28, 0x3d	; 61
    12ac:	de b7       	in	r29, 0x3e	; 62
    12ae:	29 97       	sbiw	r28, 0x09	; 9
    12b0:	cd bf       	out	0x3d, r28	; 61
    12b2:	de bf       	out	0x3e, r29	; 62
    12b4:	8c 01       	movw	r16, r24
    12b6:	6a 01       	movw	r12, r20
    12b8:	79 01       	movw	r14, r18
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:246
  if (!write(write_buffer, write_len, stop)) {
    return false;
  }

  return read(read_buffer, read_len);
}
    12ba:	2d b7       	in	r18, 0x3d	; 61
    12bc:	3e b7       	in	r19, 0x3e	; 62
    12be:	28 87       	std	Y+8, r18	; 0x08
    12c0:	39 87       	std	Y+9, r19	; 0x09
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:241
 *    @return True if write & read was successful, otherwise false.
 */
bool Adafruit_I2CDevice::write_then_read(const uint8_t *write_buffer,
                                         size_t write_len, uint8_t *read_buffer,
                                         size_t read_len, bool stop) {
  if (!write(write_buffer, write_len, stop)) {
    12c2:	20 e0       	ldi	r18, 0x00	; 0
    12c4:	41 e0       	ldi	r20, 0x01	; 1
    12c6:	50 e0       	ldi	r21, 0x00	; 0
    12c8:	fa de       	rcall	.-524    	; 0x10be <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int) [clone .constprop.33]>
    12ca:	89 83       	std	Y+1, r24	; 0x01
    12cc:	81 11       	cpse	r24, r1
    12ce:	1c c0       	rjmp	.+56     	; 0x1308 <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool) [clone .constprop.32]+0x82>
    12d0:	19 82       	std	Y+1, r1	; 0x01
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:242
    return false;
    12d2:	89 81       	ldd	r24, Y+1	; 0x01
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:246
  }

  return read(read_buffer, read_len);
}
    12d4:	28 85       	ldd	r18, Y+8	; 0x08
    12d6:	39 85       	ldd	r19, Y+9	; 0x09
    12d8:	2d bf       	out	0x3d, r18	; 61
    12da:	3e bf       	out	0x3e, r19	; 62
    12dc:	29 96       	adiw	r28, 0x09	; 9
    12de:	cd bf       	out	0x3d, r28	; 61
    12e0:	de bf       	out	0x3e, r29	; 62
    12e2:	df 91       	pop	r29
    12e4:	cf 91       	pop	r28
    12e6:	1f 91       	pop	r17
    12e8:	0f 91       	pop	r16
    12ea:	ff 90       	pop	r15
    12ec:	ef 90       	pop	r14
    12ee:	df 90       	pop	r13
    12f0:	cf 90       	pop	r12
    12f2:	bf 90       	pop	r11
    12f4:	af 90       	pop	r10
    12f6:	9f 90       	pop	r9
    12f8:	8f 90       	pop	r8
    12fa:	7f 90       	pop	r7
    12fc:	6f 90       	pop	r6
    12fe:	5f 90       	pop	r5
    1300:	4f 90       	pop	r4
    1302:	3f 90       	pop	r3
    1304:	2f 90       	pop	r2
    1306:	08 95       	ret
    1308:	d8 01       	movw	r26, r16
    130a:	14 96       	adiw	r26, 0x04	; 4
    130c:	4d 90       	ld	r4, X+
    130e:	5c 90       	ld	r5, X
    1310:	15 97       	sbiw	r26, 0x05	; 5
read():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:170
 *    @param  stop Whether to send an I2C STOP signal on read
 *    @return True if read was successful, otherwise false.
 */
bool Adafruit_I2CDevice::read(uint8_t *buffer, size_t len, bool stop) {
  size_t bufferSize = maxBufferSize();
  if (bufferSize >= len) {
    1312:	4e 14       	cp	r4, r14
    1314:	5f 04       	cpc	r5, r15
    1316:	10 f1       	brcs	.+68     	; 0x135c <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool) [clone .constprop.32]+0xd6>
    1318:	11 96       	adiw	r26, 0x01	; 1
    131a:	ed 91       	ld	r30, X+
    131c:	fc 91       	ld	r31, X
    131e:	12 97       	sbiw	r26, 0x02	; 2
requestFrom():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:279
}
uint8_t TwoWire::requestFrom(uint8_t  address,  uint8_t  quantity,  uint8_t sendStop) {
  if (quantity > BUFFER_LENGTH) {
    quantity = BUFFER_LENGTH;
  }
  vars._clientAddress = address << 1;
    1320:	9c 91       	ld	r25, X
    1322:	99 0f       	add	r25, r25
    1324:	97 87       	std	Z+15, r25	; 0x0f
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:280
  return TWI_MasterRead(&vars, quantity, sendStop);
    1326:	41 e0       	ldi	r20, 0x01	; 1
    1328:	6e 2d       	mov	r22, r14
    132a:	cf 01       	movw	r24, r30
    132c:	0c 96       	adiw	r24, 0x0c	; 12
    132e:	40 d9       	rcall	.-3456   	; 0x5b0 <TWI_MasterRead>
_read():
    1330:	8e 15       	cp	r24, r14
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:196
  size_t recv = _wire->requestFrom((uint8_t)_addr, (uint8_t)len);
#else
  size_t recv = _wire->requestFrom((uint8_t)_addr, (uint8_t)len, (uint8_t)stop);
#endif

  if (recv != len) {
    1332:	1f 04       	cpc	r1, r15
    1334:	69 f6       	brne	.-102    	; 0x12d0 <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool) [clone .constprop.32]+0x4a>
    1336:	ec 0c       	add	r14, r12
    1338:	fd 1c       	adc	r15, r13
    133a:	f8 01       	movw	r30, r16
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:206
#endif
    return false;
  }

  for (uint16_t i = 0; i < len; i++) {
    buffer[i] = _wire->read();
    133c:	81 81       	ldd	r24, Z+1	; 0x01
    133e:	92 81       	ldd	r25, Z+2	; 0x02
    1340:	dc 01       	movw	r26, r24
    1342:	ed 91       	ld	r30, X+
    1344:	fc 91       	ld	r31, X
    1346:	02 84       	ldd	r0, Z+10	; 0x0a
    1348:	f3 85       	ldd	r31, Z+11	; 0x0b
    134a:	e0 2d       	mov	r30, r0
    134c:	09 95       	icall
    134e:	f6 01       	movw	r30, r12
    1350:	81 93       	st	Z+, r24
    1352:	6f 01       	movw	r12, r30
    1354:	ee 16       	cp	r14, r30
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:205
    DEBUG_SERIAL.println(recv);
#endif
    return false;
  }

  for (uint16_t i = 0; i < len; i++) {
    1356:	ff 06       	cpc	r15, r31
    1358:	81 f7       	brne	.-32     	; 0x133a <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool) [clone .constprop.32]+0xb4>
    135a:	bb cf       	rjmp	.-138    	; 0x12d2 <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool) [clone .constprop.32]+0x4c>
read():
    135c:	2d b7       	in	r18, 0x3d	; 61
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:185
        return false;
      }
      for (size_t i = 0; i < read_len; i++)
        buffer[pos++] = read_buffer[i];
    }
    return true;
    135e:	3e b7       	in	r19, 0x3e	; 62
    1360:	2c 83       	std	Y+4, r18	; 0x04
    1362:	3d 83       	std	Y+5, r19	; 0x05
    1364:	8d b7       	in	r24, 0x3d	; 61
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:176
    // can just read
    return _read(buffer, len, stop);
  } else {
    // must chunkify
    size_t pos = 0;
    uint8_t read_buffer[bufferSize];
    1366:	9e b7       	in	r25, 0x3e	; 62
    1368:	84 19       	sub	r24, r4
    136a:	95 09       	sbc	r25, r5
    136c:	8d bf       	out	0x3d, r24	; 61
    136e:	9e bf       	out	0x3e, r25	; 62
    1370:	ad b7       	in	r26, 0x3d	; 61
    1372:	be b7       	in	r27, 0x3e	; 62
    1374:	11 96       	adiw	r26, 0x01	; 1
    1376:	aa 83       	std	Y+2, r26	; 0x02
    1378:	bb 83       	std	Y+3, r27	; 0x03
_ZN18Adafruit_I2CDevice15write_then_readEPKhjPhjb.constprop.32():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:175
  if (bufferSize >= len) {
    // can just read
    return _read(buffer, len, stop);
  } else {
    // must chunkify
    size_t pos = 0;
    137a:	91 2c       	mov	r9, r1
    137c:	81 2c       	mov	r8, r1
read():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:178
    uint8_t read_buffer[bufferSize];
    while (pos < len) {
      size_t read_len = len - pos > bufferSize ? bufferSize : len - pos;
    137e:	57 01       	movw	r10, r14
    1380:	a8 18       	sub	r10, r8
    1382:	b9 08       	sbc	r11, r9
    1384:	4a 14       	cp	r4, r10
    1386:	5b 04       	cpc	r5, r11
    1388:	08 f4       	brcc	.+2      	; 0x138c <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool) [clone .constprop.32]+0x106>
    138a:	52 01       	movw	r10, r4
_read():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:193

bool Adafruit_I2CDevice::_read(uint8_t *buffer, size_t len, bool stop) {
#if defined(TinyWireM_h)
  size_t recv = _wire->requestFrom((uint8_t)_addr, (uint8_t)len);
#else
  size_t recv = _wire->requestFrom((uint8_t)_addr, (uint8_t)len, (uint8_t)stop);
    138c:	d8 01       	movw	r26, r16
    138e:	11 96       	adiw	r26, 0x01	; 1
    1390:	ed 91       	ld	r30, X+
    1392:	fc 91       	ld	r31, X
    1394:	12 97       	sbiw	r26, 0x02	; 2
requestFrom():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:279
}
uint8_t TwoWire::requestFrom(uint8_t  address,  uint8_t  quantity,  uint8_t sendStop) {
  if (quantity > BUFFER_LENGTH) {
    quantity = BUFFER_LENGTH;
  }
  vars._clientAddress = address << 1;
    1396:	9c 91       	ld	r25, X
    1398:	99 0f       	add	r25, r25
    139a:	97 87       	std	Z+15, r25	; 0x0f
_read():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:193
    139c:	6a 2d       	mov	r22, r10
requestFrom():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:280
  return TWI_MasterRead(&vars, quantity, sendStop);
    139e:	61 32       	cpi	r22, 0x21	; 33
    13a0:	08 f0       	brcs	.+2      	; 0x13a4 <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool) [clone .constprop.32]+0x11e>
    13a2:	60 e2       	ldi	r22, 0x20	; 32
    13a4:	40 e0       	ldi	r20, 0x00	; 0
    13a6:	cf 01       	movw	r24, r30
    13a8:	0c 96       	adiw	r24, 0x0c	; 12
    13aa:	02 d9       	rcall	.-3580   	; 0x5b0 <TWI_MasterRead>
_read():
    13ac:	8a 15       	cp	r24, r10
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:196
#endif

  if (recv != len) {
    13ae:	1b 04       	cpc	r1, r11
    13b0:	89 f5       	brne	.+98     	; 0x1414 <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool) [clone .constprop.32]+0x18e>
    13b2:	2a 80       	ldd	r2, Y+2	; 0x02
    13b4:	3b 80       	ldd	r3, Y+3	; 0x03
    13b6:	f1 01       	movw	r30, r2
    13b8:	ea 0d       	add	r30, r10
    13ba:	fb 1d       	adc	r31, r11
    13bc:	ee 83       	std	Y+6, r30	; 0x06
    13be:	ff 83       	std	Y+7, r31	; 0x07
    13c0:	31 01       	movw	r6, r2
    13c2:	2e 81       	ldd	r18, Y+6	; 0x06
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:205
    DEBUG_SERIAL.println(recv);
#endif
    return false;
  }

  for (uint16_t i = 0; i < len; i++) {
    13c4:	3f 81       	ldd	r19, Y+7	; 0x07
    13c6:	26 15       	cp	r18, r6
    13c8:	37 05       	cpc	r19, r7
    13ca:	81 f4       	brne	.+32     	; 0x13ec <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool) [clone .constprop.32]+0x166>
    13cc:	f6 01       	movw	r30, r12
    13ce:	e8 0d       	add	r30, r8
    13d0:	f9 1d       	adc	r31, r9
read():
    13d2:	26 14       	cp	r2, r6
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:182
    while (pos < len) {
      size_t read_len = len - pos > bufferSize ? bufferSize : len - pos;
      if (!_read(read_buffer, read_len, false)) {
        return false;
      }
      for (size_t i = 0; i < read_len; i++)
    13d4:	37 04       	cpc	r3, r7
    13d6:	c9 f4       	brne	.+50     	; 0x140a <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool) [clone .constprop.32]+0x184>
    13d8:	8a 0c       	add	r8, r10
    13da:	9b 1c       	adc	r9, r11
    13dc:	8e 14       	cp	r8, r14
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:177
    return _read(buffer, len, stop);
  } else {
    // must chunkify
    size_t pos = 0;
    uint8_t read_buffer[bufferSize];
    while (pos < len) {
    13de:	9f 04       	cpc	r9, r15
    13e0:	70 f2       	brcs	.-100    	; 0x137e <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool) [clone .constprop.32]+0xf8>
    13e2:	ec 81       	ldd	r30, Y+4	; 0x04
    13e4:	fd 81       	ldd	r31, Y+5	; 0x05
    13e6:	ed bf       	out	0x3d, r30	; 61
    13e8:	fe bf       	out	0x3e, r31	; 62
    13ea:	73 cf       	rjmp	.-282    	; 0x12d2 <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool) [clone .constprop.32]+0x4c>
_read():
    13ec:	d8 01       	movw	r26, r16
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:206
#endif
    return false;
  }

  for (uint16_t i = 0; i < len; i++) {
    buffer[i] = _wire->read();
    13ee:	11 96       	adiw	r26, 0x01	; 1
    13f0:	8d 91       	ld	r24, X+
    13f2:	9c 91       	ld	r25, X
    13f4:	dc 01       	movw	r26, r24
    13f6:	ed 91       	ld	r30, X+
    13f8:	fc 91       	ld	r31, X
    13fa:	02 84       	ldd	r0, Z+10	; 0x0a
    13fc:	f3 85       	ldd	r31, Z+11	; 0x0b
    13fe:	e0 2d       	mov	r30, r0
    1400:	09 95       	icall
    1402:	f3 01       	movw	r30, r6
    1404:	81 93       	st	Z+, r24
    1406:	3f 01       	movw	r6, r30
    1408:	dc cf       	rjmp	.-72     	; 0x13c2 <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool) [clone .constprop.32]+0x13c>
read():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:183
      size_t read_len = len - pos > bufferSize ? bufferSize : len - pos;
      if (!_read(read_buffer, read_len, false)) {
        return false;
      }
      for (size_t i = 0; i < read_len; i++)
        buffer[pos++] = read_buffer[i];
    140a:	d1 01       	movw	r26, r2
    140c:	8d 91       	ld	r24, X+
    140e:	1d 01       	movw	r2, r26
    1410:	81 93       	st	Z+, r24
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:180
    size_t pos = 0;
    uint8_t read_buffer[bufferSize];
    while (pos < len) {
      size_t read_len = len - pos > bufferSize ? bufferSize : len - pos;
      if (!_read(read_buffer, read_len, false)) {
        return false;
    1412:	df cf       	rjmp	.-66     	; 0x13d2 <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool) [clone .constprop.32]+0x14c>
_ZN18Adafruit_I2CDevice15write_then_readEPKhjPhjb.constprop.32():
    1414:	19 82       	std	Y+1, r1	; 0x01
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:189
    spi_dev->write_then_read(buffer, 1, buffer, 2);
  }
  return uint16_t(buffer[0]) << 8 | uint16_t(buffer[1]);
}

uint16_t Adafruit_BMP280::read16_LE(byte reg) {
    1416:	e5 cf       	rjmp	.-54     	; 0x13e2 <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool) [clone .constprop.32]+0x15c>

00001418 <Adafruit_BMP280::read16_LE(unsigned char) [clone .constprop.27]>:
_ZN15Adafruit_BMP2809read16_LEEh.constprop.27():
    1418:	cf 93       	push	r28
    141a:	df 93       	push	r29
    141c:	00 d0       	rcall	.+0      	; 0x141e <Adafruit_BMP280::read16_LE(unsigned char) [clone .constprop.27]+0x6>
    141e:	cd b7       	in	r28, 0x3d	; 61
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:179
 *  @brief  Reads a 16 bit value over I2C/SPI
 */
uint16_t Adafruit_BMP280::read16(byte reg) {
  uint8_t buffer[2];

  if (i2c_dev) {
    1420:	de b7       	in	r29, 0x3e	; 62
read16():
    1422:	e0 91 0b 39 	lds	r30, 0x390B	; 0x80390b <bmp+0x2>
    1426:	f0 91 0c 39 	lds	r31, 0x390C	; 0x80390c <bmp+0x3>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:181
    buffer[0] = uint8_t(reg);
    i2c_dev->write_then_read(buffer, 1, buffer, 2);
    142a:	89 83       	std	Y+1, r24	; 0x01
    142c:	22 e0       	ldi	r18, 0x02	; 2
    142e:	30 e0       	ldi	r19, 0x00	; 0
    1430:	ae 01       	movw	r20, r28
    1432:	4f 5f       	subi	r20, 0xFF	; 255
    1434:	5f 4f       	sbci	r21, 0xFF	; 255
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:179
 *  @brief  Reads a 16 bit value over I2C/SPI
 */
uint16_t Adafruit_BMP280::read16(byte reg) {
  uint8_t buffer[2];

  if (i2c_dev) {
    1436:	ba 01       	movw	r22, r20
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:181
    buffer[0] = uint8_t(reg);
    i2c_dev->write_then_read(buffer, 1, buffer, 2);
    1438:	30 97       	sbiw	r30, 0x00	; 0
    143a:	49 f0       	breq	.+18     	; 0x144e <Adafruit_BMP280::read16_LE(unsigned char) [clone .constprop.27]+0x36>
    143c:	cf 01       	movw	r24, r30
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:192
}

uint16_t Adafruit_BMP280::read16_LE(byte reg) {
  uint16_t temp = read16(reg);
  return (temp >> 8) | (temp << 8);
}
    143e:	23 df       	rcall	.-442    	; 0x1286 <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool) [clone .constprop.32]>
_ZN15Adafruit_BMP2809read16_LEEh.constprop.27():
    1440:	89 81       	ldd	r24, Y+1	; 0x01
    1442:	9a 81       	ldd	r25, Y+2	; 0x02
    1444:	0f 90       	pop	r0
    1446:	0f 90       	pop	r0
    1448:	df 91       	pop	r29
    144a:	cf 91       	pop	r28
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:184
  if (i2c_dev) {
    buffer[0] = uint8_t(reg);
    i2c_dev->write_then_read(buffer, 1, buffer, 2);
  } else {
    buffer[0] = uint8_t(reg | 0x80);
    spi_dev->write_then_read(buffer, 1, buffer, 2);
    144c:	08 95       	ret
read16():
    144e:	80 91 0d 39 	lds	r24, 0x390D	; 0x80390d <bmp+0x4>
    1452:	90 91 0e 39 	lds	r25, 0x390E	; 0x80390e <bmp+0x5>
    1456:	f8 db       	rcall	.-2064   	; 0xc48 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char) [clone .constprop.35]>
    1458:	f3 cf       	rjmp	.-26     	; 0x1440 <Adafruit_BMP280::read16_LE(unsigned char) [clone .constprop.27]+0x28>

0000145a <Adafruit_BMP280::read24(unsigned char)>:
_ZN15Adafruit_BMP2806read24Eh():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:206
}

/*!
 *  @brief  Reads a 24 bit value over I2C/SPI
 */
uint32_t Adafruit_BMP280::read24(byte reg) {
    145a:	cf 93       	push	r28
    145c:	df 93       	push	r29
    145e:	00 d0       	rcall	.+0      	; 0x1460 <Adafruit_BMP280::read24(unsigned char)+0x6>
    1460:	1f 92       	push	r1
    1462:	cd b7       	in	r28, 0x3d	; 61
    1464:	de b7       	in	r29, 0x3e	; 62
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:209
  uint8_t buffer[3];

  if (i2c_dev) {
    1466:	fc 01       	movw	r30, r24
    1468:	82 81       	ldd	r24, Z+2	; 0x02
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:210
    buffer[0] = uint8_t(reg);
    146a:	93 81       	ldd	r25, Z+3	; 0x03
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:211
    i2c_dev->write_then_read(buffer, 1, buffer, 3);
    146c:	69 83       	std	Y+1, r22	; 0x01
    146e:	23 e0       	ldi	r18, 0x03	; 3
    1470:	30 e0       	ldi	r19, 0x00	; 0
    1472:	ae 01       	movw	r20, r28
    1474:	4f 5f       	subi	r20, 0xFF	; 255
    1476:	5f 4f       	sbci	r21, 0xFF	; 255
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:209
 *  @brief  Reads a 24 bit value over I2C/SPI
 */
uint32_t Adafruit_BMP280::read24(byte reg) {
  uint8_t buffer[3];

  if (i2c_dev) {
    1478:	ba 01       	movw	r22, r20
    147a:	00 97       	sbiw	r24, 0x00	; 0
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:211
    buffer[0] = uint8_t(reg);
    i2c_dev->write_then_read(buffer, 1, buffer, 3);
    147c:	99 f0       	breq	.+38     	; 0x14a4 <Adafruit_BMP280::read24(unsigned char)+0x4a>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:216
  } else {
    buffer[0] = uint8_t(reg | 0x80);
    spi_dev->write_then_read(buffer, 1, buffer, 3);
  }
  return uint32_t(buffer[0]) << 16 | uint32_t(buffer[1]) << 8 |
    147e:	03 df       	rcall	.-506    	; 0x1286 <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool) [clone .constprop.32]>
    1480:	29 81       	ldd	r18, Y+1	; 0x01
    1482:	6a 81       	ldd	r22, Y+2	; 0x02
    1484:	70 e0       	ldi	r23, 0x00	; 0
    1486:	90 e0       	ldi	r25, 0x00	; 0
    1488:	80 e0       	ldi	r24, 0x00	; 0
    148a:	98 2f       	mov	r25, r24
    148c:	87 2f       	mov	r24, r23
    148e:	76 2f       	mov	r23, r22
    1490:	66 27       	eor	r22, r22
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:217
         uint32_t(buffer[2]);
    1492:	82 2b       	or	r24, r18
    1494:	2b 81       	ldd	r18, Y+3	; 0x03
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:218
}
    1496:	62 2b       	or	r22, r18
    1498:	23 96       	adiw	r28, 0x03	; 3
    149a:	cd bf       	out	0x3d, r28	; 61
    149c:	de bf       	out	0x3e, r29	; 62
    149e:	df 91       	pop	r29
    14a0:	cf 91       	pop	r28
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:214
  if (i2c_dev) {
    buffer[0] = uint8_t(reg);
    i2c_dev->write_then_read(buffer, 1, buffer, 3);
  } else {
    buffer[0] = uint8_t(reg | 0x80);
    spi_dev->write_then_read(buffer, 1, buffer, 3);
    14a2:	08 95       	ret
    14a4:	84 81       	ldd	r24, Z+4	; 0x04
    14a6:	95 81       	ldd	r25, Z+5	; 0x05
    14a8:	cf db       	rcall	.-2146   	; 0xc48 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char) [clone .constprop.35]>
    14aa:	ea cf       	rjmp	.-44     	; 0x1480 <Adafruit_BMP280::read24(unsigned char)+0x26>

000014ac <Adafruit_BMP280::readTemperature()>:
_ZN15Adafruit_BMP28015readTemperatureEv():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:243

/*!
 * Reads the temperature from the device.
 * @return The temperature in degress celcius.
 */
float Adafruit_BMP280::readTemperature() {
    14ac:	8f 92       	push	r8
    14ae:	9f 92       	push	r9
    14b0:	af 92       	push	r10
    14b2:	bf 92       	push	r11
    14b4:	cf 92       	push	r12
    14b6:	df 92       	push	r13
    14b8:	ef 92       	push	r14
    14ba:	ff 92       	push	r15
    14bc:	0f 93       	push	r16
    14be:	1f 93       	push	r17
    14c0:	cf 93       	push	r28
    14c2:	df 93       	push	r29
    14c4:	ec 01       	movw	r28, r24
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:246
  int32_t var1, var2;

  int32_t adc_T = read24(BMP280_REGISTER_TEMPDATA);
    14c6:	6a ef       	ldi	r22, 0xFA	; 250
    14c8:	c8 df       	rcall	.-112    	; 0x145a <Adafruit_BMP280::read24(unsigned char)>
    14ca:	0d 89       	ldd	r16, Y+21	; 0x15
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:249
  adc_T >>= 4;

  var1 = ((((adc_T >> 3) - ((int32_t)_bmp280_calib.dig_T1 << 1))) *
    14cc:	1e 89       	ldd	r17, Y+22	; 0x16
    14ce:	30 e0       	ldi	r19, 0x00	; 0
    14d0:	20 e0       	ldi	r18, 0x00	; 0
    14d2:	c7 2e       	mov	r12, r23
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:253
          ((int32_t)_bmp280_calib.dig_T2)) >>
         11;

  var2 = (((((adc_T >> 4) - ((int32_t)_bmp280_calib.dig_T1)) *
    14d4:	d8 2e       	mov	r13, r24
    14d6:	e9 2e       	mov	r14, r25
    14d8:	ff 24       	eor	r15, r15
    14da:	e7 fc       	sbrc	r14, 7
    14dc:	fa 94       	dec	r15
    14de:	c0 1a       	sub	r12, r16
    14e0:	d1 0a       	sbc	r13, r17
    14e2:	e2 0a       	sbc	r14, r18
    14e4:	f3 0a       	sbc	r15, r19
    14e6:	57 e0       	ldi	r21, 0x07	; 7
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:249
  int32_t var1, var2;

  int32_t adc_T = read24(BMP280_REGISTER_TEMPDATA);
  adc_T >>= 4;

  var1 = ((((adc_T >> 3) - ((int32_t)_bmp280_calib.dig_T1 << 1))) *
    14e8:	95 95       	asr	r25
    14ea:	87 95       	ror	r24
    14ec:	77 95       	ror	r23
    14ee:	67 95       	ror	r22
    14f0:	5a 95       	dec	r21
    14f2:	d1 f7       	brne	.-12     	; 0x14e8 <Adafruit_BMP280::readTemperature()+0x3c>
    14f4:	00 0f       	add	r16, r16
    14f6:	11 1f       	adc	r17, r17
    14f8:	22 1f       	adc	r18, r18
    14fa:	33 1f       	adc	r19, r19
    14fc:	4b 01       	movw	r8, r22
    14fe:	5c 01       	movw	r10, r24
    1500:	80 1a       	sub	r8, r16
    1502:	91 0a       	sbc	r9, r17
    1504:	a2 0a       	sbc	r10, r18
    1506:	b3 0a       	sbc	r11, r19
    1508:	a5 01       	movw	r20, r10
    150a:	94 01       	movw	r18, r8
    150c:	af 89       	ldd	r26, Y+23	; 0x17
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:250
          ((int32_t)_bmp280_calib.dig_T2)) >>
    150e:	b8 8d       	ldd	r27, Y+24	; 0x18
    1510:	0e 94 12 17 	call	0x2e24	; 0x2e24 <__mulshisi3>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:249
  int32_t var1, var2;

  int32_t adc_T = read24(BMP280_REGISTER_TEMPDATA);
  adc_T >>= 4;

  var1 = ((((adc_T >> 3) - ((int32_t)_bmp280_calib.dig_T1 << 1))) *
    1514:	4b 01       	movw	r8, r22
    1516:	5c 01       	movw	r10, r24
    1518:	fb e0       	ldi	r31, 0x0B	; 11
    151a:	b5 94       	asr	r11
    151c:	a7 94       	ror	r10
    151e:	97 94       	ror	r9
    1520:	87 94       	ror	r8
    1522:	fa 95       	dec	r31
    1524:	d1 f7       	brne	.-12     	; 0x151a <Adafruit_BMP280::readTemperature()+0x6e>
    1526:	a7 01       	movw	r20, r14
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:253
          ((int32_t)_bmp280_calib.dig_T2)) >>
         11;

  var2 = (((((adc_T >> 4) - ((int32_t)_bmp280_calib.dig_T1)) *
    1528:	96 01       	movw	r18, r12
    152a:	c7 01       	movw	r24, r14
    152c:	b6 01       	movw	r22, r12
    152e:	0e 94 d7 16 	call	0x2dae	; 0x2dae <__mulsi3>
    1532:	9b 01       	movw	r18, r22
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:254
            ((adc_T >> 4) - ((int32_t)_bmp280_calib.dig_T1))) >>
    1534:	ac 01       	movw	r20, r24
    1536:	ac e0       	ldi	r26, 0x0C	; 12
    1538:	55 95       	asr	r21
    153a:	47 95       	ror	r20
    153c:	37 95       	ror	r19
    153e:	27 95       	ror	r18
    1540:	aa 95       	dec	r26
    1542:	d1 f7       	brne	.-12     	; 0x1538 <Adafruit_BMP280::readTemperature()+0x8c>
    1544:	a9 8d       	ldd	r26, Y+25	; 0x19
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:256
           12) *
          ((int32_t)_bmp280_calib.dig_T3)) >>
    1546:	ba 8d       	ldd	r27, Y+26	; 0x1a
    1548:	0e 94 12 17 	call	0x2e24	; 0x2e24 <__mulshisi3>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:255
          ((int32_t)_bmp280_calib.dig_T2)) >>
         11;

  var2 = (((((adc_T >> 4) - ((int32_t)_bmp280_calib.dig_T1)) *
            ((adc_T >> 4) - ((int32_t)_bmp280_calib.dig_T1))) >>
           12) *
    154c:	9b 01       	movw	r18, r22
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:253

  var1 = ((((adc_T >> 3) - ((int32_t)_bmp280_calib.dig_T1 << 1))) *
          ((int32_t)_bmp280_calib.dig_T2)) >>
         11;

  var2 = (((((adc_T >> 4) - ((int32_t)_bmp280_calib.dig_T1)) *
    154e:	ac 01       	movw	r20, r24
    1550:	be e0       	ldi	r27, 0x0E	; 14
    1552:	55 95       	asr	r21
    1554:	47 95       	ror	r20
    1556:	37 95       	ror	r19
    1558:	27 95       	ror	r18
    155a:	ba 95       	dec	r27
    155c:	d1 f7       	brne	.-12     	; 0x1552 <Adafruit_BMP280::readTemperature()+0xa6>
    155e:	28 0d       	add	r18, r8
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:259
            ((adc_T >> 4) - ((int32_t)_bmp280_calib.dig_T1))) >>
           12) *
          ((int32_t)_bmp280_calib.dig_T3)) >>
         14;

  t_fine = var1 + var2;
    1560:	39 1d       	adc	r19, r9
    1562:	4a 1d       	adc	r20, r10
    1564:	5b 1d       	adc	r21, r11
    1566:	2f 87       	std	Y+15, r18	; 0x0f
    1568:	38 8b       	std	Y+16, r19	; 0x10
    156a:	49 8b       	std	Y+17, r20	; 0x11
    156c:	5a 8b       	std	Y+18, r21	; 0x12
    156e:	a5 e0       	ldi	r26, 0x05	; 5
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:261

  float T = (t_fine * 5 + 128) >> 8;
    1570:	b0 e0       	ldi	r27, 0x00	; 0
    1572:	0e 94 08 17 	call	0x2e10	; 0x2e10 <__muluhisi3>
    1576:	60 58       	subi	r22, 0x80	; 128
    1578:	7f 4f       	sbci	r23, 0xFF	; 255
    157a:	8f 4f       	sbci	r24, 0xFF	; 255
    157c:	9f 4f       	sbci	r25, 0xFF	; 255
    157e:	67 2f       	mov	r22, r23
    1580:	78 2f       	mov	r23, r24
    1582:	89 2f       	mov	r24, r25
    1584:	99 27       	eor	r25, r25
    1586:	87 fd       	sbrc	r24, 7
    1588:	9a 95       	dec	r25
    158a:	0e 94 09 14 	call	0x2812	; 0x2812 <__floatsisf>
    158e:	20 e0       	ldi	r18, 0x00	; 0
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:262
  return T / 100;
    1590:	30 e0       	ldi	r19, 0x00	; 0
    1592:	48 ec       	ldi	r20, 0xC8	; 200
    1594:	52 e4       	ldi	r21, 0x42	; 66
    1596:	0e 94 6f 13 	call	0x26de	; 0x26de <__divsf3>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:263
}
    159a:	df 91       	pop	r29
    159c:	cf 91       	pop	r28
    159e:	1f 91       	pop	r17
    15a0:	0f 91       	pop	r16
    15a2:	ff 90       	pop	r15
    15a4:	ef 90       	pop	r14
    15a6:	df 90       	pop	r13
    15a8:	cf 90       	pop	r12
    15aa:	bf 90       	pop	r11
    15ac:	af 90       	pop	r10
    15ae:	9f 90       	pop	r9
    15b0:	8f 90       	pop	r8
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:269

/*!
 * Reads the barometric pressure from the device.
 * @return Barometric pressure in Pa.
 */
float Adafruit_BMP280::readPressure() {
    15b2:	08 95       	ret

000015b4 <Adafruit_BMP280::readPressure()>:
_ZN15Adafruit_BMP28012readPressureEv():
    15b4:	2f 92       	push	r2
    15b6:	3f 92       	push	r3
    15b8:	4f 92       	push	r4
    15ba:	5f 92       	push	r5
    15bc:	6f 92       	push	r6
    15be:	7f 92       	push	r7
    15c0:	8f 92       	push	r8
    15c2:	9f 92       	push	r9
    15c4:	af 92       	push	r10
    15c6:	bf 92       	push	r11
    15c8:	cf 92       	push	r12
    15ca:	df 92       	push	r13
    15cc:	ef 92       	push	r14
    15ce:	ff 92       	push	r15
    15d0:	0f 93       	push	r16
    15d2:	1f 93       	push	r17
    15d4:	cf 93       	push	r28
    15d6:	df 93       	push	r29
    15d8:	cd b7       	in	r28, 0x3d	; 61
    15da:	de b7       	in	r29, 0x3e	; 62
    15dc:	6d 97       	sbiw	r28, 0x1d	; 29
    15de:	cd bf       	out	0x3d, r28	; 61
    15e0:	de bf       	out	0x3e, r29	; 62
    15e2:	8c 8f       	std	Y+28, r24	; 0x1c
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:273
  int64_t var1, var2, p;

  // Must be done first to get the t_fine variable set up
  readTemperature();
    15e4:	9d 8f       	std	Y+29, r25	; 0x1d
    15e6:	62 df       	rcall	.-316    	; 0x14ac <Adafruit_BMP280::readTemperature()>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:275

  int32_t adc_P = read24(BMP280_REGISTER_PRESSUREDATA);
    15e8:	67 ef       	ldi	r22, 0xF7	; 247
    15ea:	8c 8d       	ldd	r24, Y+28	; 0x1c
    15ec:	9d 8d       	ldd	r25, Y+29	; 0x1d
    15ee:	35 df       	rcall	.-406    	; 0x145a <Adafruit_BMP280::read24(unsigned char)>
    15f0:	68 8f       	std	Y+24, r22	; 0x18
    15f2:	79 8f       	std	Y+25, r23	; 0x19
    15f4:	8a 8f       	std	Y+26, r24	; 0x1a
    15f6:	9b 8f       	std	Y+27, r25	; 0x1b
    15f8:	ec 8d       	ldd	r30, Y+28	; 0x1c
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:278
  adc_P >>= 4;

  var1 = ((int64_t)t_fine) - 128000;
    15fa:	fd 8d       	ldd	r31, Y+29	; 0x1d
    15fc:	87 85       	ldd	r24, Z+15	; 0x0f
    15fe:	90 89       	ldd	r25, Z+16	; 0x10
    1600:	a1 89       	ldd	r26, Z+17	; 0x11
    1602:	b2 89       	ldd	r27, Z+18	; 0x12
    1604:	6c 01       	movw	r12, r24
    1606:	7d 01       	movw	r14, r26
    1608:	ff 0c       	add	r15, r15
    160a:	cc 08       	sbc	r12, r12
    160c:	dc 2c       	mov	r13, r12
    160e:	76 01       	movw	r14, r12
    1610:	9c 01       	movw	r18, r24
    1612:	ad 01       	movw	r20, r26
    1614:	6c 2d       	mov	r22, r12
    1616:	7c 2d       	mov	r23, r12
    1618:	8c 2d       	mov	r24, r12
    161a:	9c 2d       	mov	r25, r12
    161c:	34 5f       	subi	r19, 0xF4	; 244
    161e:	41 40       	sbci	r20, 0x01	; 1
    1620:	51 09       	sbc	r21, r1
    1622:	61 09       	sbc	r22, r1
    1624:	71 09       	sbc	r23, r1
    1626:	81 09       	sbc	r24, r1
    1628:	91 09       	sbc	r25, r1
    162a:	29 87       	std	Y+9, r18	; 0x09
    162c:	3a 87       	std	Y+10, r19	; 0x0a
    162e:	4b 87       	std	Y+11, r20	; 0x0b
    1630:	5c 87       	std	Y+12, r21	; 0x0c
    1632:	3b 01       	movw	r6, r22
    1634:	4c 01       	movw	r8, r24
    1636:	59 01       	movw	r10, r18
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:279
  var2 = var1 * var1 * (int64_t)_bmp280_calib.dig_P6;
    1638:	6a 01       	movw	r12, r20
    163a:	7b 01       	movw	r14, r22
    163c:	8c 01       	movw	r16, r24
    163e:	0e 94 18 17 	call	0x2e30	; 0x2e30 <__muldi3>
    1642:	32 2e       	mov	r3, r18
    1644:	23 2e       	mov	r2, r19
    1646:	4a 8b       	std	Y+18, r20	; 0x12
    1648:	5b 8b       	std	Y+19, r21	; 0x13
    164a:	6c 8b       	std	Y+20, r22	; 0x14
    164c:	7d 8b       	std	Y+21, r23	; 0x15
    164e:	8e 8b       	std	Y+22, r24	; 0x16
    1650:	9f 8b       	std	Y+23, r25	; 0x17
    1652:	ac 8d       	ldd	r26, Y+28	; 0x1c
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:283
  var2 = var2 + ((var1 * (int64_t)_bmp280_calib.dig_P5) << 17);
  var2 = var2 + (((int64_t)_bmp280_calib.dig_P4) << 35);
  var1 = ((var1 * var1 * (int64_t)_bmp280_calib.dig_P3) >> 8) +
         ((var1 * (int64_t)_bmp280_calib.dig_P2) << 12);
    1654:	bd 8d       	ldd	r27, Y+29	; 0x1d
    1656:	5e 96       	adiw	r26, 0x1e	; 30
    1658:	3c 91       	ld	r19, X
    165a:	5e 97       	sbiw	r26, 0x1e	; 30
    165c:	5d 96       	adiw	r26, 0x1d	; 29
    165e:	2c 91       	ld	r18, X
    1660:	93 2f       	mov	r25, r19
    1662:	99 0f       	add	r25, r25
    1664:	99 0b       	sbc	r25, r25
    1666:	49 2f       	mov	r20, r25
    1668:	59 2f       	mov	r21, r25
    166a:	69 2f       	mov	r22, r25
    166c:	79 2f       	mov	r23, r25
    166e:	89 2f       	mov	r24, r25
    1670:	0e 94 18 17 	call	0x2e30	; 0x2e30 <__muldi3>
    1674:	0c e0       	ldi	r16, 0x0C	; 12
    1676:	0e 94 01 18 	call	0x3002	; 0x3002 <__ashldi3>
    167a:	52 2e       	mov	r5, r18
    167c:	39 83       	std	Y+1, r19	; 0x01
    167e:	4d 87       	std	Y+13, r20	; 0x0d
    1680:	5e 87       	std	Y+14, r21	; 0x0e
    1682:	6f 87       	std	Y+15, r22	; 0x0f
    1684:	78 8b       	std	Y+16, r23	; 0x10
    1686:	89 8b       	std	Y+17, r24	; 0x11
    1688:	49 2e       	mov	r4, r25
    168a:	ec 8d       	ldd	r30, Y+28	; 0x1c
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:282

  var1 = ((int64_t)t_fine) - 128000;
  var2 = var1 * var1 * (int64_t)_bmp280_calib.dig_P6;
  var2 = var2 + ((var1 * (int64_t)_bmp280_calib.dig_P5) << 17);
  var2 = var2 + (((int64_t)_bmp280_calib.dig_P4) << 35);
  var1 = ((var1 * var1 * (int64_t)_bmp280_calib.dig_P3) >> 8) +
    168c:	fd 8d       	ldd	r31, Y+29	; 0x1d
    168e:	30 a1       	ldd	r19, Z+32	; 0x20
    1690:	27 8d       	ldd	r18, Z+31	; 0x1f
    1692:	93 2f       	mov	r25, r19
    1694:	99 0f       	add	r25, r25
    1696:	99 0b       	sbc	r25, r25
    1698:	a3 2c       	mov	r10, r3
    169a:	b2 2c       	mov	r11, r2
    169c:	ca 88       	ldd	r12, Y+18	; 0x12
    169e:	db 88       	ldd	r13, Y+19	; 0x13
    16a0:	ec 88       	ldd	r14, Y+20	; 0x14
    16a2:	fd 88       	ldd	r15, Y+21	; 0x15
    16a4:	0e 89       	ldd	r16, Y+22	; 0x16
    16a6:	1f 89       	ldd	r17, Y+23	; 0x17
    16a8:	49 2f       	mov	r20, r25
    16aa:	59 2f       	mov	r21, r25
    16ac:	69 2f       	mov	r22, r25
    16ae:	79 2f       	mov	r23, r25
    16b0:	89 2f       	mov	r24, r25
    16b2:	0e 94 18 17 	call	0x2e30	; 0x2e30 <__muldi3>
    16b6:	08 e0       	ldi	r16, 0x08	; 8
    16b8:	0e 94 1a 18 	call	0x3034	; 0x3034 <__ashrdi3>
    16bc:	a5 2c       	mov	r10, r5
    16be:	b9 80       	ldd	r11, Y+1	; 0x01
    16c0:	cd 84       	ldd	r12, Y+13	; 0x0d
    16c2:	de 84       	ldd	r13, Y+14	; 0x0e
    16c4:	ef 84       	ldd	r14, Y+15	; 0x0f
    16c6:	f8 88       	ldd	r15, Y+16	; 0x10
    16c8:	09 89       	ldd	r16, Y+17	; 0x11
    16ca:	14 2d       	mov	r17, r4
    16cc:	0e 94 37 18 	call	0x306e	; 0x306e <__adddi3>
    16d0:	70 58       	subi	r23, 0x80	; 128
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:285
         ((var1 * (int64_t)_bmp280_calib.dig_P2) << 12);
  var1 =
      (((((int64_t)1) << 47) + var1)) * ((int64_t)_bmp280_calib.dig_P1) >> 33;
    16d2:	8f 4f       	sbci	r24, 0xFF	; 255
    16d4:	9f 4f       	sbci	r25, 0xFF	; 255
    16d6:	ac 8d       	ldd	r26, Y+28	; 0x1c
    16d8:	bd 8d       	ldd	r27, Y+29	; 0x1d
    16da:	5b 96       	adiw	r26, 0x1b	; 27
    16dc:	ed 91       	ld	r30, X+
    16de:	fc 91       	ld	r31, X
    16e0:	5f 01       	movw	r10, r30
    16e2:	d1 2c       	mov	r13, r1
    16e4:	c1 2c       	mov	r12, r1
    16e6:	e1 2c       	mov	r14, r1
    16e8:	f1 2c       	mov	r15, r1
    16ea:	87 01       	movw	r16, r14
    16ec:	e9 83       	std	Y+1, r30	; 0x01
    16ee:	ba 82       	std	Y+2, r11	; 0x02
    16f0:	cb 82       	std	Y+3, r12	; 0x03
    16f2:	dc 82       	std	Y+4, r13	; 0x04
    16f4:	ed 82       	std	Y+5, r14	; 0x05
    16f6:	fe 82       	std	Y+6, r15	; 0x06
    16f8:	0f 83       	std	Y+7, r16	; 0x07
    16fa:	18 87       	std	Y+8, r17	; 0x08
    16fc:	c1 2c       	mov	r12, r1
    16fe:	d1 2c       	mov	r13, r1
    1700:	e1 2c       	mov	r14, r1
    1702:	f1 2c       	mov	r15, r1
    1704:	00 e0       	ldi	r16, 0x00	; 0
    1706:	10 e0       	ldi	r17, 0x00	; 0
    1708:	0e 94 18 17 	call	0x2e30	; 0x2e30 <__muldi3>
    170c:	01 e2       	ldi	r16, 0x21	; 33
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:284
  var2 = var1 * var1 * (int64_t)_bmp280_calib.dig_P6;
  var2 = var2 + ((var1 * (int64_t)_bmp280_calib.dig_P5) << 17);
  var2 = var2 + (((int64_t)_bmp280_calib.dig_P4) << 35);
  var1 = ((var1 * var1 * (int64_t)_bmp280_calib.dig_P3) >> 8) +
         ((var1 * (int64_t)_bmp280_calib.dig_P2) << 12);
  var1 =
    170e:	0e 94 1a 18 	call	0x3034	; 0x3034 <__ashrdi3>
    1712:	29 83       	std	Y+1, r18	; 0x01
    1714:	53 2e       	mov	r5, r19
    1716:	4d 87       	std	Y+13, r20	; 0x0d
    1718:	5e 87       	std	Y+14, r21	; 0x0e
    171a:	6f 87       	std	Y+15, r22	; 0x0f
    171c:	78 8b       	std	Y+16, r23	; 0x10
    171e:	89 8b       	std	Y+17, r24	; 0x11
    1720:	49 2e       	mov	r4, r25
    1722:	a0 e0       	ldi	r26, 0x00	; 0
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:287
      (((((int64_t)1) << 47) + var1)) * ((int64_t)_bmp280_calib.dig_P1) >> 33;

  if (var1 == 0) {
    1724:	0e 94 49 18 	call	0x3092	; 0x3092 <__cmpdi2_s8>
    1728:	09 f4       	brne	.+2      	; 0x172c <Adafruit_BMP280::readPressure()+0x178>
    172a:	39 c1       	rjmp	.+626    	; 0x199e <Adafruit_BMP280::readPressure()+0x3ea>
    172c:	ac 8d       	ldd	r26, Y+28	; 0x1c
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:279

  int32_t adc_P = read24(BMP280_REGISTER_PRESSUREDATA);
  adc_P >>= 4;

  var1 = ((int64_t)t_fine) - 128000;
  var2 = var1 * var1 * (int64_t)_bmp280_calib.dig_P6;
    172e:	bd 8d       	ldd	r27, Y+29	; 0x1d
    1730:	96 96       	adiw	r26, 0x26	; 38
    1732:	3c 91       	ld	r19, X
    1734:	96 97       	sbiw	r26, 0x26	; 38
    1736:	95 96       	adiw	r26, 0x25	; 37
    1738:	2c 91       	ld	r18, X
    173a:	93 2f       	mov	r25, r19
    173c:	99 0f       	add	r25, r25
    173e:	99 0b       	sbc	r25, r25
    1740:	a3 2c       	mov	r10, r3
    1742:	b2 2c       	mov	r11, r2
    1744:	ca 88       	ldd	r12, Y+18	; 0x12
    1746:	db 88       	ldd	r13, Y+19	; 0x13
    1748:	ec 88       	ldd	r14, Y+20	; 0x14
    174a:	fd 88       	ldd	r15, Y+21	; 0x15
    174c:	0e 89       	ldd	r16, Y+22	; 0x16
    174e:	1f 89       	ldd	r17, Y+23	; 0x17
    1750:	49 2f       	mov	r20, r25
    1752:	59 2f       	mov	r21, r25
    1754:	69 2f       	mov	r22, r25
    1756:	79 2f       	mov	r23, r25
    1758:	89 2f       	mov	r24, r25
    175a:	0e 94 18 17 	call	0x2e30	; 0x2e30 <__muldi3>
    175e:	19 01       	movw	r2, r18
    1760:	4a 8b       	std	Y+18, r20	; 0x12
    1762:	5b 8b       	std	Y+19, r21	; 0x13
    1764:	6c 8b       	std	Y+20, r22	; 0x14
    1766:	7d 8b       	std	Y+21, r23	; 0x15
    1768:	8e 8b       	std	Y+22, r24	; 0x16
    176a:	9f 8b       	std	Y+23, r25	; 0x17
    176c:	ec 8d       	ldd	r30, Y+28	; 0x1c
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:280
  var2 = var2 + ((var1 * (int64_t)_bmp280_calib.dig_P5) << 17);
    176e:	fd 8d       	ldd	r31, Y+29	; 0x1d
    1770:	34 a1       	ldd	r19, Z+36	; 0x24
    1772:	23 a1       	ldd	r18, Z+35	; 0x23
    1774:	93 2f       	mov	r25, r19
    1776:	99 0f       	add	r25, r25
    1778:	99 0b       	sbc	r25, r25
    177a:	a9 84       	ldd	r10, Y+9	; 0x09
    177c:	ba 84       	ldd	r11, Y+10	; 0x0a
    177e:	cb 84       	ldd	r12, Y+11	; 0x0b
    1780:	dc 84       	ldd	r13, Y+12	; 0x0c
    1782:	73 01       	movw	r14, r6
    1784:	84 01       	movw	r16, r8
    1786:	49 2f       	mov	r20, r25
    1788:	59 2f       	mov	r21, r25
    178a:	69 2f       	mov	r22, r25
    178c:	79 2f       	mov	r23, r25
    178e:	89 2f       	mov	r24, r25
    1790:	0e 94 18 17 	call	0x2e30	; 0x2e30 <__muldi3>
    1794:	01 e1       	ldi	r16, 0x11	; 17
    1796:	0e 94 01 18 	call	0x3002	; 0x3002 <__ashldi3>
    179a:	51 01       	movw	r10, r2
    179c:	ca 88       	ldd	r12, Y+18	; 0x12
    179e:	db 88       	ldd	r13, Y+19	; 0x13
    17a0:	ec 88       	ldd	r14, Y+20	; 0x14
    17a2:	fd 88       	ldd	r15, Y+21	; 0x15
    17a4:	0e 89       	ldd	r16, Y+22	; 0x16
    17a6:	1f 89       	ldd	r17, Y+23	; 0x17
    17a8:	0e 94 37 18 	call	0x306e	; 0x306e <__adddi3>
    17ac:	59 01       	movw	r10, r18
    17ae:	6a 01       	movw	r12, r20
    17b0:	7b 01       	movw	r14, r22
    17b2:	28 2e       	mov	r2, r24
    17b4:	19 2f       	mov	r17, r25
    17b6:	48 8d       	ldd	r20, Y+24	; 0x18
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:276

  // Must be done first to get the t_fine variable set up
  readTemperature();

  int32_t adc_P = read24(BMP280_REGISTER_PRESSUREDATA);
  adc_P >>= 4;
    17b8:	59 8d       	ldd	r21, Y+25	; 0x19
    17ba:	6a 8d       	ldd	r22, Y+26	; 0x1a
    17bc:	7b 8d       	ldd	r23, Y+27	; 0x1b
    17be:	84 e0       	ldi	r24, 0x04	; 4
    17c0:	75 95       	asr	r23
    17c2:	67 95       	ror	r22
    17c4:	57 95       	ror	r21
    17c6:	47 95       	ror	r20
    17c8:	8a 95       	dec	r24
    17ca:	d1 f7       	brne	.-12     	; 0x17c0 <Adafruit_BMP280::readPressure()+0x20c>
    17cc:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:290
      (((((int64_t)1) << 47) + var1)) * ((int64_t)_bmp280_calib.dig_P1) >> 33;

  if (var1 == 0) {
    return 0; // avoid exception caused by division by zero
  }
  p = 1048576 - adc_P;
    17ce:	90 e0       	ldi	r25, 0x00	; 0
    17d0:	a0 e1       	ldi	r26, 0x10	; 16
    17d2:	b0 e0       	ldi	r27, 0x00	; 0
    17d4:	84 1b       	sub	r24, r20
    17d6:	95 0b       	sbc	r25, r21
    17d8:	a6 0b       	sbc	r26, r22
    17da:	b7 0b       	sbc	r27, r23
    17dc:	3c 01       	movw	r6, r24
    17de:	4d 01       	movw	r8, r26
    17e0:	99 0c       	add	r9, r9
    17e2:	66 08       	sbc	r6, r6
    17e4:	76 2c       	mov	r7, r6
    17e6:	43 01       	movw	r8, r6
    17e8:	9c 01       	movw	r18, r24
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:291
  p = (((p << 31) - var2) * 3125) / var1;
    17ea:	ad 01       	movw	r20, r26
    17ec:	66 2d       	mov	r22, r6
    17ee:	76 2d       	mov	r23, r6
    17f0:	86 2d       	mov	r24, r6
    17f2:	96 2d       	mov	r25, r6
    17f4:	0f e1       	ldi	r16, 0x1F	; 31
    17f6:	0e 94 01 18 	call	0x3002	; 0x3002 <__ashldi3>
    17fa:	72 2e       	mov	r7, r18
    17fc:	83 2e       	mov	r8, r19
    17fe:	94 2e       	mov	r9, r20
    1800:	65 2e       	mov	r6, r21
    1802:	b6 2f       	mov	r27, r22
    1804:	a7 2f       	mov	r26, r23
    1806:	38 2e       	mov	r3, r24
    1808:	99 87       	std	Y+9, r25	; 0x09
    180a:	ec 8d       	ldd	r30, Y+28	; 0x1c
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:281
  adc_P >>= 4;

  var1 = ((int64_t)t_fine) - 128000;
  var2 = var1 * var1 * (int64_t)_bmp280_calib.dig_P6;
  var2 = var2 + ((var1 * (int64_t)_bmp280_calib.dig_P5) << 17);
  var2 = var2 + (((int64_t)_bmp280_calib.dig_P4) << 35);
    180c:	fd 8d       	ldd	r31, Y+29	; 0x1d
    180e:	32 a1       	ldd	r19, Z+34	; 0x22
    1810:	21 a1       	ldd	r18, Z+33	; 0x21
    1812:	93 2f       	mov	r25, r19
    1814:	99 0f       	add	r25, r25
    1816:	99 0b       	sbc	r25, r25
    1818:	49 2f       	mov	r20, r25
    181a:	59 2f       	mov	r21, r25
    181c:	69 2f       	mov	r22, r25
    181e:	79 2f       	mov	r23, r25
    1820:	89 2f       	mov	r24, r25
    1822:	03 e2       	ldi	r16, 0x23	; 35
    1824:	0e 94 01 18 	call	0x3002	; 0x3002 <__ashldi3>
    1828:	02 2d       	mov	r16, r2
    182a:	0e 94 37 18 	call	0x306e	; 0x306e <__adddi3>
    182e:	59 01       	movw	r10, r18
    1830:	6a 01       	movw	r12, r20
    1832:	7b 01       	movw	r14, r22
    1834:	8c 01       	movw	r16, r24
    1836:	27 2d       	mov	r18, r7
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:291

  if (var1 == 0) {
    return 0; // avoid exception caused by division by zero
  }
  p = 1048576 - adc_P;
  p = (((p << 31) - var2) * 3125) / var1;
    1838:	38 2d       	mov	r19, r8
    183a:	49 2d       	mov	r20, r9
    183c:	56 2d       	mov	r21, r6
    183e:	6b 2f       	mov	r22, r27
    1840:	7a 2f       	mov	r23, r26
    1842:	83 2d       	mov	r24, r3
    1844:	99 85       	ldd	r25, Y+9	; 0x09
    1846:	0e 94 40 18 	call	0x3080	; 0x3080 <__subdi3>
    184a:	e5 e3       	ldi	r30, 0x35	; 53
    184c:	ae 2e       	mov	r10, r30
    184e:	fc e0       	ldi	r31, 0x0C	; 12
    1850:	bf 2e       	mov	r11, r31
    1852:	c1 2c       	mov	r12, r1
    1854:	d1 2c       	mov	r13, r1
    1856:	e1 2c       	mov	r14, r1
    1858:	f1 2c       	mov	r15, r1
    185a:	00 e0       	ldi	r16, 0x00	; 0
    185c:	10 e0       	ldi	r17, 0x00	; 0
    185e:	0e 94 18 17 	call	0x2e30	; 0x2e30 <__muldi3>
    1862:	a9 80       	ldd	r10, Y+1	; 0x01
    1864:	b5 2c       	mov	r11, r5
    1866:	cd 84       	ldd	r12, Y+13	; 0x0d
    1868:	de 84       	ldd	r13, Y+14	; 0x0e
    186a:	ef 84       	ldd	r14, Y+15	; 0x0f
    186c:	f8 88       	ldd	r15, Y+16	; 0x10
    186e:	09 89       	ldd	r16, Y+17	; 0x11
    1870:	14 2d       	mov	r17, r4
    1872:	0e 94 6a 17 	call	0x2ed4	; 0x2ed4 <__divdi3>
    1876:	29 87       	std	Y+9, r18	; 0x09
    1878:	3a 87       	std	Y+10, r19	; 0x0a
    187a:	4b 87       	std	Y+11, r20	; 0x0b
    187c:	5c 87       	std	Y+12, r21	; 0x0c
    187e:	69 83       	std	Y+1, r22	; 0x01
    1880:	7d 87       	std	Y+13, r23	; 0x0d
    1882:	8e 87       	std	Y+14, r24	; 0x0e
    1884:	9f 87       	std	Y+15, r25	; 0x0f
    1886:	0d e0       	ldi	r16, 0x0D	; 13
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:292
  var1 = (((int64_t)_bmp280_calib.dig_P9) * (p >> 13) * (p >> 13)) >> 25;
    1888:	0e 94 1a 18 	call	0x3034	; 0x3034 <__ashrdi3>
    188c:	92 2e       	mov	r9, r18
    188e:	83 2e       	mov	r8, r19
    1890:	74 2e       	mov	r7, r20
    1892:	65 2e       	mov	r6, r21
    1894:	56 2e       	mov	r5, r22
    1896:	47 2e       	mov	r4, r23
    1898:	38 2e       	mov	r3, r24
    189a:	29 2e       	mov	r2, r25
    189c:	ac 8d       	ldd	r26, Y+28	; 0x1c
    189e:	bd 8d       	ldd	r27, Y+29	; 0x1d
    18a0:	9c 96       	adiw	r26, 0x2c	; 44
    18a2:	3c 91       	ld	r19, X
    18a4:	9c 97       	sbiw	r26, 0x2c	; 44
    18a6:	9b 96       	adiw	r26, 0x2b	; 43
    18a8:	2c 91       	ld	r18, X
    18aa:	93 2f       	mov	r25, r19
    18ac:	99 0f       	add	r25, r25
    18ae:	99 0b       	sbc	r25, r25
    18b0:	a9 2c       	mov	r10, r9
    18b2:	b8 2c       	mov	r11, r8
    18b4:	c7 2c       	mov	r12, r7
    18b6:	d6 2c       	mov	r13, r6
    18b8:	e5 2c       	mov	r14, r5
    18ba:	f4 2c       	mov	r15, r4
    18bc:	03 2d       	mov	r16, r3
    18be:	12 2d       	mov	r17, r2
    18c0:	49 2f       	mov	r20, r25
    18c2:	59 2f       	mov	r21, r25
    18c4:	69 2f       	mov	r22, r25
    18c6:	79 2f       	mov	r23, r25
    18c8:	89 2f       	mov	r24, r25
    18ca:	0e 94 18 17 	call	0x2e30	; 0x2e30 <__muldi3>
    18ce:	0e 94 18 17 	call	0x2e30	; 0x2e30 <__muldi3>
    18d2:	09 e1       	ldi	r16, 0x19	; 25
    18d4:	0e 94 1a 18 	call	0x3034	; 0x3034 <__ashrdi3>
    18d8:	a9 84       	ldd	r10, Y+9	; 0x09
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:295
  var2 = (((int64_t)_bmp280_calib.dig_P8) * p) >> 19;

  p = ((p + var1 + var2) >> 8) + (((int64_t)_bmp280_calib.dig_P7) << 4);
    18da:	ba 84       	ldd	r11, Y+10	; 0x0a
    18dc:	cb 84       	ldd	r12, Y+11	; 0x0b
    18de:	dc 84       	ldd	r13, Y+12	; 0x0c
    18e0:	e9 80       	ldd	r14, Y+1	; 0x01
    18e2:	fd 84       	ldd	r15, Y+13	; 0x0d
    18e4:	0e 85       	ldd	r16, Y+14	; 0x0e
    18e6:	1f 85       	ldd	r17, Y+15	; 0x0f
    18e8:	0e 94 37 18 	call	0x306e	; 0x306e <__adddi3>
    18ec:	19 01       	movw	r2, r18
    18ee:	2a 01       	movw	r4, r20
    18f0:	3b 01       	movw	r6, r22
    18f2:	4c 01       	movw	r8, r24
    18f4:	ec 8d       	ldd	r30, Y+28	; 0x1c
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:293
    return 0; // avoid exception caused by division by zero
  }
  p = 1048576 - adc_P;
  p = (((p << 31) - var2) * 3125) / var1;
  var1 = (((int64_t)_bmp280_calib.dig_P9) * (p >> 13) * (p >> 13)) >> 25;
  var2 = (((int64_t)_bmp280_calib.dig_P8) * p) >> 19;
    18f6:	fd 8d       	ldd	r31, Y+29	; 0x1d
    18f8:	32 a5       	ldd	r19, Z+42	; 0x2a
    18fa:	21 a5       	ldd	r18, Z+41	; 0x29
    18fc:	93 2f       	mov	r25, r19
    18fe:	99 0f       	add	r25, r25
    1900:	99 0b       	sbc	r25, r25
    1902:	49 2f       	mov	r20, r25
    1904:	59 2f       	mov	r21, r25
    1906:	69 2f       	mov	r22, r25
    1908:	79 2f       	mov	r23, r25
    190a:	89 2f       	mov	r24, r25
    190c:	0e 94 18 17 	call	0x2e30	; 0x2e30 <__muldi3>
    1910:	03 e1       	ldi	r16, 0x13	; 19
    1912:	0e 94 1a 18 	call	0x3034	; 0x3034 <__ashrdi3>
    1916:	59 01       	movw	r10, r18
    1918:	6a 01       	movw	r12, r20
    191a:	7b 01       	movw	r14, r22
    191c:	8c 01       	movw	r16, r24
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:295

  p = ((p + var1 + var2) >> 8) + (((int64_t)_bmp280_calib.dig_P7) << 4);
    191e:	91 01       	movw	r18, r2
    1920:	a2 01       	movw	r20, r4
    1922:	b3 01       	movw	r22, r6
    1924:	c4 01       	movw	r24, r8
    1926:	0e 94 37 18 	call	0x306e	; 0x306e <__adddi3>
    192a:	08 e0       	ldi	r16, 0x08	; 8
    192c:	0e 94 1a 18 	call	0x3034	; 0x3034 <__ashrdi3>
    1930:	59 01       	movw	r10, r18
    1932:	6a 01       	movw	r12, r20
    1934:	7b 01       	movw	r14, r22
    1936:	e8 2f       	mov	r30, r24
    1938:	19 2f       	mov	r17, r25
    193a:	ac 8d       	ldd	r26, Y+28	; 0x1c
    193c:	bd 8d       	ldd	r27, Y+29	; 0x1d
    193e:	98 96       	adiw	r26, 0x28	; 40
    1940:	3c 91       	ld	r19, X
    1942:	98 97       	sbiw	r26, 0x28	; 40
    1944:	97 96       	adiw	r26, 0x27	; 39
    1946:	2c 91       	ld	r18, X
    1948:	93 2f       	mov	r25, r19
    194a:	99 0f       	add	r25, r25
    194c:	99 0b       	sbc	r25, r25
    194e:	49 2f       	mov	r20, r25
    1950:	59 2f       	mov	r21, r25
    1952:	69 2f       	mov	r22, r25
    1954:	79 2f       	mov	r23, r25
    1956:	89 2f       	mov	r24, r25
    1958:	04 e0       	ldi	r16, 0x04	; 4
    195a:	0e 94 01 18 	call	0x3002	; 0x3002 <__ashldi3>
    195e:	0e 2f       	mov	r16, r30
    1960:	0e 94 37 18 	call	0x306e	; 0x306e <__adddi3>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:296
  return (float)p / 256;
    1964:	50 d7       	rcall	.+3744   	; 0x2806 <__floatdisf>
    1966:	20 e0       	ldi	r18, 0x00	; 0
    1968:	30 e0       	ldi	r19, 0x00	; 0
    196a:	40 e8       	ldi	r20, 0x80	; 128
    196c:	5b e3       	ldi	r21, 0x3B	; 59
    196e:	0e 94 0b 15 	call	0x2a16	; 0x2a16 <__mulsf3>
    1972:	6d 96       	adiw	r28, 0x1d	; 29
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:297
}
    1974:	cd bf       	out	0x3d, r28	; 61
    1976:	de bf       	out	0x3e, r29	; 62
    1978:	df 91       	pop	r29
    197a:	cf 91       	pop	r28
    197c:	1f 91       	pop	r17
    197e:	0f 91       	pop	r16
    1980:	ff 90       	pop	r15
    1982:	ef 90       	pop	r14
    1984:	df 90       	pop	r13
    1986:	cf 90       	pop	r12
    1988:	bf 90       	pop	r11
    198a:	af 90       	pop	r10
    198c:	9f 90       	pop	r9
    198e:	8f 90       	pop	r8
    1990:	7f 90       	pop	r7
    1992:	6f 90       	pop	r6
    1994:	5f 90       	pop	r5
    1996:	4f 90       	pop	r4
    1998:	3f 90       	pop	r3
    199a:	2f 90       	pop	r2
    199c:	08 95       	ret
    199e:	60 e0       	ldi	r22, 0x00	; 0
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:288
         ((var1 * (int64_t)_bmp280_calib.dig_P2) << 12);
  var1 =
      (((((int64_t)1) << 47) + var1)) * ((int64_t)_bmp280_calib.dig_P1) >> 33;

  if (var1 == 0) {
    return 0; // avoid exception caused by division by zero
    19a0:	70 e0       	ldi	r23, 0x00	; 0
    19a2:	cb 01       	movw	r24, r22
    19a4:	e6 cf       	rjmp	.-52     	; 0x1972 <Adafruit_BMP280::readPressure()+0x3be>

000019a6 <Adafruit_BMP280_Temp::~Adafruit_BMP280_Temp()>:
_ZN20Adafruit_BMP280_TempD0Ev():
    19a6:	0c 94 06 19 	jmp	0x320c	; 0x320c <free>

000019aa <Adafruit_BMP280_Pressure::~Adafruit_BMP280_Pressure()>:
_ZN24Adafruit_BMP280_PressureD0Ev():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/new.cpp:63
// Since C++14, also need two more delete variants...
// Note thnat this CAN break code that compiled amd worked in C++11.
#if (__cpp_sized_deallocation >= 201309L)
  void  operator delete  (void* ptr, size_t size) noexcept {
    (void) size;
    free(ptr);
    19aa:	0c 94 06 19 	jmp	0x320c	; 0x320c <free>

000019ae <Adafruit_BMP280_Pressure::getEvent(sensors_event_t*)>:
_ZN24Adafruit_BMP280_Pressure8getEventEP15sensors_event_t():
    19ae:	cf 93       	push	r28
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:477
    @brief  Gets the pressure as a standard sensor event
    @param  event Sensor event object that will be populated
    @returns True
*/
/**************************************************************************/
bool Adafruit_BMP280_Pressure::getEvent(sensors_event_t *event) {
    19b0:	df 93       	push	r29
    19b2:	eb 01       	movw	r28, r22
    19b4:	fb 01       	movw	r30, r22
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:479
  /* Clear the event */
  memset(event, 0, sizeof(sensors_event_t));
    19b6:	34 96       	adiw	r30, 0x04	; 4
    19b8:	20 e2       	ldi	r18, 0x20	; 32
    19ba:	df 01       	movw	r26, r30
    19bc:	1d 92       	st	X+, r1
    19be:	2a 95       	dec	r18
    19c0:	e9 f7       	brne	.-6      	; 0x19bc <Adafruit_BMP280_Pressure::getEvent(sensors_event_t*)+0xe>
    19c2:	44 e2       	ldi	r20, 0x24	; 36
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:481

  event->version = sizeof(sensors_event_t);
    19c4:	50 e0       	ldi	r21, 0x00	; 0
    19c6:	60 e0       	ldi	r22, 0x00	; 0
    19c8:	70 e0       	ldi	r23, 0x00	; 0
    19ca:	48 83       	st	Y, r20
    19cc:	59 83       	std	Y+1, r21	; 0x01
    19ce:	6a 83       	std	Y+2, r22	; 0x02
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:482
  event->sensor_id = _sensorID;
    19d0:	7b 83       	std	Y+3, r23	; 0x03
    19d2:	fc 01       	movw	r30, r24
    19d4:	43 81       	ldd	r20, Z+3	; 0x03
    19d6:	54 81       	ldd	r21, Z+4	; 0x04
    19d8:	05 2e       	mov	r0, r21
    19da:	00 0c       	add	r0, r0
    19dc:	66 0b       	sbc	r22, r22
    19de:	77 0b       	sbc	r23, r23
    19e0:	4c 83       	std	Y+4, r20	; 0x04
    19e2:	5d 83       	std	Y+5, r21	; 0x05
    19e4:	6e 83       	std	Y+6, r22	; 0x06
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:483
  event->type = SENSOR_TYPE_PRESSURE;
    19e6:	7f 83       	std	Y+7, r23	; 0x07
    19e8:	46 e0       	ldi	r20, 0x06	; 6
    19ea:	50 e0       	ldi	r21, 0x00	; 0
    19ec:	60 e0       	ldi	r22, 0x00	; 0
    19ee:	70 e0       	ldi	r23, 0x00	; 0
    19f0:	48 87       	std	Y+8, r20	; 0x08
    19f2:	59 87       	std	Y+9, r21	; 0x09
    19f4:	6a 87       	std	Y+10, r22	; 0x0a
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:226


unsigned long millis() {
  // return timer_overflow_count; // for debugging timekeeping issues where these variables are out of scope from the sketch
  unsigned long m;
  uint8_t oldSREG = SREG;
    19f6:	7b 87       	std	Y+11, r23	; 0x0b
millis():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:227
  cli();
    19f8:	2f b7       	in	r18, 0x3f	; 63
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:255

     * Not only that - but a dedicated optimizing assembly programmer could probably ensure that instead of the >> 7 (a little mini loop)
     * that was implemented leftshifting it once, retaining the carried bit, and
     */
  #else
    m = timer_millis;
    19fa:	f8 94       	cli
    19fc:	40 91 0a 38 	lds	r20, 0x380A	; 0x80380a <timer_millis>
    1a00:	50 91 0b 38 	lds	r21, 0x380B	; 0x80380b <timer_millis+0x1>
    1a04:	60 91 0c 38 	lds	r22, 0x380C	; 0x80380c <timer_millis+0x2>
    1a08:	70 91 0d 38 	lds	r23, 0x380D	; 0x80380d <timer_millis+0x3>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:484
  event->timestamp = millis();
    1a0c:	2f bf       	out	0x3f, r18	; 63
_ZN24Adafruit_BMP280_Pressure8getEventEP15sensors_event_t():
    1a0e:	48 8b       	std	Y+16, r20	; 0x10
    1a10:	59 8b       	std	Y+17, r21	; 0x11
    1a12:	6a 8b       	std	Y+18, r22	; 0x12
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:485
  event->pressure = _theBMP280->readPressure() / 100; // convert Pa to hPa
    1a14:	7b 8b       	std	Y+19, r23	; 0x13
    1a16:	85 81       	ldd	r24, Z+5	; 0x05
    1a18:	96 81       	ldd	r25, Z+6	; 0x06
    1a1a:	cc dd       	rcall	.-1128   	; 0x15b4 <Adafruit_BMP280::readPressure()>
    1a1c:	20 e0       	ldi	r18, 0x00	; 0
    1a1e:	30 e0       	ldi	r19, 0x00	; 0
    1a20:	48 ec       	ldi	r20, 0xC8	; 200
    1a22:	52 e4       	ldi	r21, 0x42	; 66
    1a24:	5c d6       	rcall	.+3256   	; 0x26de <__divsf3>
    1a26:	6c 8b       	std	Y+20, r22	; 0x14
    1a28:	7d 8b       	std	Y+21, r23	; 0x15
    1a2a:	8e 8b       	std	Y+22, r24	; 0x16
    1a2c:	9f 8b       	std	Y+23, r25	; 0x17
    1a2e:	81 e0       	ldi	r24, 0x01	; 1
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:487
  return true;
}
    1a30:	df 91       	pop	r29
    1a32:	cf 91       	pop	r28
    1a34:	08 95       	ret

00001a36 <Adafruit_BMP280_Temp::getEvent(sensors_event_t*)>:
_ZN20Adafruit_BMP280_Temp8getEventEP15sensors_event_t():
    1a36:	cf 93       	push	r28
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:437
    @brief  Gets the temperature as a standard sensor event
    @param  event Sensor event object that will be populated
    @returns True
*/
/**************************************************************************/
bool Adafruit_BMP280_Temp::getEvent(sensors_event_t *event) {
    1a38:	df 93       	push	r29
    1a3a:	eb 01       	movw	r28, r22
    1a3c:	fb 01       	movw	r30, r22
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:439
  /* Clear the event */
  memset(event, 0, sizeof(sensors_event_t));
    1a3e:	34 96       	adiw	r30, 0x04	; 4
    1a40:	20 e2       	ldi	r18, 0x20	; 32
    1a42:	df 01       	movw	r26, r30
    1a44:	1d 92       	st	X+, r1
    1a46:	2a 95       	dec	r18
    1a48:	e9 f7       	brne	.-6      	; 0x1a44 <Adafruit_BMP280_Temp::getEvent(sensors_event_t*)+0xe>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:441

  event->version = sizeof(sensors_event_t);
    1a4a:	44 e2       	ldi	r20, 0x24	; 36
    1a4c:	50 e0       	ldi	r21, 0x00	; 0
    1a4e:	60 e0       	ldi	r22, 0x00	; 0
    1a50:	70 e0       	ldi	r23, 0x00	; 0
    1a52:	48 83       	st	Y, r20
    1a54:	59 83       	std	Y+1, r21	; 0x01
    1a56:	6a 83       	std	Y+2, r22	; 0x02
    1a58:	7b 83       	std	Y+3, r23	; 0x03
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:442
  event->sensor_id = _sensorID;
    1a5a:	fc 01       	movw	r30, r24
    1a5c:	43 81       	ldd	r20, Z+3	; 0x03
    1a5e:	54 81       	ldd	r21, Z+4	; 0x04
    1a60:	05 2e       	mov	r0, r21
    1a62:	00 0c       	add	r0, r0
    1a64:	66 0b       	sbc	r22, r22
    1a66:	77 0b       	sbc	r23, r23
    1a68:	4c 83       	std	Y+4, r20	; 0x04
    1a6a:	5d 83       	std	Y+5, r21	; 0x05
    1a6c:	6e 83       	std	Y+6, r22	; 0x06
    1a6e:	7f 83       	std	Y+7, r23	; 0x07
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:443
  event->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
    1a70:	4d e0       	ldi	r20, 0x0D	; 13
    1a72:	50 e0       	ldi	r21, 0x00	; 0
    1a74:	60 e0       	ldi	r22, 0x00	; 0
    1a76:	70 e0       	ldi	r23, 0x00	; 0
    1a78:	48 87       	std	Y+8, r20	; 0x08
    1a7a:	59 87       	std	Y+9, r21	; 0x09
    1a7c:	6a 87       	std	Y+10, r22	; 0x0a
    1a7e:	7b 87       	std	Y+11, r23	; 0x0b
millis():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:226


unsigned long millis() {
  // return timer_overflow_count; // for debugging timekeeping issues where these variables are out of scope from the sketch
  unsigned long m;
  uint8_t oldSREG = SREG;
    1a80:	2f b7       	in	r18, 0x3f	; 63
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:227
  cli();
    1a82:	f8 94       	cli
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:255

     * Not only that - but a dedicated optimizing assembly programmer could probably ensure that instead of the >> 7 (a little mini loop)
     * that was implemented leftshifting it once, retaining the carried bit, and
     */
  #else
    m = timer_millis;
    1a84:	40 91 0a 38 	lds	r20, 0x380A	; 0x80380a <timer_millis>
    1a88:	50 91 0b 38 	lds	r21, 0x380B	; 0x80380b <timer_millis+0x1>
    1a8c:	60 91 0c 38 	lds	r22, 0x380C	; 0x80380c <timer_millis+0x2>
    1a90:	70 91 0d 38 	lds	r23, 0x380D	; 0x80380d <timer_millis+0x3>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:256
    SREG = oldSREG;
    1a94:	2f bf       	out	0x3f, r18	; 63
_ZN20Adafruit_BMP280_Temp8getEventEP15sensors_event_t():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:444
  event->timestamp = millis();
    1a96:	48 8b       	std	Y+16, r20	; 0x10
    1a98:	59 8b       	std	Y+17, r21	; 0x11
    1a9a:	6a 8b       	std	Y+18, r22	; 0x12
    1a9c:	7b 8b       	std	Y+19, r23	; 0x13
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:445
  event->temperature = _theBMP280->readTemperature();
    1a9e:	85 81       	ldd	r24, Z+5	; 0x05
    1aa0:	96 81       	ldd	r25, Z+6	; 0x06
    1aa2:	04 dd       	rcall	.-1528   	; 0x14ac <Adafruit_BMP280::readTemperature()>
    1aa4:	6c 8b       	std	Y+20, r22	; 0x14
    1aa6:	7d 8b       	std	Y+21, r23	; 0x15
    1aa8:	8e 8b       	std	Y+22, r24	; 0x16
    1aaa:	9f 8b       	std	Y+23, r25	; 0x17
    1aac:	81 e0       	ldi	r24, 0x01	; 1
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:447
  return true;
}
    1aae:	df 91       	pop	r29
    1ab0:	cf 91       	pop	r28
    1ab2:	08 95       	ret

00001ab4 <Adafruit_BMP280_Pressure::getSensor(sensor_t*)>:
_ZN24Adafruit_BMP280_Pressure9getSensorEP8sensor_t():
    1ab4:	0f 93       	push	r16
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:454
/**************************************************************************/
/*!
    @brief  Gets the sensor_t data for the BMP280's pressure sensor
*/
/**************************************************************************/
void Adafruit_BMP280_Pressure::getSensor(sensor_t *sensor) {
    1ab6:	1f 93       	push	r17
    1ab8:	cf 93       	push	r28
    1aba:	df 93       	push	r29
    1abc:	8c 01       	movw	r16, r24
    1abe:	eb 01       	movw	r28, r22
    1ac0:	88 e2       	ldi	r24, 0x28	; 40
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:456
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));
    1ac2:	fb 01       	movw	r30, r22
    1ac4:	11 92       	st	Z+, r1
    1ac6:	8a 95       	dec	r24
    1ac8:	e9 f7       	brne	.-6      	; 0x1ac4 <Adafruit_BMP280_Pressure::getSensor(sensor_t*)+0x10>
    1aca:	4b e0       	ldi	r20, 0x0B	; 11
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:459

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "BMP280", sizeof(sensor->name) - 1);
    1acc:	50 e0       	ldi	r21, 0x00	; 0
    1ace:	62 ee       	ldi	r22, 0xE2	; 226
    1ad0:	73 eb       	ldi	r23, 0xB3	; 179
    1ad2:	ce 01       	movw	r24, r28
    1ad4:	0e 94 8f 19 	call	0x331e	; 0x331e <strncpy>
    1ad8:	1b 86       	std	Y+11, r1	; 0x0b
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:460
  sensor->name[sizeof(sensor->name) - 1] = 0;
    1ada:	81 e0       	ldi	r24, 0x01	; 1
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:461
  sensor->version = 1;
    1adc:	90 e0       	ldi	r25, 0x00	; 0
    1ade:	a0 e0       	ldi	r26, 0x00	; 0
    1ae0:	b0 e0       	ldi	r27, 0x00	; 0
    1ae2:	8c 87       	std	Y+12, r24	; 0x0c
    1ae4:	9d 87       	std	Y+13, r25	; 0x0d
    1ae6:	ae 87       	std	Y+14, r26	; 0x0e
    1ae8:	bf 87       	std	Y+15, r27	; 0x0f
    1aea:	f8 01       	movw	r30, r16
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:462
  sensor->sensor_id = _sensorID;
    1aec:	83 81       	ldd	r24, Z+3	; 0x03
    1aee:	94 81       	ldd	r25, Z+4	; 0x04
    1af0:	09 2e       	mov	r0, r25
    1af2:	00 0c       	add	r0, r0
    1af4:	aa 0b       	sbc	r26, r26
    1af6:	bb 0b       	sbc	r27, r27
    1af8:	88 8b       	std	Y+16, r24	; 0x10
    1afa:	99 8b       	std	Y+17, r25	; 0x11
    1afc:	aa 8b       	std	Y+18, r26	; 0x12
    1afe:	bb 8b       	std	Y+19, r27	; 0x13
    1b00:	86 e0       	ldi	r24, 0x06	; 6
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:463
  sensor->type = SENSOR_TYPE_PRESSURE;
    1b02:	90 e0       	ldi	r25, 0x00	; 0
    1b04:	a0 e0       	ldi	r26, 0x00	; 0
    1b06:	b0 e0       	ldi	r27, 0x00	; 0
    1b08:	8c 8b       	std	Y+20, r24	; 0x14
    1b0a:	9d 8b       	std	Y+21, r25	; 0x15
    1b0c:	ae 8b       	std	Y+22, r26	; 0x16
    1b0e:	bf 8b       	std	Y+23, r27	; 0x17
    1b10:	1c a2       	std	Y+36, r1	; 0x24
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:464
  sensor->min_delay = 0;
    1b12:	1d a2       	std	Y+37, r1	; 0x25
    1b14:	1e a2       	std	Y+38, r1	; 0x26
    1b16:	1f a2       	std	Y+39, r1	; 0x27
    1b18:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:465
  sensor->min_value = 300.0; /* 300 ~ 1100 hPa  */
    1b1a:	90 e0       	ldi	r25, 0x00	; 0
    1b1c:	a6 e9       	ldi	r26, 0x96	; 150
    1b1e:	b3 e4       	ldi	r27, 0x43	; 67
    1b20:	8c 8f       	std	Y+28, r24	; 0x1c
    1b22:	9d 8f       	std	Y+29, r25	; 0x1d
    1b24:	ae 8f       	std	Y+30, r26	; 0x1e
    1b26:	bf 8f       	std	Y+31, r27	; 0x1f
    1b28:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:466
  sensor->max_value = 1100.0;
    1b2a:	90 e8       	ldi	r25, 0x80	; 128
    1b2c:	a9 e8       	ldi	r26, 0x89	; 137
    1b2e:	b4 e4       	ldi	r27, 0x44	; 68
    1b30:	88 8f       	std	Y+24, r24	; 0x18
    1b32:	99 8f       	std	Y+25, r25	; 0x19
    1b34:	aa 8f       	std	Y+26, r26	; 0x1a
    1b36:	bb 8f       	std	Y+27, r27	; 0x1b
    1b38:	86 ea       	ldi	r24, 0xA6	; 166
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:467
  sensor->resolution = 0.012; /* 0.12 hPa relative */
    1b3a:	9b e9       	ldi	r25, 0x9B	; 155
    1b3c:	a4 e4       	ldi	r26, 0x44	; 68
    1b3e:	bc e3       	ldi	r27, 0x3C	; 60
    1b40:	88 a3       	std	Y+32, r24	; 0x20
    1b42:	99 a3       	std	Y+33, r25	; 0x21
    1b44:	aa a3       	std	Y+34, r26	; 0x22
    1b46:	bb a3       	std	Y+35, r27	; 0x23
    1b48:	df 91       	pop	r29
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:468
}
    1b4a:	cf 91       	pop	r28
    1b4c:	1f 91       	pop	r17
    1b4e:	0f 91       	pop	r16
    1b50:	08 95       	ret

00001b52 <Adafruit_BMP280_Temp::getSensor(sensor_t*)>:
_ZN20Adafruit_BMP280_Temp9getSensorEP8sensor_t():
    1b52:	0f 93       	push	r16
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:414
/**************************************************************************/
/*!
    @brief  Gets the sensor_t data for the BMP280's temperature sensor
*/
/**************************************************************************/
void Adafruit_BMP280_Temp::getSensor(sensor_t *sensor) {
    1b54:	1f 93       	push	r17
    1b56:	cf 93       	push	r28
    1b58:	df 93       	push	r29
    1b5a:	8c 01       	movw	r16, r24
    1b5c:	eb 01       	movw	r28, r22
    1b5e:	88 e2       	ldi	r24, 0x28	; 40
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:416
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));
    1b60:	fb 01       	movw	r30, r22
    1b62:	11 92       	st	Z+, r1
    1b64:	8a 95       	dec	r24
    1b66:	e9 f7       	brne	.-6      	; 0x1b62 <Adafruit_BMP280_Temp::getSensor(sensor_t*)+0x10>
    1b68:	4b e0       	ldi	r20, 0x0B	; 11
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:419

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "BMP280", sizeof(sensor->name) - 1);
    1b6a:	50 e0       	ldi	r21, 0x00	; 0
    1b6c:	62 ee       	ldi	r22, 0xE2	; 226
    1b6e:	73 eb       	ldi	r23, 0xB3	; 179
    1b70:	ce 01       	movw	r24, r28
    1b72:	0e 94 8f 19 	call	0x331e	; 0x331e <strncpy>
    1b76:	1b 86       	std	Y+11, r1	; 0x0b
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:420
  sensor->name[sizeof(sensor->name) - 1] = 0;
    1b78:	81 e0       	ldi	r24, 0x01	; 1
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:421
  sensor->version = 1;
    1b7a:	90 e0       	ldi	r25, 0x00	; 0
    1b7c:	a0 e0       	ldi	r26, 0x00	; 0
    1b7e:	b0 e0       	ldi	r27, 0x00	; 0
    1b80:	8c 87       	std	Y+12, r24	; 0x0c
    1b82:	9d 87       	std	Y+13, r25	; 0x0d
    1b84:	ae 87       	std	Y+14, r26	; 0x0e
    1b86:	bf 87       	std	Y+15, r27	; 0x0f
    1b88:	f8 01       	movw	r30, r16
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:422
  sensor->sensor_id = _sensorID;
    1b8a:	83 81       	ldd	r24, Z+3	; 0x03
    1b8c:	94 81       	ldd	r25, Z+4	; 0x04
    1b8e:	09 2e       	mov	r0, r25
    1b90:	00 0c       	add	r0, r0
    1b92:	aa 0b       	sbc	r26, r26
    1b94:	bb 0b       	sbc	r27, r27
    1b96:	88 8b       	std	Y+16, r24	; 0x10
    1b98:	99 8b       	std	Y+17, r25	; 0x11
    1b9a:	aa 8b       	std	Y+18, r26	; 0x12
    1b9c:	bb 8b       	std	Y+19, r27	; 0x13
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:423
  sensor->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
    1b9e:	8d e0       	ldi	r24, 0x0D	; 13
    1ba0:	90 e0       	ldi	r25, 0x00	; 0
    1ba2:	a0 e0       	ldi	r26, 0x00	; 0
    1ba4:	b0 e0       	ldi	r27, 0x00	; 0
    1ba6:	8c 8b       	std	Y+20, r24	; 0x14
    1ba8:	9d 8b       	std	Y+21, r25	; 0x15
    1baa:	ae 8b       	std	Y+22, r26	; 0x16
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:424
  sensor->min_delay = 0;
    1bac:	bf 8b       	std	Y+23, r27	; 0x17
    1bae:	1c a2       	std	Y+36, r1	; 0x24
    1bb0:	1d a2       	std	Y+37, r1	; 0x25
    1bb2:	1e a2       	std	Y+38, r1	; 0x26
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:425
  sensor->min_value = -40.0; /* Temperature range -40 ~ +85 C  */
    1bb4:	1f a2       	std	Y+39, r1	; 0x27
    1bb6:	80 e0       	ldi	r24, 0x00	; 0
    1bb8:	90 e0       	ldi	r25, 0x00	; 0
    1bba:	a0 e2       	ldi	r26, 0x20	; 32
    1bbc:	b2 ec       	ldi	r27, 0xC2	; 194
    1bbe:	8c 8f       	std	Y+28, r24	; 0x1c
    1bc0:	9d 8f       	std	Y+29, r25	; 0x1d
    1bc2:	ae 8f       	std	Y+30, r26	; 0x1e
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:426
  sensor->max_value = +85.0;
    1bc4:	bf 8f       	std	Y+31, r27	; 0x1f
    1bc6:	80 e0       	ldi	r24, 0x00	; 0
    1bc8:	90 e0       	ldi	r25, 0x00	; 0
    1bca:	aa ea       	ldi	r26, 0xAA	; 170
    1bcc:	b2 e4       	ldi	r27, 0x42	; 66
    1bce:	88 8f       	std	Y+24, r24	; 0x18
    1bd0:	99 8f       	std	Y+25, r25	; 0x19
    1bd2:	aa 8f       	std	Y+26, r26	; 0x1a
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:427
  sensor->resolution = 0.01; /*  0.01 C */
    1bd4:	bb 8f       	std	Y+27, r27	; 0x1b
    1bd6:	8a e0       	ldi	r24, 0x0A	; 10
    1bd8:	97 ed       	ldi	r25, 0xD7	; 215
    1bda:	a3 e2       	ldi	r26, 0x23	; 35
    1bdc:	bc e3       	ldi	r27, 0x3C	; 60
    1bde:	88 a3       	std	Y+32, r24	; 0x20
    1be0:	99 a3       	std	Y+33, r25	; 0x21
    1be2:	aa a3       	std	Y+34, r26	; 0x22
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:428
}
    1be4:	bb a3       	std	Y+35, r27	; 0x23
    1be6:	df 91       	pop	r29
    1be8:	cf 91       	pop	r28
    1bea:	1f 91       	pop	r17
    1bec:	0f 91       	pop	r16
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART0.cpp:73
  #else
    ISR(USART0_DRE_vect, ISR_NAKED) {
      __asm__ __volatile__(
                "push  r30"    "\n\t"
                "push  r31"    "\n\t"
                :::);
    1bee:	08 95       	ret

00001bf0 <__vector_18>:
__vector_18():
    1bf0:	ef 93       	push	r30
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART0.cpp:76
      __asm__ __volatile__(
                "jmp _do_dre"  "\n"
                ::"z"(&Serial));
    1bf2:	ff 93       	push	r31
    1bf4:	ea e1       	ldi	r30, 0x1A	; 26
    1bf6:	f8 e3       	ldi	r31, 0x38	; 56
    1bf8:	08 c0       	rjmp	.+16     	; 0x1c0a <_do_dre()>

00001bfa <__vector_17>:
__vector_17():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART0.cpp:55
  #else
    ISR(USART0_RXC_vect, ISR_NAKED) {
      __asm__ __volatile__(
            "push      r30"     "\n\t"
            "push      r31"     "\n\t"
            :::);
    1bfa:	ef 93       	push	r30
    1bfc:	ff 93       	push	r31
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART0.cpp:58
      __asm__ __volatile__(
            "jmp   _do_rxc"     "\n\t"
            ::"z"(&Serial));
    1bfe:	ea e1       	ldi	r30, 0x1A	; 26
    1c00:	f8 e3       	ldi	r31, 0x38	; 56
    1c02:	32 c0       	rjmp	.+100    	; 0x1c68 <_do_rxc()>

00001c04 <__vector_19>:
__vector_19():
    1c04:	ef 93       	push	r30
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART0.cpp:31
    ISR(USART0_TXC_vect, ISR_NAKED) {
      __asm__ __volatile__(
            "push  r30"         "\n\t" // push the low byte of Z
            "ldi r30, 0x00"     "\n\t" // and put the low bit of this USART there - 0x20 * n
            "jmp _do_txc"      "\n\t" // _do_txc pushes the other necessary registers and loads 0x08 into the high byte.
            :::);
    1c06:	e0 e0       	ldi	r30, 0x00	; 0
    1c08:	53 c0       	rjmp	.+166    	; 0x1cb0 <_do_txc()>

00001c0a <_do_dre()>:
_Z7_do_drev():
    1c0a:	2f 93       	push	r18
    1c0c:	2f b7       	in	r18, 0x3f	; 63
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:307
      "out        0x3f,     r18"      "\n\t"  // restore SREG
      "pop         r18"               "\n\t"  // pop old r18
      "pop         r31"               "\n\t"  // pop the Z that the isr pushed.
      "pop         r30"               "\n\t"
      "reti"                        "\n"   // and RETI!
      ::);
    1c0e:	2f 93       	push	r18
    1c10:	8f 93       	push	r24
    1c12:	9f 93       	push	r25
    1c14:	af 93       	push	r26
    1c16:	bf 93       	push	r27
    1c18:	68 94       	set

00001c1a <_poll_dre>:
    1c1a:	cf 93       	push	r28
    1c1c:	df 93       	push	r29
    1c1e:	20 e0       	ldi	r18, 0x00	; 0
    1c20:	c4 85       	ldd	r28, Z+12	; 0x0c
    1c22:	d8 e0       	ldi	r29, 0x08	; 8
    1c24:	94 89       	ldd	r25, Z+20	; 0x14
    1c26:	df 01       	movw	r26, r30
    1c28:	a9 0f       	add	r26, r25
    1c2a:	b2 1f       	adc	r27, r18
    1c2c:	ab 5a       	subi	r26, 0xAB	; 171
    1c2e:	bf 4f       	sbci	r27, 0xFF	; 255
    1c30:	8c 91       	ld	r24, X
    1c32:	20 e4       	ldi	r18, 0x40	; 64
    1c34:	2c 83       	std	Y+4, r18	; 0x04
    1c36:	8a 83       	std	Y+2, r24	; 0x02
    1c38:	9f 5f       	subi	r25, 0xFF	; 255
    1c3a:	9f 73       	andi	r25, 0x3F	; 63
    1c3c:	8d 81       	ldd	r24, Y+5	; 0x05
    1c3e:	23 89       	ldd	r18, Z+19	; 0x13
    1c40:	29 13       	cpse	r18, r25
    1c42:	02 c0       	rjmp	.+4      	; 0x1c48 <_done_dre_irq>
    1c44:	8f 7d       	andi	r24, 0xDF	; 223
    1c46:	8d 83       	std	Y+5, r24	; 0x05

00001c48 <_done_dre_irq>:
    1c48:	94 8b       	std	Z+20, r25	; 0x14
    1c4a:	df 91       	pop	r29
    1c4c:	cf 91       	pop	r28
    1c4e:	16 f0       	brts	.+4      	; 0x1c54 <_done_dre_irq+0xc>
    1c50:	0c 94 87 01 	jmp	0x30e	; 0x30e <_poll_dre_done>
    1c54:	bf 91       	pop	r27
    1c56:	af 91       	pop	r26
    1c58:	9f 91       	pop	r25
    1c5a:	8f 91       	pop	r24
    1c5c:	2f 91       	pop	r18
    1c5e:	2f bf       	out	0x3f, r18	; 63
    1c60:	2f 91       	pop	r18
    1c62:	ff 91       	pop	r31
    1c64:	ef 91       	pop	r30
    1c66:	18 95       	reti

00001c68 <_do_rxc()>:
_Z7_do_rxcv():
    1c68:	2f 93       	push	r18
    1c6a:	2f b7       	in	r18, 0x3f	; 63
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:175
        "out       0x3f,       r18"   "\n\t" // and write back
        "pop        r18"              "\n\t" // used as tail pointer and z known zero.
        "pop        r31"              "\n\t" // end with Z which the isr pushed to make room for
        "pop        r30"              "\n\t" // pointer to serial instance
        "reti"                        "\n"   // return
        ::);
    1c6c:	2f 93       	push	r18
    1c6e:	8f 93       	push	r24
    1c70:	9f 93       	push	r25
    1c72:	cf 93       	push	r28
    1c74:	df 93       	push	r29
    1c76:	c4 85       	ldd	r28, Z+12	; 0x0c
    1c78:	d8 e0       	ldi	r29, 0x08	; 8
    1c7a:	89 81       	ldd	r24, Y+1	; 0x01
    1c7c:	98 81       	ld	r25, Y
    1c7e:	81 fd       	sbrc	r24, 1
    1c80:	0d c0       	rjmp	.+26     	; 0x1c9c <_end_rxc>
    1c82:	c1 89       	ldd	r28, Z+17	; 0x11
    1c84:	81 e0       	ldi	r24, 0x01	; 1
    1c86:	8c 0f       	add	r24, r28
    1c88:	8f 73       	andi	r24, 0x3F	; 63
    1c8a:	22 89       	ldd	r18, Z+18	; 0x12
    1c8c:	28 17       	cp	r18, r24
    1c8e:	31 f0       	breq	.+12     	; 0x1c9c <_end_rxc>
    1c90:	ce 0f       	add	r28, r30
    1c92:	df 2f       	mov	r29, r31
    1c94:	20 e0       	ldi	r18, 0x00	; 0
    1c96:	d2 1f       	adc	r29, r18
    1c98:	9d 8b       	std	Y+21, r25	; 0x15
    1c9a:	81 8b       	std	Z+17, r24	; 0x11

00001c9c <_end_rxc>:
    1c9c:	df 91       	pop	r29
    1c9e:	cf 91       	pop	r28
    1ca0:	9f 91       	pop	r25
    1ca2:	8f 91       	pop	r24
    1ca4:	2f 91       	pop	r18
    1ca6:	2f bf       	out	0x3f, r18	; 63
    1ca8:	2f 91       	pop	r18
    1caa:	ff 91       	pop	r31
    1cac:	ef 91       	pop	r30
    1cae:	18 95       	reti

00001cb0 <_do_txc()>:
_Z7_do_txcv():
    1cb0:	ff 93       	push	r31
    1cb2:	8f 93       	push	r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:105
        "out     0x3f,      r24"  "\n\t"  // restore it
        "pop      r24"            "\n\t"  // pop r24 to get it's old value back
        "pop      r31"            "\n\t"  // and r31
        "pop      r30"            "\n\t"  // Pop the register the ISR did
        "reti"                    "\n"    // return from the interrupt.
        ::);
    1cb4:	8f b7       	in	r24, 0x3f	; 63
    1cb6:	8f 93       	push	r24
    1cb8:	f8 e0       	ldi	r31, 0x08	; 8

00001cba <_txc_flush_rx>:
    1cba:	80 81       	ld	r24, Z
    1cbc:	84 81       	ldd	r24, Z+4	; 0x04
    1cbe:	87 ff       	sbrs	r24, 7
    1cc0:	fc cf       	rjmp	.-8      	; 0x1cba <_txc_flush_rx>
    1cc2:	85 81       	ldd	r24, Z+5	; 0x05
    1cc4:	8f 7b       	andi	r24, 0xBF	; 191
    1cc6:	80 68       	ori	r24, 0x80	; 128
    1cc8:	85 83       	std	Z+5, r24	; 0x05
    1cca:	8f 91       	pop	r24
    1ccc:	8f bf       	out	0x3f, r24	; 63
    1cce:	8f 91       	pop	r24
    1cd0:	ff 91       	pop	r31
    1cd2:	ef 91       	pop	r30
    1cd4:	18 95       	reti

00001cd6 <__vector_25>:
__vector_25():
    1cd6:	1f 92       	push	r1
    1cd8:	0f 92       	push	r0
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:142
#elif defined(MILLIS_USE_TIMERB1)
  ISR(TCB1_INT_vect)
#else
  #error "No millis timer selected, but not disabled - cannot determine millis vector"
#endif
{
    1cda:	0f b6       	in	r0, 0x3f	; 63
    1cdc:	0f 92       	push	r0
    1cde:	11 24       	eor	r1, r1
    1ce0:	8f 93       	push	r24
    1ce2:	9f 93       	push	r25
    1ce4:	af 93       	push	r26
    1ce6:	bf 93       	push	r27
    1ce8:	80 91 0a 38 	lds	r24, 0x380A	; 0x80380a <timer_millis>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:148
  // copy these to local variables so they can be stored in registers
  // (volatile variables must be read from memory on every access)

  #if (defined(MILLIS_USE_TIMERB0)|defined(MILLIS_USE_TIMERB1))
    #if (F_CPU>1000000)
      timer_millis++; // that's all we need to do!
    1cec:	90 91 0b 38 	lds	r25, 0x380B	; 0x80380b <timer_millis+0x1>
    1cf0:	a0 91 0c 38 	lds	r26, 0x380C	; 0x80380c <timer_millis+0x2>
    1cf4:	b0 91 0d 38 	lds	r27, 0x380D	; 0x80380d <timer_millis+0x3>
    1cf8:	01 96       	adiw	r24, 0x01	; 1
    1cfa:	a1 1d       	adc	r26, r1
    1cfc:	b1 1d       	adc	r27, r1
    1cfe:	80 93 0a 38 	sts	0x380A, r24	; 0x80380a <timer_millis>
    1d02:	90 93 0b 38 	sts	0x380B, r25	; 0x80380b <timer_millis+0x1>
    1d06:	a0 93 0c 38 	sts	0x380C, r26	; 0x80380c <timer_millis+0x2>
    1d0a:	b0 93 0d 38 	sts	0x380D, r27	; 0x80380d <timer_millis+0x3>
    1d0e:	81 e0       	ldi	r24, 0x01	; 1
    1d10:	80 93 96 0a 	sts	0x0A96, r24	; 0x800a96 <vtable for Adafruit_BMP280_Temp+0x7f56d0>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:177
  #elif defined(MILLIS_USE_TIMERD0)
    TCD0.INTFLAGS = TCD_OVF_bm;
  #elif defined(MILLIS_USE_TIMERRTC)
    RTC.INTFLAGS = RTC_OVF_bm;
  #else // timerb
    _timer->INTFLAGS = TCB_CAPT_bm;
    1d14:	bf 91       	pop	r27
    1d16:	af 91       	pop	r26
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:179
  #endif
}
    1d18:	9f 91       	pop	r25
    1d1a:	8f 91       	pop	r24
    1d1c:	0f 90       	pop	r0
    1d1e:	0f be       	out	0x3f, r0	; 63
    1d20:	0f 90       	pop	r0
    1d22:	1f 90       	pop	r1
    1d24:	18 95       	reti

00001d26 <__vector_14>:
__vector_14():
    1d26:	1f 92       	push	r1
    1d28:	0f 92       	push	r0
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:776


/**
 *@brief      TWI0 Slave Interrupt vector
 */
ISR(TWI0_TWIS_vect) {
    1d2a:	0f b6       	in	r0, 0x3f	; 63
    1d2c:	0f 92       	push	r0
    1d2e:	11 24       	eor	r1, r1
    1d30:	2f 93       	push	r18
    1d32:	3f 93       	push	r19
    1d34:	4f 93       	push	r20
    1d36:	5f 93       	push	r21
    1d38:	6f 93       	push	r22
    1d3a:	7f 93       	push	r23
    1d3c:	8f 93       	push	r24
    1d3e:	9f 93       	push	r25
    1d40:	af 93       	push	r26
    1d42:	bf 93       	push	r27
    1d44:	ef 93       	push	r30
    1d46:	ff 93       	push	r31
TWI_HandleSlaveIRQ():
    1d48:	e0 91 bb 38 	lds	r30, 0x38BB	; 0x8038bb <Wire+0xc>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:511
      uint8_t* txHead   = &(_data->_bytesToWrite);
      uint8_t* rxHead   = &(_data->_bytesToRead);
    #endif
  #endif

  uint8_t clientStatus = _data->_module->SSTATUS;
    1d4c:	f0 91 bc 38 	lds	r31, 0x38BC	; 0x8038bc <Wire+0xd>
    1d50:	83 85       	ldd	r24, Z+11	; 0x0b
    1d52:	98 2f       	mov	r25, r24
    1d54:	9c 70       	andi	r25, 0x0C	; 12
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:513

  if (clientStatus & (TWI_BUSERR_bm | TWI_COLL_bm)) {   // if Bus error/Collision was detected
    1d56:	b1 f0       	breq	.+44     	; 0x1d84 <__vector_14+0x5e>
    1d58:	85 85       	ldd	r24, Z+13	; 0x0d
    1d5a:	10 92 c0 38 	sts	0x38C0, r1	; 0x8038c0 <Wire+0x11>
SlaveIRQ_DataReadNack():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:515
    _data->_module->SDATA;                              // Read data to remove Status flags
    (*rxHead) = 0;                                      // Abort
    1d5e:	10 92 bf 38 	sts	0x38BF, r1	; 0x8038bf <Wire+0x10>
__vector_14():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:652
  #endif


  _data->_bools._ackMatters = false;                // stop checking for NACK
  _data->_module->SCTRLB = TWI_SCMD_COMPTRANS_gc;   // "Wait for any Start (S/Sr) condition"
  (*txHead) = 0;                                    // Abort further data writes
    1d62:	ff 91       	pop	r31
    1d64:	ef 91       	pop	r30
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:778
  TwoWire::onSlaveIRQ(&TWI0);
}
    1d66:	bf 91       	pop	r27
    1d68:	af 91       	pop	r26
    1d6a:	9f 91       	pop	r25
    1d6c:	8f 91       	pop	r24
    1d6e:	7f 91       	pop	r23
    1d70:	6f 91       	pop	r22
    1d72:	5f 91       	pop	r21
    1d74:	4f 91       	pop	r20
    1d76:	3f 91       	pop	r19
    1d78:	2f 91       	pop	r18
    1d7a:	0f 90       	pop	r0
    1d7c:	0f be       	out	0x3f, r0	; 63
    1d7e:	0f 90       	pop	r0
    1d80:	1f 90       	pop	r1
    1d82:	18 95       	reti
TWI_HandleSlaveIRQ():
    1d84:	86 ff       	sbrs	r24, 6
    1d86:	2b c0       	rjmp	.+86     	; 0x1dde <__vector_14+0xb8>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:522
  } else {                                              // No Bus error/Collision was detected
    #if defined(TWI_MANDS)
      _data->_bools._toggleStreamFn = 0x01;             // reroute stream functions to slave elements
    #endif

    if (clientStatus & TWI_APIF_bm) {  // Address/Stop Bit set
    1d88:	80 ff       	sbrs	r24, 0
    1d8a:	20 c0       	rjmp	.+64     	; 0x1dcc <__vector_14+0xa6>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:523
      if (clientStatus & TWI_AP_bm) {    // Address bit set
    1d8c:	81 ff       	sbrs	r24, 1
    1d8e:	15 c0       	rjmp	.+42     	; 0x1dba <__vector_14+0x94>
SlaveIRQ_AddrRead():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:524
        if (clientStatus & TWI_DIR_bm) {   // Master is reading
    1d90:	85 85       	ldd	r24, Z+13	; 0x0d
    1d92:	80 93 be 38 	sts	0x38BE, r24	; 0x8038be <Wire+0xf>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:581
      uint8_t* txHead   = &(_data->_bytesToWrite);
      uint8_t* txTail   = &(_data->_bytesWritten);
    #endif
  #endif

  (*address) = _data->_module->SDATA;       // saving address to expose to the user sketch
    1d96:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <NotifyUser_onReceive.constprop.5>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:584

                                            // There is no way to identify a REPSTART, so when a Master Read occurs after a Master write
  NotifyUser_onReceive(_data);              // Notify user program "onReceive" if necessary
    1d9a:	10 92 bf 38 	sts	0x38BF, r1	; 0x8038bf <Wire+0x10>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:586

  (*txHead) = 0;                            // reset buffer positions so the Slave can start writing at zero.
    1d9e:	10 92 c2 38 	sts	0x38C2, r1	; 0x8038c2 <Wire+0x13>
NotifyUser_onRequest():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:587
  (*txTail) = 0;
    1da2:	e0 91 c3 38 	lds	r30, 0x38C3	; 0x8038c3 <Wire+0x14>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:730
 *
 *
 *@return     void
 */
void NotifyUser_onRequest(struct twiData *_data) {
  if (_data->user_onRequest != NULL) {
    1da6:	f0 91 c4 38 	lds	r31, 0x38C4	; 0x8038c4 <Wire+0x15>
    1daa:	30 97       	sbiw	r30, 0x00	; 0
    1dac:	09 f0       	breq	.+2      	; 0x1db0 <__vector_14+0x8a>
    1dae:	09 95       	icall
SlaveIRQ_DataWrite():
    1db0:	e0 91 bb 38 	lds	r30, 0x38BB	; 0x8038bb <Wire+0xc>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:706
  uint8_t payload = _data->_module->SDATA;

  if ((*rxHead) < BUFFER_LENGTH) {                // if buffer is not full
    rxBuffer[(*rxHead)] = payload;                  // Load data into the buffer
    (*rxHead)++;                                    // Advance Head
    _data->_module->SCTRLB = TWI_SCMD_RESPONSE_gc;  // "Execute Acknowledge Action succeeded by reception of next byte"
    1db4:	f0 91 bc 38 	lds	r31, 0x38BC	; 0x8038bc <Wire+0xd>
    1db8:	07 c0       	rjmp	.+14     	; 0x1dc8 <__vector_14+0xa2>
SlaveIRQ_AddrWrite():
    1dba:	85 85       	ldd	r24, Z+13	; 0x0d
    1dbc:	80 93 be 38 	sts	0x38BE, r24	; 0x8038be <Wire+0xf>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:611
      uint8_t* rxTail   = &(_data->_bytesRead);
    #endif
  #endif


  (*address) = _data->_module->SDATA;
    1dc0:	10 92 c0 38 	sts	0x38C0, r1	; 0x8038c0 <Wire+0x11>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:612
  (*rxHead) = 0;                                    // reset buffer positions so the Master can start writing at zero.
    1dc4:	10 92 c1 38 	sts	0x38C1, r1	; 0x8038c1 <Wire+0x12>
SlaveIRQ_DataWrite():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:613
  (*rxTail) = 0;
    1dc8:	83 e0       	ldi	r24, 0x03	; 3
    1dca:	32 c0       	rjmp	.+100    	; 0x1e30 <__vector_14+0x10a>
SlaveIRQ_Stop():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:706
  uint8_t payload = _data->_module->SDATA;

  if ((*rxHead) < BUFFER_LENGTH) {                // if buffer is not full
    rxBuffer[(*rxHead)] = payload;                  // Load data into the buffer
    (*rxHead)++;                                    // Advance Head
    _data->_module->SCTRLB = TWI_SCMD_RESPONSE_gc;  // "Execute Acknowledge Action succeeded by reception of next byte"
    1dcc:	80 e4       	ldi	r24, 0x40	; 64
    1dce:	83 87       	std	Z+11, r24	; 0x0b
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:632
      uint8_t* rxTail   = &(_data->_bytesRead);
    #endif
  #endif


  _data->_module->SSTATUS = TWI_APIF_bm;      // Clear Flag, no further action needed
    1dd0:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <NotifyUser_onReceive.constprop.5>
SlaveIRQ_DataWrite():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:633
  NotifyUser_onReceive(_data);                // Notify user program "onReceive" if necessary
    1dd4:	10 92 c0 38 	sts	0x38C0, r1	; 0x8038c0 <Wire+0x11>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:709
    rxBuffer[(*rxHead)] = payload;                  // Load data into the buffer
    (*rxHead)++;                                    // Advance Head
    _data->_module->SCTRLB = TWI_SCMD_RESPONSE_gc;  // "Execute Acknowledge Action succeeded by reception of next byte"
  } else {                                          // else buffer is full
    _data->_module->SCTRLB = TWI_ACKACT_bm | TWI_SCMD_COMPTRANS_gc;  // "Execute ACK Action succeeded by waiting for any Start (S/Sr) condition"
    (*rxHead) = 0;                                           // Dismiss all received Data since data integrity can't be guaranteed
    1dd8:	10 92 c1 38 	sts	0x38C1, r1	; 0x8038c1 <Wire+0x12>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:710
    (*rxTail) = 0;  // Make sure available will return 0
    1ddc:	c2 cf       	rjmp	.-124    	; 0x1d62 <__vector_14+0x3c>
TWI_HandleSlaveIRQ():
    1dde:	87 ff       	sbrs	r24, 7
    1de0:	c0 cf       	rjmp	.-128    	; 0x1d62 <__vector_14+0x3c>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:532
          SlaveIRQ_AddrWrite(_data);
        }
      } else {                          // Stop bit set
        SlaveIRQ_Stop(_data);
      }
    } else if (clientStatus & TWI_DIF_bm) {  // Data bit set
    1de2:	81 ff       	sbrs	r24, 1
    1de4:	27 c0       	rjmp	.+78     	; 0x1e34 <__vector_14+0x10e>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:533
      if (clientStatus & TWI_DIR_bm) {         // Master is reading
    1de6:	84 ff       	sbrs	r24, 4
    1de8:	0a c0       	rjmp	.+20     	; 0x1dfe <__vector_14+0xd8>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:534
        if ((clientStatus & TWI_RXACK_bm) && _data->_bools._ackMatters) {  // RXACK bit is set and it matters
    1dea:	80 91 bd 38 	lds	r24, 0x38BD	; 0x8038bd <Wire+0xe>
    1dee:	87 ff       	sbrs	r24, 7
    1df0:	06 c0       	rjmp	.+12     	; 0x1dfe <__vector_14+0xd8>
SlaveIRQ_DataReadNack():
    1df2:	8f 77       	andi	r24, 0x7F	; 127
    1df4:	80 93 bd 38 	sts	0x38BD, r24	; 0x8038bd <Wire+0xe>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:650
      uint8_t* txHead   = &(_data->_bytesToWrite);
    #endif
  #endif


  _data->_bools._ackMatters = false;                // stop checking for NACK
    1df8:	82 e0       	ldi	r24, 0x02	; 2
    1dfa:	82 87       	std	Z+10, r24	; 0x0a
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:651
  _data->_module->SCTRLB = TWI_SCMD_COMPTRANS_gc;   // "Wait for any Start (S/Sr) condition"
    1dfc:	b0 cf       	rjmp	.-160    	; 0x1d5e <__vector_14+0x38>
SlaveIRQ_DataReadAck():
    1dfe:	80 91 bd 38 	lds	r24, 0x38BD	; 0x8038bd <Wire+0xe>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:672
      uint8_t* txTail   = &(_data->_bytesWritten);
      uint8_t* txBuffer =   _data->_txBuffer;
    #endif
  #endif

  _data->_bools._ackMatters = true;             // start checking for NACK
    1e02:	80 68       	ori	r24, 0x80	; 128
    1e04:	80 93 bd 38 	sts	0x38BD, r24	; 0x8038bd <Wire+0xe>
    1e08:	a0 91 c2 38 	lds	r26, 0x38C2	; 0x8038c2 <Wire+0x13>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:673
  if ((*txTail) < (*txHead)) {                  // Data is available
    1e0c:	80 91 bf 38 	lds	r24, 0x38BF	; 0x8038bf <Wire+0x10>
    1e10:	a8 17       	cp	r26, r24
    1e12:	68 f4       	brcc	.+26     	; 0x1e2e <__vector_14+0x108>
    1e14:	b0 e0       	ldi	r27, 0x00	; 0
    1e16:	a9 53       	subi	r26, 0x39	; 57
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:674
    _data->_module->SDATA = txBuffer[(*txTail)];    // Writing to the register to send data
    1e18:	b7 4c       	sbci	r27, 0xC7	; 199
    1e1a:	8c 91       	ld	r24, X
    1e1c:	85 87       	std	Z+13, r24	; 0x0d
    1e1e:	83 e0       	ldi	r24, 0x03	; 3
    1e20:	82 87       	std	Z+10, r24	; 0x0a
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:675
    _data->_module->SCTRLB = TWI_SCMD_RESPONSE_gc;  // "Execute a byte read operation followed by Acknowledge Action"
    1e22:	80 91 c2 38 	lds	r24, 0x38C2	; 0x8038c2 <Wire+0x13>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:676
    (*txTail)++;                                    // Increment counter for sent bytes
    1e26:	8f 5f       	subi	r24, 0xFF	; 255
    1e28:	80 93 c2 38 	sts	0x38C2, r24	; 0x8038c2 <Wire+0x13>
    1e2c:	9a cf       	rjmp	.-204    	; 0x1d62 <__vector_14+0x3c>
    1e2e:	82 e0       	ldi	r24, 0x02	; 2
SlaveIRQ_DataWrite():
    1e30:	82 87       	std	Z+10, r24	; 0x0a
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:679

  } else {                                            // No more data available
    _data->_module->SCTRLB = TWI_SCMD_COMPTRANS_gc;   // "Wait for any Start (S/Sr) condition"
    1e32:	97 cf       	rjmp	.-210    	; 0x1d62 <__vector_14+0x3c>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:706
  uint8_t payload = _data->_module->SDATA;

  if ((*rxHead) < BUFFER_LENGTH) {                // if buffer is not full
    rxBuffer[(*rxHead)] = payload;                  // Load data into the buffer
    (*rxHead)++;                                    // Advance Head
    _data->_module->SCTRLB = TWI_SCMD_RESPONSE_gc;  // "Execute Acknowledge Action succeeded by reception of next byte"
    1e34:	95 85       	ldd	r25, Z+13	; 0x0d
    1e36:	80 91 c0 38 	lds	r24, 0x38C0	; 0x8038c0 <Wire+0x11>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:703
  #endif


  uint8_t payload = _data->_module->SDATA;

  if ((*rxHead) < BUFFER_LENGTH) {                // if buffer is not full
    1e3a:	80 32       	cpi	r24, 0x20	; 32
    1e3c:	58 f4       	brcc	.+22     	; 0x1e54 <__vector_14+0x12e>
    1e3e:	e8 2f       	mov	r30, r24
    1e40:	f0 e0       	ldi	r31, 0x00	; 0
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:704
    rxBuffer[(*rxHead)] = payload;                  // Load data into the buffer
    1e42:	e9 51       	subi	r30, 0x19	; 25
    1e44:	f7 4c       	sbci	r31, 0xC7	; 199
    1e46:	90 83       	st	Z, r25
    1e48:	80 91 c0 38 	lds	r24, 0x38C0	; 0x8038c0 <Wire+0x11>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:705
    (*rxHead)++;                                    // Advance Head
    1e4c:	8f 5f       	subi	r24, 0xFF	; 255
    1e4e:	80 93 c0 38 	sts	0x38C0, r24	; 0x8038c0 <Wire+0x11>
    1e52:	ae cf       	rjmp	.-164    	; 0x1db0 <__vector_14+0x8a>
    1e54:	86 e0       	ldi	r24, 0x06	; 6
    1e56:	82 87       	std	Z+10, r24	; 0x0a
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:708
    _data->_module->SCTRLB = TWI_SCMD_RESPONSE_gc;  // "Execute Acknowledge Action succeeded by reception of next byte"
  } else {                                          // else buffer is full
    _data->_module->SCTRLB = TWI_ACKACT_bm | TWI_SCMD_COMPTRANS_gc;  // "Execute ACK Action succeeded by waiting for any Start (S/Sr) condition"
    1e58:	bd cf       	rjmp	.-134    	; 0x1dd4 <__vector_14+0xae>

00001e5a <global constructors keyed to 65535_0_Altimetr_SPI.cpp.o.3720>:
_GLOBAL__I_65535_0_Altimetr_SPI.cpp.o.3720():
    1e5a:	ff 92       	push	r15
    1e5c:	0f 93       	push	r16
    1e5e:	1f 93       	push	r17
    1e60:	cf 93       	push	r28
    1e62:	df 93       	push	r29
    1e64:	10 92 1c 38 	sts	0x381C, r1	; 0x80381c <Serial+0x2>
    1e68:	10 92 1d 38 	sts	0x381D, r1	; 0x80381d <Serial+0x3>
    1e6c:	88 ee       	ldi	r24, 0xE8	; 232
    1e6e:	93 e0       	ldi	r25, 0x03	; 3
    1e70:	a0 e0       	ldi	r26, 0x00	; 0
    1e72:	b0 e0       	ldi	r27, 0x00	; 0
    1e74:	80 93 1e 38 	sts	0x381E, r24	; 0x80381e <Serial+0x4>
    1e78:	90 93 1f 38 	sts	0x381F, r25	; 0x80381f <Serial+0x5>
    1e7c:	a0 93 20 38 	sts	0x3820, r26	; 0x803820 <Serial+0x6>
    1e80:	b0 93 21 38 	sts	0x3821, r27	; 0x803821 <Serial+0x7>
    1e84:	48 e7       	ldi	r20, 0x78	; 120
    1e86:	53 eb       	ldi	r21, 0xB3	; 179
    1e88:	40 93 1a 38 	sts	0x381A, r20	; 0x80381a <Serial>
    1e8c:	50 93 1b 38 	sts	0x381B, r21	; 0x80381b <Serial+0x1>
    1e90:	40 e0       	ldi	r20, 0x00	; 0
    1e92:	58 e0       	ldi	r21, 0x08	; 8
    1e94:	40 93 26 38 	sts	0x3826, r20	; 0x803826 <Serial+0xc>
    1e98:	50 93 27 38 	sts	0x3827, r21	; 0x803827 <Serial+0xd>
    1e9c:	10 92 28 38 	sts	0x3828, r1	; 0x803828 <Serial+0xe>
    1ea0:	10 92 29 38 	sts	0x3829, r1	; 0x803829 <Serial+0xf>
    1ea4:	10 92 b1 38 	sts	0x38B1, r1	; 0x8038b1 <Wire+0x2>
    1ea8:	10 92 b2 38 	sts	0x38B2, r1	; 0x8038b2 <Wire+0x3>
    1eac:	80 93 b3 38 	sts	0x38B3, r24	; 0x8038b3 <Wire+0x4>
    1eb0:	90 93 b4 38 	sts	0x38B4, r25	; 0x8038b4 <Wire+0x5>
    1eb4:	a0 93 b5 38 	sts	0x38B5, r26	; 0x8038b5 <Wire+0x6>
    1eb8:	b0 93 b6 38 	sts	0x38B6, r27	; 0x8038b6 <Wire+0x7>
    1ebc:	82 e9       	ldi	r24, 0x92	; 146
    1ebe:	93 eb       	ldi	r25, 0xB3	; 179
    1ec0:	80 93 af 38 	sts	0x38AF, r24	; 0x8038af <Wire>
    1ec4:	90 93 b0 38 	sts	0x38B0, r25	; 0x8038b0 <Wire+0x1>
    1ec8:	80 ea       	ldi	r24, 0xA0	; 160
    1eca:	98 e0       	ldi	r25, 0x08	; 8
    1ecc:	80 93 bb 38 	sts	0x38BB, r24	; 0x8038bb <Wire+0xc>
    1ed0:	90 93 bc 38 	sts	0x38BC, r25	; 0x8038bc <Wire+0xd>
    1ed4:	40 e8       	ldi	r20, 0x80	; 128
    1ed6:	56 e9       	ldi	r21, 0x96	; 150
    1ed8:	68 e9       	ldi	r22, 0x98	; 152
    1eda:	70 e0       	ldi	r23, 0x00	; 0
    1edc:	80 e0       	ldi	r24, 0x00	; 0
    1ede:	8f 5f       	subi	r24, 0xFF	; 255
    1ee0:	86 30       	cpi	r24, 0x06	; 6
    1ee2:	11 f4       	brne	.+4      	; 0x1ee8 <global constructors keyed to 65535_0_Altimetr_SPI.cpp.o.3720+0x8e>
    1ee4:	87 e0       	ldi	r24, 0x07	; 7
    1ee6:	0b c0       	rjmp	.+22     	; 0x1efe <global constructors keyed to 65535_0_Altimetr_SPI.cpp.o.3720+0xa4>
    1ee8:	76 95       	lsr	r23
    1eea:	67 95       	ror	r22
    1eec:	57 95       	ror	r21
    1eee:	47 95       	ror	r20
    1ef0:	41 30       	cpi	r20, 0x01	; 1
    1ef2:	99 e0       	ldi	r25, 0x09	; 9
    1ef4:	59 07       	cpc	r21, r25
    1ef6:	9d e3       	ldi	r25, 0x3D	; 61
    1ef8:	69 07       	cpc	r22, r25
    1efa:	71 05       	cpc	r23, r1
    1efc:	80 f7       	brcc	.-32     	; 0x1ede <global constructors keyed to 65535_0_Altimetr_SPI.cpp.o.3720+0x84>
    1efe:	34 e0       	ldi	r19, 0x04	; 4
    1f00:	f3 2e       	mov	r15, r19
    1f02:	f0 92 08 39 	sts	0x3908, r15	; 0x803908 <DEFAULT_SPI_SETTINGS+0x1>
    1f06:	98 2f       	mov	r25, r24
    1f08:	90 95       	com	r25
    1f0a:	29 2f       	mov	r18, r25
    1f0c:	21 70       	andi	r18, 0x01	; 1
    1f0e:	30 e0       	ldi	r19, 0x00	; 0
    1f10:	44 e0       	ldi	r20, 0x04	; 4
    1f12:	22 0f       	add	r18, r18
    1f14:	33 1f       	adc	r19, r19
    1f16:	4a 95       	dec	r20
    1f18:	e1 f7       	brne	.-8      	; 0x1f12 <global constructors keyed to 65535_0_Altimetr_SPI.cpp.o.3720+0xb8>
    1f1a:	81 62       	ori	r24, 0x21	; 33
    1f1c:	82 2b       	or	r24, r18
    1f1e:	80 93 07 39 	sts	0x3907, r24	; 0x803907 <DEFAULT_SPI_SETTINGS>
    1f22:	10 92 0b 39 	sts	0x390B, r1	; 0x80390b <bmp+0x2>
    1f26:	10 92 0c 39 	sts	0x390C, r1	; 0x80390c <bmp+0x3>
    1f2a:	8c e1       	ldi	r24, 0x1C	; 28
    1f2c:	90 e0       	ldi	r25, 0x00	; 0
    1f2e:	0e 94 6a 18 	call	0x30d4	; 0x30d4 <malloc>
    1f32:	ec 01       	movw	r28, r24
    1f34:	87 e0       	ldi	r24, 0x07	; 7
    1f36:	8b 87       	std	Y+11, r24	; 0x0b
    1f38:	8a e0       	ldi	r24, 0x0A	; 10
    1f3a:	8c 87       	std	Y+12, r24	; 0x0c
    1f3c:	89 e0       	ldi	r24, 0x09	; 9
    1f3e:	8e 87       	std	Y+14, r24	; 0x0e
    1f40:	88 e0       	ldi	r24, 0x08	; 8
    1f42:	8d 87       	std	Y+13, r24	; 0x0d
    1f44:	24 e2       	ldi	r18, 0x24	; 36
    1f46:	34 e0       	ldi	r19, 0x04	; 4
    1f48:	2d 8b       	std	Y+21, r18	; 0x15
    1f4a:	3e 8b       	std	Y+22, r19	; 0x16
    1f4c:	91 e0       	ldi	r25, 0x01	; 1
    1f4e:	9a 8f       	std	Y+26, r25	; 0x1a
    1f50:	24 e0       	ldi	r18, 0x04	; 4
    1f52:	34 e0       	ldi	r19, 0x04	; 4
    1f54:	2f 87       	std	Y+15, r18	; 0x0f
    1f56:	38 8b       	std	Y+16, r19	; 0x10
    1f58:	92 e0       	ldi	r25, 0x02	; 2
    1f5a:	9f 8b       	std	Y+23, r25	; 0x17
    1f5c:	48 e0       	ldi	r20, 0x08	; 8
    1f5e:	54 e0       	ldi	r21, 0x04	; 4
    1f60:	4b 8b       	std	Y+19, r20	; 0x13
    1f62:	5c 8b       	std	Y+20, r21	; 0x14
    1f64:	f8 8e       	std	Y+24, r15	; 0x18
    1f66:	29 8b       	std	Y+17, r18	; 0x11
    1f68:	3a 8b       	std	Y+18, r19	; 0x12
    1f6a:	89 8f       	std	Y+25, r24	; 0x19
    1f6c:	80 e4       	ldi	r24, 0x40	; 64
    1f6e:	92 e4       	ldi	r25, 0x42	; 66
    1f70:	af e0       	ldi	r26, 0x0F	; 15
    1f72:	b0 e0       	ldi	r27, 0x00	; 0
    1f74:	8c 83       	std	Y+4, r24	; 0x04
    1f76:	9d 83       	std	Y+5, r25	; 0x05
    1f78:	ae 83       	std	Y+6, r26	; 0x06
    1f7a:	bf 83       	std	Y+7, r27	; 0x07
    1f7c:	81 e0       	ldi	r24, 0x01	; 1
    1f7e:	90 e0       	ldi	r25, 0x00	; 0
    1f80:	88 87       	std	Y+8, r24	; 0x08
    1f82:	99 87       	std	Y+9, r25	; 0x09
    1f84:	1a 86       	std	Y+10, r1	; 0x0a
    1f86:	1b 8e       	std	Y+27, r1	; 0x1b
    1f88:	82 e0       	ldi	r24, 0x02	; 2
    1f8a:	90 e0       	ldi	r25, 0x00	; 0
    1f8c:	0e 94 6a 18 	call	0x30d4	; 0x30d4 <malloc>
    1f90:	fc 01       	movw	r30, r24
    1f92:	40 e8       	ldi	r20, 0x80	; 128
    1f94:	56 e9       	ldi	r21, 0x96	; 150
    1f96:	68 e9       	ldi	r22, 0x98	; 152
    1f98:	70 e0       	ldi	r23, 0x00	; 0
    1f9a:	90 e0       	ldi	r25, 0x00	; 0
    1f9c:	9f 5f       	subi	r25, 0xFF	; 255
    1f9e:	96 30       	cpi	r25, 0x06	; 6
    1fa0:	11 f4       	brne	.+4      	; 0x1fa6 <global constructors keyed to 65535_0_Altimetr_SPI.cpp.o.3720+0x14c>
    1fa2:	97 e0       	ldi	r25, 0x07	; 7
    1fa4:	0b c0       	rjmp	.+22     	; 0x1fbc <global constructors keyed to 65535_0_Altimetr_SPI.cpp.o.3720+0x162>
    1fa6:	76 95       	lsr	r23
    1fa8:	67 95       	ror	r22
    1faa:	57 95       	ror	r21
    1fac:	47 95       	ror	r20
    1fae:	41 34       	cpi	r20, 0x41	; 65
    1fb0:	82 e4       	ldi	r24, 0x42	; 66
    1fb2:	58 07       	cpc	r21, r24
    1fb4:	8f e0       	ldi	r24, 0x0F	; 15
    1fb6:	68 07       	cpc	r22, r24
    1fb8:	71 05       	cpc	r23, r1
    1fba:	80 f7       	brcc	.-32     	; 0x1f9c <global constructors keyed to 65535_0_Altimetr_SPI.cpp.o.3720+0x142>
    1fbc:	84 e0       	ldi	r24, 0x04	; 4
    1fbe:	81 83       	std	Z+1, r24	; 0x01
    1fc0:	89 2f       	mov	r24, r25
    1fc2:	80 95       	com	r24
    1fc4:	08 2f       	mov	r16, r24
    1fc6:	01 70       	andi	r16, 0x01	; 1
    1fc8:	10 e0       	ldi	r17, 0x00	; 0
    1fca:	84 e0       	ldi	r24, 0x04	; 4
    1fcc:	00 0f       	add	r16, r16
    1fce:	11 1f       	adc	r17, r17
    1fd0:	8a 95       	dec	r24
    1fd2:	e1 f7       	brne	.-8      	; 0x1fcc <global constructors keyed to 65535_0_Altimetr_SPI.cpp.o.3720+0x172>
    1fd4:	91 62       	ori	r25, 0x21	; 33
    1fd6:	90 2b       	or	r25, r16
    1fd8:	90 83       	st	Z, r25
    1fda:	ea 83       	std	Y+2, r30	; 0x02
    1fdc:	fb 83       	std	Y+3, r31	; 0x03
    1fde:	18 82       	st	Y, r1
    1fe0:	19 82       	std	Y+1, r1	; 0x01
    1fe2:	09 e0       	ldi	r16, 0x09	; 9
    1fe4:	19 e3       	ldi	r17, 0x39	; 57
    1fe6:	c0 93 0d 39 	sts	0x390D, r28	; 0x80390d <bmp+0x4>
    1fea:	d0 93 0e 39 	sts	0x390E, r29	; 0x80390e <bmp+0x5>
    1fee:	87 e0       	ldi	r24, 0x07	; 7
    1ff0:	90 e0       	ldi	r25, 0x00	; 0
    1ff2:	0e 94 6a 18 	call	0x30d4	; 0x30d4 <malloc>
    1ff6:	fc 01       	movw	r30, r24
    1ff8:	8a ec       	ldi	r24, 0xCA	; 202
    1ffa:	93 eb       	ldi	r25, 0xB3	; 179
    1ffc:	80 83       	st	Z, r24
    1ffe:	91 83       	std	Z+1, r25	; 0x01
    2000:	88 e1       	ldi	r24, 0x18	; 24
    2002:	91 e0       	ldi	r25, 0x01	; 1
    2004:	83 83       	std	Z+3, r24	; 0x03
    2006:	94 83       	std	Z+4, r25	; 0x04
    2008:	05 83       	std	Z+5, r16	; 0x05
    200a:	16 83       	std	Z+6, r17	; 0x06
    200c:	e0 93 0f 39 	sts	0x390F, r30	; 0x80390f <bmp+0x6>
    2010:	f0 93 10 39 	sts	0x3910, r31	; 0x803910 <bmp+0x7>
    2014:	87 e0       	ldi	r24, 0x07	; 7
    2016:	90 e0       	ldi	r25, 0x00	; 0
    2018:	0e 94 6a 18 	call	0x30d4	; 0x30d4 <malloc>
    201c:	fc 01       	movw	r30, r24
    201e:	8c eb       	ldi	r24, 0xBC	; 188
    2020:	93 eb       	ldi	r25, 0xB3	; 179
    2022:	80 83       	st	Z, r24
    2024:	91 83       	std	Z+1, r25	; 0x01
    2026:	13 82       	std	Z+3, r1	; 0x03
    2028:	14 82       	std	Z+4, r1	; 0x04
    202a:	05 83       	std	Z+5, r16	; 0x05
    202c:	16 83       	std	Z+6, r17	; 0x06
    202e:	e0 93 11 39 	sts	0x3911, r30	; 0x803911 <bmp+0x8>
    2032:	f0 93 12 39 	sts	0x3912, r31	; 0x803912 <bmp+0x9>
    2036:	df 91       	pop	r29
    2038:	cf 91       	pop	r28
    203a:	1f 91       	pop	r17
    203c:	0f 91       	pop	r16
    203e:	ff 90       	pop	r15
    2040:	08 95       	ret

00002042 <main>:
main():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/main.cpp:49
 * called first in non-optiboot configurations (neither is needed on Optibooot configurations() *
 * an extra bit of initialization code in .init3 to fix the vectors and still happen if user    *
 * overrides main. In the past there was a USB-related function here, that is removed, as work  *
 * will be needed in any event at the core level if VUSB-based "stuff" arrives, but really I'm  *
 * just waiting for the DU-series now                                                           */
int main() {
    2042:	cf 93       	push	r28
    2044:	df 93       	push	r29
    2046:	1f 92       	push	r1
    2048:	cd b7       	in	r28, 0x3d	; 61
    204a:	de b7       	in	r29, 0x3e	; 62
init_clock():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:1275
    #if (defined(CLOCK_TUNE_INTERNAL))
      tune_internal(); // Will be inlined as only called once. Just too long and ugly to put two implementations in middle of this.
    #else
      #if (F_CPU == 20000000)
        /* No division on clock */
        _PROTECTED_WRITE(CLKCTRL_MCLKCTRLB, 0x00);
    204c:	88 ed       	ldi	r24, 0xD8	; 216
    204e:	90 e0       	ldi	r25, 0x00	; 0
    2050:	84 bf       	out	0x34, r24	; 52
    2052:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <vtable for Adafruit_BMP280_Temp+0x7f4c9b>
init_ADC0():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:1407
    #elif F_CPU  >= 30000000            // 32 MHz /12 = 2.67 MHz
      ADC0.CTRLB  = ADC_PRESC_DIV12_gc; // 30 MHz /12 = 2.50 MHz
    #elif F_CPU  >= 24000000            // 25 MHz /10 = 2.50 MHz
      ADC0.CTRLB  = ADC_PRESC_DIV10_gc; // 24 MHz /10 = 2.40 MHz
    #elif F_CPU  >= 20000000
      ADC0.CTRLB  = ADC_PRESC_DIV8_gc;  // 20 MHz / 8 = 2.50 MHz
    2056:	83 e0       	ldi	r24, 0x03	; 3
    2058:	80 93 01 06 	sts	0x0601, r24	; 0x800601 <vtable for Adafruit_BMP280_Temp+0x7f523b>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:1417
    #elif F_CPU  >=  6000000            // 10 MHz / 4 = 2.50 MHz
      ADC0.CTRLB  = ADC_PRESC_DIV4_gc;  //  8 MHz / 4 = 2.00 MHz
    #else                               //  5 MHz / 2 = 2.50 MHz
      ADC0.CTRLB  = ADC_PRESC_DIV2_gc;  //  4 MHz / 2 = 2.00 MHz
    #endif                              //  1 MHz / 2 =  500 kHz
    ADC0.CTRLE = 15; // 15.5 without PGA, 16 with PGA, corresponding to 7.75 or 8 us.
    205c:	9f e0       	ldi	r25, 0x0F	; 15
    205e:	90 93 08 06 	sts	0x0608, r25	; 0x800608 <vtable for Adafruit_BMP280_Temp+0x7f5242>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:1418
    ADC0.CTRLA = ADC_ENABLE_bm | ADC_LOWLAT_bm;
    2062:	91 e2       	ldi	r25, 0x21	; 33
    2064:	90 93 00 06 	sts	0x0600, r25	; 0x800600 <vtable for Adafruit_BMP280_Temp+0x7f523a>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:1423
    /* Default low latency mode on
     * Users can turn it off if they care about power consumption while ADC is on
     * and chip is awake, since these parts don't have the perverse ADC-left-on
     * behavior of classic AVRs. */
    ADC0.CTRLC = TIMEBASE_1US; // defined in Arduino.h.
    2068:	90 ea       	ldi	r25, 0xA0	; 160
    206a:	90 93 02 06 	sts	0x0602, r25	; 0x800602 <vtable for Adafruit_BMP280_Temp+0x7f523c>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:1424
    ADC0.PGACTRL = ADC_PGABIASSEL_3_4X_gc | ADC_ADCPGASAMPDUR_15CLK_gc;
    206e:	9a e0       	ldi	r25, 0x0A	; 10
    2070:	90 93 0b 06 	sts	0x060B, r25	; 0x80060b <vtable for Adafruit_BMP280_Temp+0x7f5245>
init_TCA0():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:1487
  #ifdef __AVR_ATtinyxy2__
    PORTMUX.CTRLC = 1; // move WO0 output to PA7 so PA3 can be used with WO3
  #endif

  /* Enable Split Mode */
  TCA0.SPLIT.CTRLD = TCA_SPLIT_SPLITM_bm;
    2074:	91 e0       	ldi	r25, 0x01	; 1
    2076:	90 93 03 0a 	sts	0x0A03, r25	; 0x800a03 <vtable for Adafruit_BMP280_Temp+0x7f563d>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:1492

  // Only 1 WGM so no need to specifically set up.

  /* Period setting, 8-bit register in SPLIT mode */
  TCA0.SPLIT.LPER    = PWM_TIMER_PERIOD;
    207a:	2e ef       	ldi	r18, 0xFE	; 254
    207c:	20 93 26 0a 	sts	0x0A26, r18	; 0x800a26 <vtable for Adafruit_BMP280_Temp+0x7f5660>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:1493
  TCA0.SPLIT.HPER    = PWM_TIMER_PERIOD;
    2080:	20 93 27 0a 	sts	0x0A27, r18	; 0x800a27 <vtable for Adafruit_BMP280_Temp+0x7f5661>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:1511
  /* Use prescale appropriate for system clock speed */

  #if (F_CPU > 25000000) //   use 256 divider when clocked over 25 MHz
    TCA0.SPLIT.CTRLA   = (TCA_SPLIT_CLKSEL_DIV256_gc) | (TCA_SPLIT_ENABLE_bm);
  #elif (F_CPU > 5000000) //  use 64 divider for everything in the middle
    TCA0.SPLIT.CTRLA   =  (TCA_SPLIT_CLKSEL_DIV64_gc) | (TCA_SPLIT_ENABLE_bm);
    2084:	2b e0       	ldi	r18, 0x0B	; 11
    2086:	20 93 00 0a 	sts	0x0A00, r18	; 0x800a00 <vtable for Adafruit_BMP280_Temp+0x7f563a>
init_millis():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:1204
        // RTC.CLKSEL=0; this is the power on value
      #endif
      RTC.INTCTRL         = 0x01; // enable overflow interrupt
      RTC.CTRLA           = (RTC_RUNSTDBY_bm|RTC_RTCEN_bm|RTC_PRESCALER_DIV32_gc);//fire it up, prescale by 32.
    #else // It's a type b timer - we have already errored out if that wasn't defined
      _timer->CCMP = TIME_TRACKING_TIMER_PERIOD;
    208a:	2f e0       	ldi	r18, 0x0F	; 15
    208c:	37 e2       	ldi	r19, 0x27	; 39
    208e:	20 93 9c 0a 	sts	0x0A9C, r18	; 0x800a9c <vtable for Adafruit_BMP280_Temp+0x7f56d6>
    2092:	30 93 9d 0a 	sts	0x0A9D, r19	; 0x800a9d <vtable for Adafruit_BMP280_Temp+0x7f56d7>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:1206
      // Enable timer interrupt, but clear the rest of register
      _timer->INTCTRL = TCB_CAPT_bm;
    2096:	90 93 95 0a 	sts	0x0A95, r25	; 0x800a95 <vtable for Adafruit_BMP280_Temp+0x7f56cf>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:1208
      // Clear timer mode (since it will have been set as PWM by init())
      _timer->CTRLB = 0;
    209a:	10 92 91 0a 	sts	0x0A91, r1	; 0x800a91 <vtable for Adafruit_BMP280_Temp+0x7f56cb>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:1210
      // CLK_PER/1 is 0b00,. CLK_PER/2 is 0b01, so bitwise OR of valid divider with enable works
      _timer->CTRLA = TIME_TRACKING_TIMER_DIVIDER|TCB_ENABLE_bm;  // Keep this last before enabling interrupts to ensure tracking as accurate as possible
    209e:	80 93 90 0a 	sts	0x0A90, r24	; 0x800a90 <vtable for Adafruit_BMP280_Temp+0x7f56ca>
init():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:1257
  #ifndef MILLIS_USE_TIMERNONE
    init_millis();
  #endif
  /*************************** ENABLE GLOBAL INTERRUPTS *************************/
  // Finally, after everything is initialized, we go ahead and enable interrupts.
  sei();
    20a2:	78 94       	sei
main():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/main.cpp:53
  onBeforeInit(); // Emnpty callback called before init but after the .init stuff. First normal code executed
  init(); // Interrupts are turned on just prior to init() returning.
  initVariant();
  if (!onAfterInit()) sei();  // enable interrupts.
    20a4:	78 94       	sei
    20a6:	10 e0       	ldi	r17, 0x00	; 0
setup():
g:\Studia\PUT Rocket LAB\altimetr\Altimetr_SPI/Altimetr_SPI.ino:61
uint64_t t = 0; // timer updated with millis()
void setup()
{
  // put your setup code here, to run once:
  for (int i = 0; i < 11; i++) // For all pins
    pinMode(i, OUTPUT);
    20a8:	61 e0       	ldi	r22, 0x01	; 1
    20aa:	81 2f       	mov	r24, r17
    20ac:	0e 94 5e 06 	call	0xcbc	; 0xcbc <pinMode>
    20b0:	1f 5f       	subi	r17, 0xFF	; 255
g:\Studia\PUT Rocket LAB\altimetr\Altimetr_SPI/Altimetr_SPI.ino:60
float initialHight;
uint64_t t = 0; // timer updated with millis()
void setup()
{
  // put your setup code here, to run once:
  for (int i = 0; i < 11; i++) // For all pins
    20b2:	1b 30       	cpi	r17, 0x0B	; 11
    20b4:	c9 f7       	brne	.-14     	; 0x20a8 <main+0x66>
g:\Studia\PUT Rocket LAB\altimetr\Altimetr_SPI/Altimetr_SPI.ino:62
    pinMode(i, OUTPUT);
  pinMode(SEND_DATA_UART_EN, INPUT_PULLUP);
    20b6:	62 e0       	ldi	r22, 0x02	; 2
    20b8:	83 e0       	ldi	r24, 0x03	; 3
    20ba:	0e 94 5e 06 	call	0xcbc	; 0xcbc <pinMode>
g:\Studia\PUT Rocket LAB\altimetr\Altimetr_SPI/Altimetr_SPI.ino:63
  Serial.begin(115200);
    20be:	40 e0       	ldi	r20, 0x00	; 0
    20c0:	52 ec       	ldi	r21, 0xC2	; 194
    20c2:	61 e0       	ldi	r22, 0x01	; 1
    20c4:	70 e0       	ldi	r23, 0x00	; 0
    20c6:	8a e1       	ldi	r24, 0x1A	; 26
    20c8:	98 e3       	ldi	r25, 0x38	; 56
    20ca:	0e 94 91 05 	call	0xb22	; 0xb22 <UartClass::begin(unsigned long)>
write():
    20ce:	89 ee       	ldi	r24, 0xE9	; 233
    20d0:	93 eb       	ldi	r25, 0xB3	; 179
    20d2:	0e 94 40 07 	call	0xe80	; 0xe80 <Print::write(char const*) [clone .part.2] [clone .constprop.51]>
    20d6:	8f ee       	ldi	r24, 0xEF	; 239
    20d8:	93 eb       	ldi	r25, 0xB3	; 179
    20da:	0e 94 40 07 	call	0xe80	; 0xe80 <Print::write(char const*) [clone .part.2] [clone .constprop.51]>
begin():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:86
 *  @param chipid
 *         The expected chip ID (used to validate connection).
 *  @return True if the init was successful, otherwise false.
 */
bool Adafruit_BMP280::begin(uint8_t addr, uint8_t chipid) {
  if (spi_dev == NULL) {
    20de:	00 91 0d 39 	lds	r16, 0x390D	; 0x80390d <bmp+0x4>
    20e2:	10 91 0e 39 	lds	r17, 0x390E	; 0x80390e <bmp+0x5>
    20e6:	01 15       	cp	r16, r1
    20e8:	11 05       	cpc	r17, r1
    20ea:	09 f0       	breq	.+2      	; 0x20ee <main+0xac>
    20ec:	40 c0       	rjmp	.+128    	; 0x216e <main+0x12c>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:88
    // I2C mode
    if (i2c_dev)
    20ee:	80 91 0b 39 	lds	r24, 0x390B	; 0x80390b <bmp+0x2>
    20f2:	90 91 0c 39 	lds	r25, 0x390C	; 0x80390c <bmp+0x3>
    20f6:	00 97       	sbiw	r24, 0x00	; 0
    20f8:	11 f0       	breq	.+4      	; 0x20fe <main+0xbc>
operator delete():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/new.cpp:63
    20fa:	0e 94 06 19 	call	0x320c	; 0x320c <free>
operator new():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/new.cpp:33

#include <stdlib.h>

// For C++11, only need the following:
void *operator new  (size_t size) {
  return malloc(size);
    20fe:	86 e0       	ldi	r24, 0x06	; 6
    2100:	90 e0       	ldi	r25, 0x00	; 0
    2102:	e8 d7       	rcall	.+4048   	; 0x30d4 <malloc>
begin():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:90
      delete i2c_dev;
    i2c_dev = new Adafruit_I2CDevice(addr, _wire);
    2104:	20 91 09 39 	lds	r18, 0x3909	; 0x803909 <bmp>
    2108:	30 91 0a 39 	lds	r19, 0x390A	; 0x80390a <bmp+0x1>
__base_ctor ():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:12
 *    @brief  Create an I2C device at a given address
 *    @param  addr The 7-bit I2C address for the device
 *    @param  theWire The I2C bus to use, defaults to &Wire
 */
Adafruit_I2CDevice::Adafruit_I2CDevice(uint8_t addr, TwoWire *theWire) {
  _addr = addr;
    210c:	46 e7       	ldi	r20, 0x76	; 118
    210e:	dc 01       	movw	r26, r24
    2110:	4c 93       	st	X, r20
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:13
  _wire = theWire;
    2112:	11 96       	adiw	r26, 0x01	; 1
    2114:	2d 93       	st	X+, r18
    2116:	3c 93       	st	X, r19
    2118:	12 97       	sbiw	r26, 0x02	; 2
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:14
  _begun = false;
    211a:	13 96       	adiw	r26, 0x03	; 3
    211c:	1c 92       	st	X, r1
    211e:	13 97       	sbiw	r26, 0x03	; 3
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:18
#ifdef ARDUINO_ARCH_SAMD
  _maxBufferSize = 250; // as defined in Wire.h's RingBuffer
#else
  _maxBufferSize = 32;
    2120:	20 e2       	ldi	r18, 0x20	; 32
    2122:	30 e0       	ldi	r19, 0x00	; 0
    2124:	14 96       	adiw	r26, 0x04	; 4
    2126:	2d 93       	st	X+, r18
    2128:	3c 93       	st	X, r19
    212a:	15 97       	sbiw	r26, 0x05	; 5
begin():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:90
    212c:	80 93 0b 39 	sts	0x390B, r24	; 0x80390b <bmp+0x2>
    2130:	90 93 0c 39 	sts	0x390C, r25	; 0x80390c <bmp+0x3>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:91
    if (!i2c_dev->begin())
    2134:	0e 94 9a 05 	call	0xb34	; 0xb34 <Adafruit_I2CDevice::begin(bool) [clone .constprop.15]>
    2138:	81 11       	cpse	r24, r1
    213a:	5d c0       	rjmp	.+186    	; 0x21f6 <main+0x1b4>
    213c:	0a ef       	ldi	r16, 0xFA	; 250
    213e:	10 e0       	ldi	r17, 0x00	; 0
print():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:46
size_t Print::print(const __FlashStringHelper *ifsh) {
  #if defined(__AVR__)
  PGM_P p = reinterpret_cast<PGM_P>(ifsh);
  size_t n = 0;
  while (1) {
    unsigned char c = pgm_read_byte(p++);
    2140:	f8 01       	movw	r30, r16
    2142:	64 91       	lpm	r22, Z
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:47
    if (c == 0) {
    2144:	66 23       	and	r22, r22
    2146:	41 f0       	breq	.+16     	; 0x2158 <main+0x116>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:50
      break;
    }
    if (write(c)) {
    2148:	8a e1       	ldi	r24, 0x1A	; 26
    214a:	98 e3       	ldi	r25, 0x38	; 56
    214c:	0e 94 88 01 	call	0x310	; 0x310 <UartClass::write(unsigned char)>
    2150:	0f 5f       	subi	r16, 0xFF	; 255
    2152:	1f 4f       	sbci	r17, 0xFF	; 255
    2154:	89 2b       	or	r24, r25
    2156:	a1 f7       	brne	.-24     	; 0x2140 <main+0xfe>
write():
    2158:	8f ee       	ldi	r24, 0xEF	; 239
    215a:	93 eb       	ldi	r25, 0xB3	; 179
    215c:	0e 94 40 07 	call	0xe80	; 0xe80 <Print::write(char const*) [clone .part.2] [clone .constprop.51]>
setup():
g:\Studia\PUT Rocket LAB\altimetr\Altimetr_SPI/Altimetr_SPI.ino:71
  if (!bmp.begin())
  {
    Serial.println(F("Could not find a valid BMP280 sensor, check wiring or "
                     "try a different address!"));
    while (1)
      delay(10);
    2160:	6a e0       	ldi	r22, 0x0A	; 10
    2162:	70 e0       	ldi	r23, 0x00	; 0
    2164:	80 e0       	ldi	r24, 0x00	; 0
    2166:	90 e0       	ldi	r25, 0x00	; 0
    2168:	0e 94 37 02 	call	0x46e	; 0x46e <delay>
    216c:	f9 cf       	rjmp	.-14     	; 0x2160 <main+0x11e>
begin():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:92
 *    @brief  Initializes SPI bus and sets CS pin high
 *    @return Always returns true because there's no way to test success of SPI
 * init
 */
bool Adafruit_SPIDevice::begin(void) {
  pinMode(_cs, OUTPUT);
    216e:	61 e0       	ldi	r22, 0x01	; 1
    2170:	f8 01       	movw	r30, r16
    2172:	83 85       	ldd	r24, Z+11	; 0x0b
    2174:	0e 94 5e 06 	call	0xcbc	; 0xcbc <pinMode>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:93
  digitalWrite(_cs, HIGH);
    2178:	61 e0       	ldi	r22, 0x01	; 1
    217a:	d8 01       	movw	r26, r16
    217c:	1b 96       	adiw	r26, 0x0b	; 11
    217e:	8c 91       	ld	r24, X
    2180:	0e 94 db 05 	call	0xbb6	; 0xbb6 <digitalWrite>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:95

  if (_spi) { // hardware SPI
    2184:	d8 01       	movw	r26, r16
    2186:	ed 91       	ld	r30, X+
    2188:	fc 91       	ld	r31, X
    218a:	30 97       	sbiw	r30, 0x00	; 0
    218c:	09 f4       	brne	.+2      	; 0x2190 <main+0x14e>
    218e:	90 c1       	rjmp	.+800    	; 0x24b0 <main+0x46e>
init():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:149

  config(DEFAULT_SPI_SETTINGS);
}

void SPIClass::init() {
  if (initialized) {
    2190:	85 81       	ldd	r24, Z+5	; 0x05
    2192:	81 11       	cpse	r24, r1
    2194:	0c c0       	rjmp	.+24     	; 0x21ae <main+0x16c>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:152
    return;
  }
  interruptMode = SPI_IMODE_NONE;
    2196:	16 82       	std	Z+6, r1	; 0x06
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:153
  interruptSave = 0;
    2198:	17 82       	std	Z+7, r1	; 0x07
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:154
  interruptMask_lo = 0;
    219a:	10 86       	std	Z+8, r1	; 0x08
    219c:	11 86       	std	Z+9, r1	; 0x09
    219e:	12 86       	std	Z+10, r1	; 0x0a
    21a0:	13 86       	std	Z+11, r1	; 0x0b
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:155
  interruptMask_hi = 0;
    21a2:	14 86       	std	Z+12, r1	; 0x0c
    21a4:	15 86       	std	Z+13, r1	; 0x0d
    21a6:	16 86       	std	Z+14, r1	; 0x0e
    21a8:	17 86       	std	Z+15, r1	; 0x0f
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:156
  initialized = true;
    21aa:	81 e0       	ldi	r24, 0x01	; 1
    21ac:	85 83       	std	Z+5, r24	; 0x05
begin():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:111
void SPIClass::begin() {
  init();
  #if defined(PORTMUX_CTRLB)
  PORTMUX.CTRLB = _uc_mux | (PORTMUX.CTRLB & ~PORTMUX_SPI0_bm);
  #elif defined(PORTMUX_SPIROUTEA)
  PORTMUX.SPIROUTEA = _uc_mux | (PORTMUX.SPIROUTEA & ~3);
    21ae:	80 91 e3 05 	lds	r24, 0x05E3	; 0x8005e3 <vtable for Adafruit_BMP280_Temp+0x7f521d>
    21b2:	8c 7f       	andi	r24, 0xFC	; 252
    21b4:	94 81       	ldd	r25, Z+4	; 0x04
    21b6:	89 2b       	or	r24, r25
    21b8:	80 93 e3 05 	sts	0x05E3, r24	; 0x8005e3 <vtable for Adafruit_BMP280_Temp+0x7f521d>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:138
    pinMode(PIN_SPI_SCK_PINSWAP_2, OUTPUT);
  }
  #endif
  #else
  // MISO is set to input by the controller
  pinMode(PIN_SPI_MOSI, OUTPUT);
    21bc:	61 e0       	ldi	r22, 0x01	; 1
    21be:	88 e0       	ldi	r24, 0x08	; 8
    21c0:	0e 94 5e 06 	call	0xcbc	; 0xcbc <pinMode>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:139
  pinMode(PIN_SPI_SCK, OUTPUT);
    21c4:	61 e0       	ldi	r22, 0x01	; 1
    21c6:	8a e0       	ldi	r24, 0x0A	; 10
    21c8:	0e 94 5e 06 	call	0xcbc	; 0xcbc <pinMode>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:142
  #endif

  SPI0.CTRLB |= (SPI_SSD_bm);
    21cc:	80 91 c1 08 	lds	r24, 0x08C1	; 0x8008c1 <vtable for Adafruit_BMP280_Temp+0x7f54fb>
    21d0:	84 60       	ori	r24, 0x04	; 4
    21d2:	80 93 c1 08 	sts	0x08C1, r24	; 0x8008c1 <vtable for Adafruit_BMP280_Temp+0x7f54fb>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:143
  SPI0.CTRLA |= (SPI_ENABLE_bm | SPI_MASTER_bm);
    21d6:	80 91 c0 08 	lds	r24, 0x08C0	; 0x8008c0 <vtable for Adafruit_BMP280_Temp+0x7f54fa>
    21da:	81 62       	ori	r24, 0x21	; 33
    21dc:	80 93 c0 08 	sts	0x08C0, r24	; 0x8008c0 <vtable for Adafruit_BMP280_Temp+0x7f54fa>
    21e0:	90 91 07 39 	lds	r25, 0x3907	; 0x803907 <DEFAULT_SPI_SETTINGS>
    21e4:	80 91 08 39 	lds	r24, 0x3908	; 0x803908 <DEFAULT_SPI_SETTINGS+0x1>
config():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:160
  interruptMask_hi = 0;
  initialized = true;
}

void SPIClass::config(SPISettings settings) {
  SPI0.CTRLA = settings.ctrla;
    21e8:	90 93 c0 08 	sts	0x08C0, r25	; 0x8008c0 <vtable for Adafruit_BMP280_Temp+0x7f54fa>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:161
  SPI0.CTRLB = settings.ctrlb;
    21ec:	80 93 c1 08 	sts	0x08C1, r24	; 0x8008c1 <vtable for Adafruit_BMP280_Temp+0x7f54fb>
begin():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:116
    if (_miso != -1) {
      pinMode(_miso, INPUT);
    }
  }

  _begun = true;
    21f0:	81 e0       	ldi	r24, 0x01	; 1
    21f2:	f8 01       	movw	r30, r16
    21f4:	83 8f       	std	Z+27, r24	; 0x1b
read8():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:163
 *          selected register
 *  @return value from selected register
 */
uint8_t Adafruit_BMP280::read8(byte reg) {
  uint8_t buffer[1];
  if (i2c_dev) {
    21f6:	80 91 0b 39 	lds	r24, 0x390B	; 0x80390b <bmp+0x2>
    21fa:	90 91 0c 39 	lds	r25, 0x390C	; 0x80390c <bmp+0x3>
    21fe:	00 97       	sbiw	r24, 0x00	; 0
    2200:	09 f4       	brne	.+2      	; 0x2204 <main+0x1c2>
    2202:	81 c1       	rjmp	.+770    	; 0x2506 <main+0x4c4>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:164
    buffer[0] = uint8_t(reg);
    2204:	20 ed       	ldi	r18, 0xD0	; 208
    2206:	29 83       	std	Y+1, r18	; 0x01
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:165
    i2c_dev->write_then_read(buffer, 1, buffer, 1);
    2208:	21 e0       	ldi	r18, 0x01	; 1
    220a:	30 e0       	ldi	r19, 0x00	; 0
    220c:	ae 01       	movw	r20, r28
    220e:	4f 5f       	subi	r20, 0xFF	; 255
    2210:	5f 4f       	sbci	r21, 0xFF	; 255
    2212:	ba 01       	movw	r22, r20
    2214:	38 d8       	rcall	.-3984   	; 0x1286 <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool) [clone .constprop.32]>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:170
  } else {
    buffer[0] = uint8_t(reg | 0x80);
    spi_dev->write_then_read(buffer, 1, buffer, 1);
  }
  return buffer[0];
    2216:	89 81       	ldd	r24, Y+1	; 0x01
begin():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:99
    // SPI mode
    if (!spi_dev->begin())
      return false;
  }

  if (read8(BMP280_REGISTER_CHIPID) != chipid)
    2218:	88 35       	cpi	r24, 0x58	; 88
    221a:	09 f0       	breq	.+2      	; 0x221e <main+0x1dc>
    221c:	8f cf       	rjmp	.-226    	; 0x213c <main+0xfa>
readCoefficients():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:224

/*!
 *  @brief  Reads the factory-set coefficients
 */
void Adafruit_BMP280::readCoefficients() {
  _bmp280_calib.dig_T1 = read16_LE(BMP280_REGISTER_DIG_T1);
    221e:	88 e8       	ldi	r24, 0x88	; 136
    2220:	fb d8       	rcall	.-3594   	; 0x1418 <Adafruit_BMP280::read16_LE(unsigned char) [clone .constprop.27]>
    2222:	80 93 1e 39 	sts	0x391E, r24	; 0x80391e <bmp+0x15>
    2226:	90 93 1f 39 	sts	0x391F, r25	; 0x80391f <bmp+0x16>
readS16_LE():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:200
 *   @brief  Reads a signed 16 bit value over I2C/SPI
 */
int16_t Adafruit_BMP280::readS16(byte reg) { return (int16_t)read16(reg); }

int16_t Adafruit_BMP280::readS16_LE(byte reg) {
  return (int16_t)read16_LE(reg);
    222a:	8a e8       	ldi	r24, 0x8A	; 138
    222c:	f5 d8       	rcall	.-3606   	; 0x1418 <Adafruit_BMP280::read16_LE(unsigned char) [clone .constprop.27]>
readCoefficients():
    222e:	80 93 20 39 	sts	0x3920, r24	; 0x803920 <bmp+0x17>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:225
/*!
 *  @brief  Reads the factory-set coefficients
 */
void Adafruit_BMP280::readCoefficients() {
  _bmp280_calib.dig_T1 = read16_LE(BMP280_REGISTER_DIG_T1);
  _bmp280_calib.dig_T2 = readS16_LE(BMP280_REGISTER_DIG_T2);
    2232:	90 93 21 39 	sts	0x3921, r25	; 0x803921 <bmp+0x18>
readS16_LE():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:200
 *   @brief  Reads a signed 16 bit value over I2C/SPI
 */
int16_t Adafruit_BMP280::readS16(byte reg) { return (int16_t)read16(reg); }

int16_t Adafruit_BMP280::readS16_LE(byte reg) {
  return (int16_t)read16_LE(reg);
    2236:	8c e8       	ldi	r24, 0x8C	; 140
    2238:	ef d8       	rcall	.-3618   	; 0x1418 <Adafruit_BMP280::read16_LE(unsigned char) [clone .constprop.27]>
readCoefficients():
    223a:	80 93 22 39 	sts	0x3922, r24	; 0x803922 <bmp+0x19>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:226
 *  @brief  Reads the factory-set coefficients
 */
void Adafruit_BMP280::readCoefficients() {
  _bmp280_calib.dig_T1 = read16_LE(BMP280_REGISTER_DIG_T1);
  _bmp280_calib.dig_T2 = readS16_LE(BMP280_REGISTER_DIG_T2);
  _bmp280_calib.dig_T3 = readS16_LE(BMP280_REGISTER_DIG_T3);
    223e:	90 93 23 39 	sts	0x3923, r25	; 0x803923 <bmp+0x1a>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:228

  _bmp280_calib.dig_P1 = read16_LE(BMP280_REGISTER_DIG_P1);
    2242:	8e e8       	ldi	r24, 0x8E	; 142
    2244:	e9 d8       	rcall	.-3630   	; 0x1418 <Adafruit_BMP280::read16_LE(unsigned char) [clone .constprop.27]>
    2246:	80 93 24 39 	sts	0x3924, r24	; 0x803924 <bmp+0x1b>
    224a:	90 93 25 39 	sts	0x3925, r25	; 0x803925 <bmp+0x1c>
readS16_LE():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:200
 *   @brief  Reads a signed 16 bit value over I2C/SPI
 */
int16_t Adafruit_BMP280::readS16(byte reg) { return (int16_t)read16(reg); }

int16_t Adafruit_BMP280::readS16_LE(byte reg) {
  return (int16_t)read16_LE(reg);
    224e:	80 e9       	ldi	r24, 0x90	; 144
    2250:	e3 d8       	rcall	.-3642   	; 0x1418 <Adafruit_BMP280::read16_LE(unsigned char) [clone .constprop.27]>
readCoefficients():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:229
  _bmp280_calib.dig_T1 = read16_LE(BMP280_REGISTER_DIG_T1);
  _bmp280_calib.dig_T2 = readS16_LE(BMP280_REGISTER_DIG_T2);
  _bmp280_calib.dig_T3 = readS16_LE(BMP280_REGISTER_DIG_T3);

  _bmp280_calib.dig_P1 = read16_LE(BMP280_REGISTER_DIG_P1);
  _bmp280_calib.dig_P2 = readS16_LE(BMP280_REGISTER_DIG_P2);
    2252:	80 93 26 39 	sts	0x3926, r24	; 0x803926 <bmp+0x1d>
    2256:	90 93 27 39 	sts	0x3927, r25	; 0x803927 <bmp+0x1e>
readS16_LE():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:200
 *   @brief  Reads a signed 16 bit value over I2C/SPI
 */
int16_t Adafruit_BMP280::readS16(byte reg) { return (int16_t)read16(reg); }

int16_t Adafruit_BMP280::readS16_LE(byte reg) {
  return (int16_t)read16_LE(reg);
    225a:	82 e9       	ldi	r24, 0x92	; 146
    225c:	dd d8       	rcall	.-3654   	; 0x1418 <Adafruit_BMP280::read16_LE(unsigned char) [clone .constprop.27]>
readCoefficients():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:230
  _bmp280_calib.dig_T2 = readS16_LE(BMP280_REGISTER_DIG_T2);
  _bmp280_calib.dig_T3 = readS16_LE(BMP280_REGISTER_DIG_T3);

  _bmp280_calib.dig_P1 = read16_LE(BMP280_REGISTER_DIG_P1);
  _bmp280_calib.dig_P2 = readS16_LE(BMP280_REGISTER_DIG_P2);
  _bmp280_calib.dig_P3 = readS16_LE(BMP280_REGISTER_DIG_P3);
    225e:	80 93 28 39 	sts	0x3928, r24	; 0x803928 <bmp+0x1f>
    2262:	90 93 29 39 	sts	0x3929, r25	; 0x803929 <bmp+0x20>
readS16_LE():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:200
 *   @brief  Reads a signed 16 bit value over I2C/SPI
 */
int16_t Adafruit_BMP280::readS16(byte reg) { return (int16_t)read16(reg); }

int16_t Adafruit_BMP280::readS16_LE(byte reg) {
  return (int16_t)read16_LE(reg);
    2266:	84 e9       	ldi	r24, 0x94	; 148
    2268:	d7 d8       	rcall	.-3666   	; 0x1418 <Adafruit_BMP280::read16_LE(unsigned char) [clone .constprop.27]>
readCoefficients():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:231
  _bmp280_calib.dig_T3 = readS16_LE(BMP280_REGISTER_DIG_T3);

  _bmp280_calib.dig_P1 = read16_LE(BMP280_REGISTER_DIG_P1);
  _bmp280_calib.dig_P2 = readS16_LE(BMP280_REGISTER_DIG_P2);
  _bmp280_calib.dig_P3 = readS16_LE(BMP280_REGISTER_DIG_P3);
  _bmp280_calib.dig_P4 = readS16_LE(BMP280_REGISTER_DIG_P4);
    226a:	80 93 2a 39 	sts	0x392A, r24	; 0x80392a <bmp+0x21>
    226e:	90 93 2b 39 	sts	0x392B, r25	; 0x80392b <bmp+0x22>
readS16_LE():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:200
 *   @brief  Reads a signed 16 bit value over I2C/SPI
 */
int16_t Adafruit_BMP280::readS16(byte reg) { return (int16_t)read16(reg); }

int16_t Adafruit_BMP280::readS16_LE(byte reg) {
  return (int16_t)read16_LE(reg);
    2272:	86 e9       	ldi	r24, 0x96	; 150
    2274:	d1 d8       	rcall	.-3678   	; 0x1418 <Adafruit_BMP280::read16_LE(unsigned char) [clone .constprop.27]>
readCoefficients():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:232

  _bmp280_calib.dig_P1 = read16_LE(BMP280_REGISTER_DIG_P1);
  _bmp280_calib.dig_P2 = readS16_LE(BMP280_REGISTER_DIG_P2);
  _bmp280_calib.dig_P3 = readS16_LE(BMP280_REGISTER_DIG_P3);
  _bmp280_calib.dig_P4 = readS16_LE(BMP280_REGISTER_DIG_P4);
  _bmp280_calib.dig_P5 = readS16_LE(BMP280_REGISTER_DIG_P5);
    2276:	80 93 2c 39 	sts	0x392C, r24	; 0x80392c <bmp+0x23>
    227a:	90 93 2d 39 	sts	0x392D, r25	; 0x80392d <bmp+0x24>
readS16_LE():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:200
 *   @brief  Reads a signed 16 bit value over I2C/SPI
 */
int16_t Adafruit_BMP280::readS16(byte reg) { return (int16_t)read16(reg); }

int16_t Adafruit_BMP280::readS16_LE(byte reg) {
  return (int16_t)read16_LE(reg);
    227e:	88 e9       	ldi	r24, 0x98	; 152
    2280:	cb d8       	rcall	.-3690   	; 0x1418 <Adafruit_BMP280::read16_LE(unsigned char) [clone .constprop.27]>
readCoefficients():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:233
  _bmp280_calib.dig_P1 = read16_LE(BMP280_REGISTER_DIG_P1);
  _bmp280_calib.dig_P2 = readS16_LE(BMP280_REGISTER_DIG_P2);
  _bmp280_calib.dig_P3 = readS16_LE(BMP280_REGISTER_DIG_P3);
  _bmp280_calib.dig_P4 = readS16_LE(BMP280_REGISTER_DIG_P4);
  _bmp280_calib.dig_P5 = readS16_LE(BMP280_REGISTER_DIG_P5);
  _bmp280_calib.dig_P6 = readS16_LE(BMP280_REGISTER_DIG_P6);
    2282:	80 93 2e 39 	sts	0x392E, r24	; 0x80392e <bmp+0x25>
    2286:	90 93 2f 39 	sts	0x392F, r25	; 0x80392f <bmp+0x26>
readS16_LE():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:200
 *   @brief  Reads a signed 16 bit value over I2C/SPI
 */
int16_t Adafruit_BMP280::readS16(byte reg) { return (int16_t)read16(reg); }

int16_t Adafruit_BMP280::readS16_LE(byte reg) {
  return (int16_t)read16_LE(reg);
    228a:	8a e9       	ldi	r24, 0x9A	; 154
    228c:	c5 d8       	rcall	.-3702   	; 0x1418 <Adafruit_BMP280::read16_LE(unsigned char) [clone .constprop.27]>
readCoefficients():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:234
  _bmp280_calib.dig_P2 = readS16_LE(BMP280_REGISTER_DIG_P2);
  _bmp280_calib.dig_P3 = readS16_LE(BMP280_REGISTER_DIG_P3);
  _bmp280_calib.dig_P4 = readS16_LE(BMP280_REGISTER_DIG_P4);
  _bmp280_calib.dig_P5 = readS16_LE(BMP280_REGISTER_DIG_P5);
  _bmp280_calib.dig_P6 = readS16_LE(BMP280_REGISTER_DIG_P6);
  _bmp280_calib.dig_P7 = readS16_LE(BMP280_REGISTER_DIG_P7);
    228e:	80 93 30 39 	sts	0x3930, r24	; 0x803930 <bmp+0x27>
    2292:	90 93 31 39 	sts	0x3931, r25	; 0x803931 <bmp+0x28>
readS16_LE():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:200
 *   @brief  Reads a signed 16 bit value over I2C/SPI
 */
int16_t Adafruit_BMP280::readS16(byte reg) { return (int16_t)read16(reg); }

int16_t Adafruit_BMP280::readS16_LE(byte reg) {
  return (int16_t)read16_LE(reg);
    2296:	8c e9       	ldi	r24, 0x9C	; 156
    2298:	bf d8       	rcall	.-3714   	; 0x1418 <Adafruit_BMP280::read16_LE(unsigned char) [clone .constprop.27]>
readCoefficients():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:235
  _bmp280_calib.dig_P3 = readS16_LE(BMP280_REGISTER_DIG_P3);
  _bmp280_calib.dig_P4 = readS16_LE(BMP280_REGISTER_DIG_P4);
  _bmp280_calib.dig_P5 = readS16_LE(BMP280_REGISTER_DIG_P5);
  _bmp280_calib.dig_P6 = readS16_LE(BMP280_REGISTER_DIG_P6);
  _bmp280_calib.dig_P7 = readS16_LE(BMP280_REGISTER_DIG_P7);
  _bmp280_calib.dig_P8 = readS16_LE(BMP280_REGISTER_DIG_P8);
    229a:	80 93 32 39 	sts	0x3932, r24	; 0x803932 <bmp+0x29>
    229e:	90 93 33 39 	sts	0x3933, r25	; 0x803933 <bmp+0x2a>
readS16_LE():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:200
 *   @brief  Reads a signed 16 bit value over I2C/SPI
 */
int16_t Adafruit_BMP280::readS16(byte reg) { return (int16_t)read16(reg); }

int16_t Adafruit_BMP280::readS16_LE(byte reg) {
  return (int16_t)read16_LE(reg);
    22a2:	8e e9       	ldi	r24, 0x9E	; 158
    22a4:	b9 d8       	rcall	.-3726   	; 0x1418 <Adafruit_BMP280::read16_LE(unsigned char) [clone .constprop.27]>
readCoefficients():
    22a6:	80 93 34 39 	sts	0x3934, r24	; 0x803934 <bmp+0x2b>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:236
  _bmp280_calib.dig_P4 = readS16_LE(BMP280_REGISTER_DIG_P4);
  _bmp280_calib.dig_P5 = readS16_LE(BMP280_REGISTER_DIG_P5);
  _bmp280_calib.dig_P6 = readS16_LE(BMP280_REGISTER_DIG_P6);
  _bmp280_calib.dig_P7 = readS16_LE(BMP280_REGISTER_DIG_P7);
  _bmp280_calib.dig_P8 = readS16_LE(BMP280_REGISTER_DIG_P8);
  _bmp280_calib.dig_P9 = readS16_LE(BMP280_REGISTER_DIG_P9);
    22aa:	90 93 35 39 	sts	0x3935, r25	; 0x803935 <bmp+0x2c>
setSampling():
    22ae:	8d ee       	ldi	r24, 0xED	; 237
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:128
                                  sensor_sampling tempSampling,
                                  sensor_sampling pressSampling,
                                  sensor_filter filter,
                                  standby_duration duration) {
  _measReg.mode = mode;
  _measReg.osrs_t = tempSampling;
    22b0:	80 93 1d 39 	sts	0x391D, r24	; 0x80391d <bmp+0x14>
    22b4:	60 91 1c 39 	lds	r22, 0x391C	; 0x80391c <bmp+0x13>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:131
  _measReg.osrs_p = pressSampling;

  _configReg.filter = filter;
    22b8:	60 7c       	andi	r22, 0xC0	; 192
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:132
  _configReg.t_sb = duration;
    22ba:	60 93 1c 39 	sts	0x391C, r22	; 0x80391c <bmp+0x13>
get():
    22be:	67 fb       	bst	r22, 7
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.h:232
    /** Unused - don't set */
    unsigned int none : 1;
    /** Enables 3-wire SPI */
    unsigned int spi3w_en : 1;
    /** Used to retrieve the assembled config register's byte value. */
    unsigned int get() { return (t_sb << 5) | (filter << 2) | spi3w_en; }
    22c0:	66 27       	eor	r22, r22
    22c2:	60 f9       	bld	r22, 0
setSampling():
    22c4:	85 ef       	ldi	r24, 0xF5	; 245
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:134

  write8(BMP280_REGISTER_CONFIG, _configReg.get());
    22c6:	0e 94 fd 08 	call	0x11fa	; 0x11fa <Adafruit_BMP280::write8(unsigned char, unsigned char) [clone .constprop.24]>
get():
    22ca:	80 91 1d 39 	lds	r24, 0x391D	; 0x80391d <bmp+0x14>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.h:244
    /** Pressure oversampling. */
    unsigned int osrs_p : 3;
    /** Device mode */
    unsigned int mode : 2;
    /** Used to retrieve the assembled ctrl_meas register's byte value. */
    unsigned int get() { return (osrs_t << 5) | (osrs_p << 2) | mode; }
    22ce:	68 2f       	mov	r22, r24
    22d0:	67 70       	andi	r22, 0x07	; 7
    22d2:	f0 e2       	ldi	r31, 0x20	; 32
    22d4:	6f 9f       	mul	r22, r31
    22d6:	b0 01       	movw	r22, r0
    22d8:	11 24       	eor	r1, r1
    22da:	28 2f       	mov	r18, r24
    22dc:	26 95       	lsr	r18
    22de:	26 95       	lsr	r18
    22e0:	26 95       	lsr	r18
    22e2:	27 70       	andi	r18, 0x07	; 7
    22e4:	94 e0       	ldi	r25, 0x04	; 4
    22e6:	29 9f       	mul	r18, r25
    22e8:	90 01       	movw	r18, r0
    22ea:	11 24       	eor	r1, r1
    22ec:	62 2b       	or	r22, r18
    22ee:	82 95       	swap	r24
    22f0:	86 95       	lsr	r24
    22f2:	86 95       	lsr	r24
    22f4:	83 70       	andi	r24, 0x03	; 3
    22f6:	68 2b       	or	r22, r24
setSampling():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:135
  write8(BMP280_REGISTER_CONTROL, _measReg.get());
    22f8:	84 ef       	ldi	r24, 0xF4	; 244
    22fa:	0e 94 fd 08 	call	0x11fa	; 0x11fa <Adafruit_BMP280::write8(unsigned char, unsigned char) [clone .constprop.24]>
begin():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:105
    return false;

  readCoefficients();
  // write8(BMP280_REGISTER_CONTROL, 0x3F); /* needed? */
  setSampling();
  delay(100);
    22fe:	64 e6       	ldi	r22, 0x64	; 100
    2300:	70 e0       	ldi	r23, 0x00	; 0
    2302:	80 e0       	ldi	r24, 0x00	; 0
    2304:	90 e0       	ldi	r25, 0x00	; 0
    2306:	0e 94 37 02 	call	0x46e	; 0x46e <delay>
readAltitude():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:309
 * @return The approximate altitude above sea level in meters.
 */
float Adafruit_BMP280::readAltitude(float seaLevelhPa) {
  float altitude;

  float pressure = readPressure(); // in Si units for Pascal
    230a:	89 e0       	ldi	r24, 0x09	; 9
    230c:	99 e3       	ldi	r25, 0x39	; 57
    230e:	52 d9       	rcall	.-3420   	; 0x15b4 <Adafruit_BMP280::readPressure()>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:310
  pressure /= 100;
    2310:	20 e0       	ldi	r18, 0x00	; 0
    2312:	30 e0       	ldi	r19, 0x00	; 0
    2314:	48 ec       	ldi	r20, 0xC8	; 200
    2316:	52 e4       	ldi	r21, 0x42	; 66
    2318:	e2 d1       	rcall	.+964    	; 0x26de <__divsf3>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:312

  altitude = 44330 * (1.0 - pow(pressure / seaLevelhPa, 0.1903));
    231a:	20 e0       	ldi	r18, 0x00	; 0
    231c:	30 e0       	ldi	r19, 0x00	; 0
    231e:	4f e7       	ldi	r20, 0x7F	; 127
    2320:	54 e4       	ldi	r21, 0x44	; 68
    2322:	dd d1       	rcall	.+954    	; 0x26de <__divsf3>
    2324:	21 e0       	ldi	r18, 0x01	; 1
    2326:	3e ed       	ldi	r19, 0xDE	; 222
    2328:	42 e4       	ldi	r20, 0x42	; 66
    232a:	5e e3       	ldi	r21, 0x3E	; 62
    232c:	d7 d3       	rcall	.+1966   	; 0x2adc <pow>
    232e:	9b 01       	movw	r18, r22
    2330:	ac 01       	movw	r20, r24
    2332:	60 e0       	ldi	r22, 0x00	; 0
    2334:	70 e0       	ldi	r23, 0x00	; 0
    2336:	80 e8       	ldi	r24, 0x80	; 128
    2338:	9f e3       	ldi	r25, 0x3F	; 63
    233a:	68 d1       	rcall	.+720    	; 0x260c <__subsf3>
    233c:	20 e0       	ldi	r18, 0x00	; 0
    233e:	3a e2       	ldi	r19, 0x2A	; 42
    2340:	4d e2       	ldi	r20, 0x2D	; 45
    2342:	57 e4       	ldi	r21, 0x47	; 71
    2344:	68 d3       	rcall	.+1744   	; 0x2a16 <__mulsf3>
setup():
    2346:	60 93 06 38 	sts	0x3806, r22	; 0x803806 <__data_end>
g:\Studia\PUT Rocket LAB\altimetr\Altimetr_SPI/Altimetr_SPI.ino:99
  // // get the calibration data
  // calibrationData = calibration();
  // set 0 level
  // initialHight = GetHight(0.0);

  initialHight = bmp.readAltitude(seaLevelhPa);
    234a:	70 93 07 38 	sts	0x3807, r23	; 0x803807 <__data_end+0x1>
    234e:	80 93 08 38 	sts	0x3808, r24	; 0x803808 <__data_end+0x2>
    2352:	90 93 09 38 	sts	0x3809, r25	; 0x803809 <__data_end+0x3>
    2356:	8a e1       	ldi	r24, 0x1A	; 26
    2358:	98 e3       	ldi	r25, 0x38	; 56
g:\Studia\PUT Rocket LAB\altimetr\Altimetr_SPI/Altimetr_SPI.ino:100
  if (Serial.available())
    235a:	0e 94 47 01 	call	0x28e	; 0x28e <UartClass::available()>
    235e:	89 2b       	or	r24, r25
    2360:	99 f0       	breq	.+38     	; 0x2388 <main+0x346>
write():
    2362:	82 ef       	ldi	r24, 0xF2	; 242
    2364:	93 eb       	ldi	r25, 0xB3	; 179
    2366:	0e 94 40 07 	call	0xe80	; 0xe80 <Print::write(char const*) [clone .part.2] [clone .constprop.51]>
print():
    236a:	60 91 06 38 	lds	r22, 0x3806	; 0x803806 <__data_end>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:110
    return printNumber(n, base);
  }
}

size_t Print::print(double n, int digits) {
  return printFloat(n, digits);
    236e:	70 91 07 38 	lds	r23, 0x3807	; 0x803807 <__data_end+0x1>
    2372:	80 91 08 38 	lds	r24, 0x3808	; 0x803808 <__data_end+0x2>
    2376:	90 91 09 38 	lds	r25, 0x3809	; 0x803809 <__data_end+0x3>
    237a:	42 e0       	ldi	r20, 0x02	; 2
    237c:	0e 94 89 07 	call	0xf12	; 0xf12 <Print::printFloat(double, unsigned char) [clone .constprop.41]>
write():
    2380:	8f ee       	ldi	r24, 0xEF	; 239
    2382:	93 eb       	ldi	r25, 0xB3	; 179
    2384:	0e 94 40 07 	call	0xe80	; 0xe80 <Print::write(char const*) [clone .part.2] [clone .constprop.51]>
millis():
    2388:	8f b7       	in	r24, 0x3f	; 63
    238a:	f8 94       	cli
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:226


unsigned long millis() {
  // return timer_overflow_count; // for debugging timekeeping issues where these variables are out of scope from the sketch
  unsigned long m;
  uint8_t oldSREG = SREG;
    238c:	80 90 0a 38 	lds	r8, 0x380A	; 0x80380a <timer_millis>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:255

     * Not only that - but a dedicated optimizing assembly programmer could probably ensure that instead of the >> 7 (a little mini loop)
     * that was implemented leftshifting it once, retaining the carried bit, and
     */
  #else
    m = timer_millis;
    2390:	90 90 0b 38 	lds	r9, 0x380B	; 0x80380b <timer_millis+0x1>
    2394:	a0 90 0c 38 	lds	r10, 0x380C	; 0x80380c <timer_millis+0x2>
    2398:	b0 90 0d 38 	lds	r11, 0x380D	; 0x80380d <timer_millis+0x3>
    239c:	8f bf       	out	0x3f, r24	; 63
loop():
    239e:	94 01       	movw	r18, r8
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:256
    SREG = oldSREG;
    23a0:	a5 01       	movw	r20, r10
g:\Studia\PUT Rocket LAB\altimetr\Altimetr_SPI/Altimetr_SPI.ino:109
  }
}

void loop()
{
  if (millis() - t > TIME_INTERVAL)
    23a2:	60 e0       	ldi	r22, 0x00	; 0
    23a4:	70 e0       	ldi	r23, 0x00	; 0
    23a6:	80 e0       	ldi	r24, 0x00	; 0
    23a8:	90 e0       	ldi	r25, 0x00	; 0
    23aa:	a0 90 12 38 	lds	r10, 0x3812	; 0x803812 <t>
    23ae:	b0 90 13 38 	lds	r11, 0x3813	; 0x803813 <t+0x1>
    23b2:	c0 90 14 38 	lds	r12, 0x3814	; 0x803814 <t+0x2>
    23b6:	d0 90 15 38 	lds	r13, 0x3815	; 0x803815 <t+0x3>
    23ba:	e0 90 16 38 	lds	r14, 0x3816	; 0x803816 <t+0x4>
    23be:	f0 90 17 38 	lds	r15, 0x3817	; 0x803817 <t+0x5>
    23c2:	00 91 18 38 	lds	r16, 0x3818	; 0x803818 <t+0x6>
    23c6:	10 91 19 38 	lds	r17, 0x3819	; 0x803819 <t+0x7>
    23ca:	5a d6       	rcall	.+3252   	; 0x3080 <__subdi3>
    23cc:	28 3e       	cpi	r18, 0xE8	; 232
    23ce:	33 40       	sbci	r19, 0x03	; 3
    23d0:	41 05       	cpc	r20, r1
    23d2:	51 05       	cpc	r21, r1
    23d4:	61 05       	cpc	r22, r1
    23d6:	71 05       	cpc	r23, r1
    23d8:	81 05       	cpc	r24, r1
    23da:	91 05       	cpc	r25, r1
    23dc:	a9 f2       	breq	.-86     	; 0x2388 <main+0x346>
    23de:	a0 f2       	brcs	.-88     	; 0x2388 <main+0x346>
millis():
    23e0:	8f b7       	in	r24, 0x3f	; 63
    23e2:	f8 94       	cli
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:226


unsigned long millis() {
  // return timer_overflow_count; // for debugging timekeeping issues where these variables are out of scope from the sketch
  unsigned long m;
  uint8_t oldSREG = SREG;
    23e4:	00 91 0a 38 	lds	r16, 0x380A	; 0x80380a <timer_millis>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:255

     * Not only that - but a dedicated optimizing assembly programmer could probably ensure that instead of the >> 7 (a little mini loop)
     * that was implemented leftshifting it once, retaining the carried bit, and
     */
  #else
    m = timer_millis;
    23e8:	10 91 0b 38 	lds	r17, 0x380B	; 0x80380b <timer_millis+0x1>
    23ec:	20 91 0c 38 	lds	r18, 0x380C	; 0x80380c <timer_millis+0x2>
    23f0:	30 91 0d 38 	lds	r19, 0x380D	; 0x80380d <timer_millis+0x3>
    23f4:	8f bf       	out	0x3f, r24	; 63
loop():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:256
    SREG = oldSREG;
    23f6:	00 93 12 38 	sts	0x3812, r16	; 0x803812 <t>
g:\Studia\PUT Rocket LAB\altimetr\Altimetr_SPI/Altimetr_SPI.ino:111
  {
    t = millis();
    23fa:	10 93 13 38 	sts	0x3813, r17	; 0x803813 <t+0x1>
    23fe:	20 93 14 38 	sts	0x3814, r18	; 0x803814 <t+0x2>
    2402:	30 93 15 38 	sts	0x3815, r19	; 0x803815 <t+0x3>
    2406:	10 92 16 38 	sts	0x3816, r1	; 0x803816 <t+0x4>
    240a:	10 92 17 38 	sts	0x3817, r1	; 0x803817 <t+0x5>
    240e:	10 92 18 38 	sts	0x3818, r1	; 0x803818 <t+0x6>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:309
 * @return The approximate altitude above sea level in meters.
 */
float Adafruit_BMP280::readAltitude(float seaLevelhPa) {
  float altitude;

  float pressure = readPressure(); // in Si units for Pascal
    2412:	10 92 19 38 	sts	0x3819, r1	; 0x803819 <t+0x7>
readAltitude():
    2416:	89 e0       	ldi	r24, 0x09	; 9
    2418:	99 e3       	ldi	r25, 0x39	; 57
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:310
  pressure /= 100;
    241a:	cc d8       	rcall	.-3688   	; 0x15b4 <Adafruit_BMP280::readPressure()>
    241c:	20 e0       	ldi	r18, 0x00	; 0
    241e:	30 e0       	ldi	r19, 0x00	; 0
    2420:	48 ec       	ldi	r20, 0xC8	; 200
    2422:	52 e4       	ldi	r21, 0x42	; 66
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:312

  altitude = 44330 * (1.0 - pow(pressure / seaLevelhPa, 0.1903));
    2424:	5c d1       	rcall	.+696    	; 0x26de <__divsf3>
    2426:	20 e0       	ldi	r18, 0x00	; 0
    2428:	30 e0       	ldi	r19, 0x00	; 0
    242a:	4f e7       	ldi	r20, 0x7F	; 127
    242c:	54 e4       	ldi	r21, 0x44	; 68
    242e:	57 d1       	rcall	.+686    	; 0x26de <__divsf3>
    2430:	21 e0       	ldi	r18, 0x01	; 1
    2432:	3e ed       	ldi	r19, 0xDE	; 222
    2434:	42 e4       	ldi	r20, 0x42	; 66
    2436:	5e e3       	ldi	r21, 0x3E	; 62
    2438:	51 d3       	rcall	.+1698   	; 0x2adc <pow>
    243a:	9b 01       	movw	r18, r22
    243c:	ac 01       	movw	r20, r24
    243e:	60 e0       	ldi	r22, 0x00	; 0
    2440:	70 e0       	ldi	r23, 0x00	; 0
    2442:	80 e8       	ldi	r24, 0x80	; 128
    2444:	9f e3       	ldi	r25, 0x3F	; 63
    2446:	e2 d0       	rcall	.+452    	; 0x260c <__subsf3>
    2448:	20 e0       	ldi	r18, 0x00	; 0
    244a:	3a e2       	ldi	r19, 0x2A	; 42
    244c:	4d e2       	ldi	r20, 0x2D	; 45
    244e:	57 e4       	ldi	r21, 0x47	; 71
    2450:	e2 d2       	rcall	.+1476   	; 0x2a16 <__mulsf3>
    2452:	6b 01       	movw	r12, r22
    2454:	7c 01       	movw	r14, r24
loop():
    2456:	ac 01       	movw	r20, r24
    2458:	9b 01       	movw	r18, r22
g:\Studia\PUT Rocket LAB\altimetr\Altimetr_SPI/Altimetr_SPI.ino:113
    float hight = bmp.readAltitude(seaLevelhPa);
    if (hight > maxHightRAM)
    245a:	60 91 0e 38 	lds	r22, 0x380E	; 0x80380e <maxHightRAM>
    245e:	70 91 0f 38 	lds	r23, 0x380F	; 0x80380f <maxHightRAM+0x1>
    2462:	80 91 10 38 	lds	r24, 0x3810	; 0x803810 <maxHightRAM+0x2>
    2466:	90 91 11 38 	lds	r25, 0x3811	; 0x803811 <maxHightRAM+0x3>
    246a:	35 d1       	rcall	.+618    	; 0x26d6 <__cmpsf2>
    246c:	87 ff       	sbrs	r24, 7
    246e:	08 c0       	rjmp	.+16     	; 0x2480 <main+0x43e>
    2470:	c0 92 0e 38 	sts	0x380E, r12	; 0x80380e <maxHightRAM>
g:\Studia\PUT Rocket LAB\altimetr\Altimetr_SPI/Altimetr_SPI.ino:115
    {
      maxHightRAM = hight;
    2474:	d0 92 0f 38 	sts	0x380F, r13	; 0x80380f <maxHightRAM+0x1>
    2478:	e0 92 10 38 	sts	0x3810, r14	; 0x803810 <maxHightRAM+0x2>
    247c:	f0 92 11 38 	sts	0x3811, r15	; 0x803811 <maxHightRAM+0x3>
    2480:	8a e1       	ldi	r24, 0x1A	; 26
    2482:	98 e3       	ldi	r25, 0x38	; 56
g:\Studia\PUT Rocket LAB\altimetr\Altimetr_SPI/Altimetr_SPI.ino:123
    else
    {
      // eeprom_update_float(&maxHightEEM, maxHightRAM);
    }

    if (Serial.available() && !digitalRead(SEND_DATA_UART_EN))
    2484:	0e 94 47 01 	call	0x28e	; 0x28e <UartClass::available()>
    2488:	89 2b       	or	r24, r25
    248a:	09 f4       	brne	.+2      	; 0x248e <main+0x44c>
    248c:	7d cf       	rjmp	.-262    	; 0x2388 <main+0x346>
digitalRead():
    248e:	80 91 08 04 	lds	r24, 0x0408	; 0x800408 <vtable for Adafruit_BMP280_Temp+0x7f5042>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:385

  /* Get port and check valid port */
  PORT_t *port = digitalPinToPortStruct(pin);

  /* Read pin value from PORTx.IN register */
  if (port->IN & bit_mask) {
    2492:	87 fd       	sbrc	r24, 7
    2494:	79 cf       	rjmp	.-270    	; 0x2388 <main+0x346>
loop():
    2496:	80 e0       	ldi	r24, 0x00	; 0
    2498:	90 e0       	ldi	r25, 0x00	; 0
g:\Studia\PUT Rocket LAB\altimetr\Altimetr_SPI/Altimetr_SPI.ino:125
    {
      float readHight = eeprom_read_float(&maxHightEEM);
    249a:	79 d0       	rcall	.+242    	; 0x258e <eeprom_read_dword>
    249c:	6b 01       	movw	r12, r22
    249e:	7c 01       	movw	r14, r24
write():
    24a0:	82 e0       	ldi	r24, 0x02	; 2
    24a2:	94 eb       	ldi	r25, 0xB4	; 180
    24a4:	0e 94 40 07 	call	0xe80	; 0xe80 <Print::write(char const*) [clone .part.2] [clone .constprop.51]>
print():
    24a8:	42 e0       	ldi	r20, 0x02	; 2
    24aa:	c7 01       	movw	r24, r14
    24ac:	b6 01       	movw	r22, r12
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:110
    24ae:	66 cf       	rjmp	.-308    	; 0x237c <main+0x33a>
begin():
    24b0:	61 e0       	ldi	r22, 0x01	; 1
    24b2:	f8 01       	movw	r30, r16
    24b4:	84 85       	ldd	r24, Z+12	; 0x0c
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:98
  digitalWrite(_cs, HIGH);

  if (_spi) { // hardware SPI
    _spi->begin();
  } else {
    pinMode(_sck, OUTPUT);
    24b6:	0e 94 5e 06 	call	0xcbc	; 0xcbc <pinMode>
    24ba:	d8 01       	movw	r26, r16
    24bc:	1a 96       	adiw	r26, 0x0a	; 10
    24be:	8c 91       	ld	r24, X
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:100

    if ((_dataMode == SPI_MODE0) || (_dataMode == SPI_MODE1)) {
    24c0:	1a 97       	sbiw	r26, 0x0a	; 10
    24c2:	82 30       	cpi	r24, 0x02	; 2
    24c4:	e0 f4       	brcc	.+56     	; 0x24fe <main+0x4bc>
    24c6:	60 e0       	ldi	r22, 0x00	; 0
    24c8:	1c 96       	adiw	r26, 0x0c	; 12
    24ca:	8c 91       	ld	r24, X
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:102
      // idle low on mode 0 and 1
      digitalWrite(_sck, LOW);
    24cc:	0e 94 db 05 	call	0xbb6	; 0xbb6 <digitalWrite>
    24d0:	d8 01       	movw	r26, r16
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:105
    } else {
      // idle high on mode 2 or 3
      digitalWrite(_sck, HIGH);
    24d2:	1d 96       	adiw	r26, 0x0d	; 13
    24d4:	8c 91       	ld	r24, X
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:107
    }
    if (_mosi != -1) {
    24d6:	8f 3f       	cpi	r24, 0xFF	; 255
    24d8:	41 f0       	breq	.+16     	; 0x24ea <main+0x4a8>
    24da:	61 e0       	ldi	r22, 0x01	; 1
    24dc:	0e 94 5e 06 	call	0xcbc	; 0xcbc <pinMode>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:108
      pinMode(_mosi, OUTPUT);
    24e0:	61 e0       	ldi	r22, 0x01	; 1
    24e2:	f8 01       	movw	r30, r16
    24e4:	85 85       	ldd	r24, Z+13	; 0x0d
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:109
      digitalWrite(_mosi, HIGH);
    24e6:	0e 94 db 05 	call	0xbb6	; 0xbb6 <digitalWrite>
    24ea:	d8 01       	movw	r26, r16
    24ec:	1e 96       	adiw	r26, 0x0e	; 14
    24ee:	8c 91       	ld	r24, X
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:111
    }
    if (_miso != -1) {
    24f0:	8f 3f       	cpi	r24, 0xFF	; 255
    24f2:	09 f4       	brne	.+2      	; 0x24f6 <main+0x4b4>
    24f4:	7d ce       	rjmp	.-774    	; 0x21f0 <main+0x1ae>
    24f6:	60 e0       	ldi	r22, 0x00	; 0
    24f8:	0e 94 5e 06 	call	0xcbc	; 0xcbc <pinMode>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:112
      pinMode(_miso, INPUT);
    24fc:	79 ce       	rjmp	.-782    	; 0x21f0 <main+0x1ae>
    24fe:	61 e0       	ldi	r22, 0x01	; 1
    2500:	f8 01       	movw	r30, r16
    2502:	84 85       	ldd	r24, Z+12	; 0x0c
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:105
    if ((_dataMode == SPI_MODE0) || (_dataMode == SPI_MODE1)) {
      // idle low on mode 0 and 1
      digitalWrite(_sck, LOW);
    } else {
      // idle high on mode 2 or 3
      digitalWrite(_sck, HIGH);
    2504:	e3 cf       	rjmp	.-58     	; 0x24cc <main+0x48a>
read8():
    2506:	80 ed       	ldi	r24, 0xD0	; 208
    2508:	89 83       	std	Y+1, r24	; 0x01
    250a:	21 e0       	ldi	r18, 0x01	; 1
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:167
  uint8_t buffer[1];
  if (i2c_dev) {
    buffer[0] = uint8_t(reg);
    i2c_dev->write_then_read(buffer, 1, buffer, 1);
  } else {
    buffer[0] = uint8_t(reg | 0x80);
    250c:	30 e0       	ldi	r19, 0x00	; 0
    250e:	ae 01       	movw	r20, r28
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:168
    spi_dev->write_then_read(buffer, 1, buffer, 1);
    2510:	4f 5f       	subi	r20, 0xFF	; 255
    2512:	5f 4f       	sbci	r21, 0xFF	; 255
    2514:	ba 01       	movw	r22, r20
    2516:	80 91 0d 39 	lds	r24, 0x390D	; 0x80390d <bmp+0x4>
    251a:	90 91 0e 39 	lds	r25, 0x390E	; 0x80390e <bmp+0x5>
    251e:	0e 94 24 06 	call	0xc48	; 0xc48 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char) [clone .constprop.35]>
    2522:	79 ce       	rjmp	.-782    	; 0x2216 <main+0x1d4>

00002524 <_GLOBAL__sub_D_bmp>:
_GLOBAL__sub_D_bmp():
    2524:	cf 93       	push	r28
    2526:	df 93       	push	r29
__base_dtor ():
    2528:	c0 91 0d 39 	lds	r28, 0x390D	; 0x80390d <bmp+0x4>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:37
  temp_sensor = new Adafruit_BMP280_Temp(this);
  pressure_sensor = new Adafruit_BMP280_Pressure(this);
}

Adafruit_BMP280::~Adafruit_BMP280(void) {
  if (spi_dev)
    252c:	d0 91 0e 39 	lds	r29, 0x390E	; 0x80390e <bmp+0x5>
    2530:	20 97       	sbiw	r28, 0x00	; 0
    2532:	39 f0       	breq	.+14     	; 0x2542 <_GLOBAL__sub_D_bmp+0x1e>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:80

/*!
 *    @brief  Release memory allocated in constructors
 */
Adafruit_SPIDevice::~Adafruit_SPIDevice() {
  if (_spiSetting) {
    2534:	8a 81       	ldd	r24, Y+2	; 0x02
    2536:	9b 81       	ldd	r25, Y+3	; 0x03
    2538:	00 97       	sbiw	r24, 0x00	; 0
    253a:	09 f0       	breq	.+2      	; 0x253e <_GLOBAL__sub_D_bmp+0x1a>
operator delete():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/new.cpp:63
// Since C++14, also need two more delete variants...
// Note thnat this CAN break code that compiled amd worked in C++11.
#if (__cpp_sized_deallocation >= 201309L)
  void  operator delete  (void* ptr, size_t size) noexcept {
    (void) size;
    free(ptr);
    253c:	67 d6       	rcall	.+3278   	; 0x320c <free>
    253e:	ce 01       	movw	r24, r28
    2540:	65 d6       	rcall	.+3274   	; 0x320c <free>
__base_dtor ():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:39
    delete spi_dev;
  if (i2c_dev)
    2542:	80 91 0b 39 	lds	r24, 0x390B	; 0x80390b <bmp+0x2>
    2546:	90 91 0c 39 	lds	r25, 0x390C	; 0x80390c <bmp+0x3>
    254a:	00 97       	sbiw	r24, 0x00	; 0
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/new.cpp:63
    254c:	09 f0       	breq	.+2      	; 0x2550 <_GLOBAL__sub_D_bmp+0x2c>
operator delete():
    254e:	5e d6       	rcall	.+3260   	; 0x320c <free>
__base_dtor ():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:41
    delete i2c_dev;
  delete temp_sensor;
    2550:	80 91 0f 39 	lds	r24, 0x390F	; 0x80390f <bmp+0x6>
    2554:	90 91 10 39 	lds	r25, 0x3910	; 0x803910 <bmp+0x7>
    2558:	00 97       	sbiw	r24, 0x00	; 0
    255a:	39 f0       	breq	.+14     	; 0x256a <_GLOBAL__sub_D_bmp+0x46>
    255c:	dc 01       	movw	r26, r24
    255e:	ed 91       	ld	r30, X+
    2560:	fc 91       	ld	r31, X
    2562:	02 80       	ldd	r0, Z+2	; 0x02
    2564:	f3 81       	ldd	r31, Z+3	; 0x03
    2566:	e0 2d       	mov	r30, r0
    2568:	09 95       	icall
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:42
  delete pressure_sensor;
    256a:	80 91 11 39 	lds	r24, 0x3911	; 0x803911 <bmp+0x8>
    256e:	90 91 12 39 	lds	r25, 0x3912	; 0x803912 <bmp+0x9>
    2572:	00 97       	sbiw	r24, 0x00	; 0
    2574:	49 f0       	breq	.+18     	; 0x2588 <_GLOBAL__sub_D_bmp+0x64>
    2576:	dc 01       	movw	r26, r24
    2578:	ed 91       	ld	r30, X+
    257a:	fc 91       	ld	r31, X
    257c:	02 80       	ldd	r0, Z+2	; 0x02
    257e:	f3 81       	ldd	r31, Z+3	; 0x03
    2580:	e0 2d       	mov	r30, r0
_GLOBAL__sub_D_bmp():
g:\Studia\PUT Rocket LAB\altimetr\Altimetr_SPI/Altimetr_SPI.ino:130
      Serial.print("Max Hight:\t");
      Serial.println(readHight);
    }
  }
}
    2582:	df 91       	pop	r29
    2584:	cf 91       	pop	r28
__base_dtor ():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:42
    2586:	09 94       	ijmp
_GLOBAL__sub_D_bmp():
g:\Studia\PUT Rocket LAB\altimetr\Altimetr_SPI/Altimetr_SPI.ino:130
    2588:	df 91       	pop	r29
    258a:	cf 91       	pop	r28
    258c:	08 95       	ret

0000258e <eeprom_read_dword>:
eeprom_read_dword():
/home/toolsbuild/workspace/avr8-devices-pack/src/avr-libc/avr/lib/avrxmega3/attiny1624/../../../../libc/misc/eerd_dword.S:50
    258e:	09 d0       	rcall	.+18     	; 0x25a2 <eeprom_mapen>
/home/toolsbuild/workspace/avr8-devices-pack/src/avr-libc/avr/lib/avrxmega3/attiny1624/../../../../libc/misc/eerd_dword.S:51
    2590:	60 81       	ld	r22, Z
/home/toolsbuild/workspace/avr8-devices-pack/src/avr-libc/avr/lib/avrxmega3/attiny1624/../../../../libc/misc/eerd_dword.S:52
    2592:	71 81       	ldd	r23, Z+1	; 0x01
/home/toolsbuild/workspace/avr8-devices-pack/src/avr-libc/avr/lib/avrxmega3/attiny1624/../../../../libc/misc/eerd_dword.S:53
    2594:	82 81       	ldd	r24, Z+2	; 0x02
/home/toolsbuild/workspace/avr8-devices-pack/src/avr-libc/avr/lib/avrxmega3/attiny1624/../../../../libc/misc/eerd_dword.S:54
    2596:	93 81       	ldd	r25, Z+3	; 0x03
/home/toolsbuild/workspace/avr8-devices-pack/src/avr-libc/avr/lib/avrxmega3/attiny1624/../../../../libc/misc/eerd_dword.S:55
    2598:	08 95       	ret

0000259a <eeprom_read_byte>:
eeprom_read_byte():
/home/toolsbuild/workspace/avr8-devices-pack/src/avr-libc/avr/lib/avrxmega3/attiny1624/../../../../libc/misc/eerd_byte.S:51
    259a:	03 d0       	rcall	.+6      	; 0x25a2 <eeprom_mapen>
/home/toolsbuild/workspace/avr8-devices-pack/src/avr-libc/avr/lib/avrxmega3/attiny1624/../../../../libc/misc/eerd_byte.S:52
    259c:	80 81       	ld	r24, Z
/home/toolsbuild/workspace/avr8-devices-pack/src/avr-libc/avr/lib/avrxmega3/attiny1624/../../../../libc/misc/eerd_byte.S:53
    259e:	99 27       	eor	r25, r25
/home/toolsbuild/workspace/avr8-devices-pack/src/avr-libc/avr/lib/avrxmega3/attiny1624/../../../../libc/misc/eerd_byte.S:54
    25a0:	08 95       	ret

000025a2 <eeprom_mapen>:
/home/toolsbuild/workspace/avr8-devices-pack/src/avr-libc/avr/lib/avrxmega3/attiny1624/../../../../libc/misc/eerd_byte.S:83
    25a2:	fc 01       	movw	r30, r24
/home/toolsbuild/workspace/avr8-devices-pack/src/avr-libc/avr/lib/avrxmega3/attiny1624/../../../../libc/misc/eerd_byte.S:84
    25a4:	e0 50       	subi	r30, 0x00	; 0
/home/toolsbuild/workspace/avr8-devices-pack/src/avr-libc/avr/lib/avrxmega3/attiny1624/../../../../libc/misc/eerd_byte.S:85
    25a6:	fc 4e       	sbci	r31, 0xEC	; 236
/home/toolsbuild/workspace/avr8-devices-pack/src/avr-libc/avr/lib/avrxmega3/attiny1624/../../../../libc/misc/eerd_byte.S:87
    25a8:	08 95       	ret

000025aa <__prologue_saves__>:
__prologue_saves__():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2169
    25aa:	2f 92       	push	r2
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2170
    25ac:	3f 92       	push	r3
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2171
    25ae:	4f 92       	push	r4
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2172
    25b0:	5f 92       	push	r5
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2173
    25b2:	6f 92       	push	r6
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2174
    25b4:	7f 92       	push	r7
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2175
    25b6:	8f 92       	push	r8
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2176
    25b8:	9f 92       	push	r9
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2177
    25ba:	af 92       	push	r10
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2178
    25bc:	bf 92       	push	r11
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2179
    25be:	cf 92       	push	r12
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2180
    25c0:	df 92       	push	r13
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2181
    25c2:	ef 92       	push	r14
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2182
    25c4:	ff 92       	push	r15
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2183
    25c6:	0f 93       	push	r16
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2184
    25c8:	1f 93       	push	r17
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2185
    25ca:	cf 93       	push	r28
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2186
    25cc:	df 93       	push	r29
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2193
    25ce:	cd b7       	in	r28, 0x3d	; 61
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2194
    25d0:	de b7       	in	r29, 0x3e	; 62
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2195
    25d2:	ca 1b       	sub	r28, r26
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2196
    25d4:	db 0b       	sbc	r29, r27
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2197
    25d6:	cd bf       	out	0x3d, r28	; 61
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2198
    25d8:	de bf       	out	0x3e, r29	; 62
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2211
    25da:	09 94       	ijmp

000025dc <__epilogue_restores__>:
__epilogue_restores__():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2222
    25dc:	2a 88       	ldd	r2, Y+18	; 0x12
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2223
    25de:	39 88       	ldd	r3, Y+17	; 0x11
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2224
    25e0:	48 88       	ldd	r4, Y+16	; 0x10
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2225
    25e2:	5f 84       	ldd	r5, Y+15	; 0x0f
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2226
    25e4:	6e 84       	ldd	r6, Y+14	; 0x0e
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2227
    25e6:	7d 84       	ldd	r7, Y+13	; 0x0d
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2228
    25e8:	8c 84       	ldd	r8, Y+12	; 0x0c
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2229
    25ea:	9b 84       	ldd	r9, Y+11	; 0x0b
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2230
    25ec:	aa 84       	ldd	r10, Y+10	; 0x0a
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2231
    25ee:	b9 84       	ldd	r11, Y+9	; 0x09
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2232
    25f0:	c8 84       	ldd	r12, Y+8	; 0x08
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2233
    25f2:	df 80       	ldd	r13, Y+7	; 0x07
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2234
    25f4:	ee 80       	ldd	r14, Y+6	; 0x06
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2235
    25f6:	fd 80       	ldd	r15, Y+5	; 0x05
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2236
    25f8:	0c 81       	ldd	r16, Y+4	; 0x04
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2237
    25fa:	1b 81       	ldd	r17, Y+3	; 0x03
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2238
    25fc:	aa 81       	ldd	r26, Y+2	; 0x02
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2245
    25fe:	b9 81       	ldd	r27, Y+1	; 0x01
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2246
    2600:	ce 0f       	add	r28, r30
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2247
    2602:	d1 1d       	adc	r29, r1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2248
    2604:	cd bf       	out	0x3d, r28	; 61
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2249
    2606:	de bf       	out	0x3e, r29	; 62
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2250
    2608:	ed 01       	movw	r28, r26
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2263
    260a:	08 95       	ret

0000260c <__subsf3>:
__subsf3():
    260c:	50 58       	subi	r21, 0x80	; 128

0000260e <__addsf3>:
    260e:	bb 27       	eor	r27, r27
    2610:	aa 27       	eor	r26, r26
    2612:	0e d0       	rcall	.+28     	; 0x2630 <__addsf3x>
    2614:	c2 c1       	rjmp	.+900    	; 0x299a <__fp_round>
__addsf3():
    2616:	b3 d1       	rcall	.+870    	; 0x297e <__fp_pscA>
    2618:	30 f0       	brcs	.+12     	; 0x2626 <__addsf3+0x18>
    261a:	b8 d1       	rcall	.+880    	; 0x298c <__fp_pscB>
    261c:	20 f0       	brcs	.+8      	; 0x2626 <__addsf3+0x18>
    261e:	31 f4       	brne	.+12     	; 0x262c <__addsf3+0x1e>
    2620:	9f 3f       	cpi	r25, 0xFF	; 255
    2622:	11 f4       	brne	.+4      	; 0x2628 <__addsf3+0x1a>
    2624:	1e f4       	brtc	.+6      	; 0x262c <__addsf3+0x1e>
    2626:	98 c1       	rjmp	.+816    	; 0x2958 <__fp_nan>
    2628:	0e f4       	brtc	.+2      	; 0x262c <__addsf3+0x1e>
    262a:	e0 95       	com	r30
    262c:	e7 fb       	bst	r30, 7
    262e:	8e c1       	rjmp	.+796    	; 0x294c <__fp_inf>

00002630 <__addsf3x>:
__addsf3x():
    2630:	e9 2f       	mov	r30, r25
    2632:	c4 d1       	rcall	.+904    	; 0x29bc <__fp_split3>
    2634:	80 f3       	brcs	.-32     	; 0x2616 <__addsf3+0x8>
    2636:	ba 17       	cp	r27, r26
    2638:	62 07       	cpc	r22, r18
    263a:	73 07       	cpc	r23, r19
    263c:	84 07       	cpc	r24, r20
    263e:	95 07       	cpc	r25, r21
    2640:	18 f0       	brcs	.+6      	; 0x2648 <__addsf3x+0x18>
    2642:	71 f4       	brne	.+28     	; 0x2660 <__addsf3x+0x30>
    2644:	9e f5       	brtc	.+102    	; 0x26ac <__addsf3x+0x7c>
    2646:	dc c1       	rjmp	.+952    	; 0x2a00 <__fp_zero>
    2648:	0e f4       	brtc	.+2      	; 0x264c <__addsf3x+0x1c>
    264a:	e0 95       	com	r30
    264c:	0b 2e       	mov	r0, r27
    264e:	ba 2f       	mov	r27, r26
    2650:	a0 2d       	mov	r26, r0
    2652:	0b 01       	movw	r0, r22
    2654:	b9 01       	movw	r22, r18
    2656:	90 01       	movw	r18, r0
    2658:	0c 01       	movw	r0, r24
    265a:	ca 01       	movw	r24, r20
    265c:	a0 01       	movw	r20, r0
    265e:	11 24       	eor	r1, r1
    2660:	ff 27       	eor	r31, r31
    2662:	59 1b       	sub	r21, r25
    2664:	99 f0       	breq	.+38     	; 0x268c <__addsf3x+0x5c>
    2666:	59 3f       	cpi	r21, 0xF9	; 249
    2668:	50 f4       	brcc	.+20     	; 0x267e <__addsf3x+0x4e>
    266a:	50 3e       	cpi	r21, 0xE0	; 224
    266c:	68 f1       	brcs	.+90     	; 0x26c8 <__addsf3x+0x98>
    266e:	1a 16       	cp	r1, r26
    2670:	f0 40       	sbci	r31, 0x00	; 0
    2672:	a2 2f       	mov	r26, r18
    2674:	23 2f       	mov	r18, r19
    2676:	34 2f       	mov	r19, r20
    2678:	44 27       	eor	r20, r20
    267a:	58 5f       	subi	r21, 0xF8	; 248
    267c:	f3 cf       	rjmp	.-26     	; 0x2664 <__addsf3x+0x34>
    267e:	46 95       	lsr	r20
    2680:	37 95       	ror	r19
    2682:	27 95       	ror	r18
    2684:	a7 95       	ror	r26
    2686:	f0 40       	sbci	r31, 0x00	; 0
    2688:	53 95       	inc	r21
    268a:	c9 f7       	brne	.-14     	; 0x267e <__addsf3x+0x4e>
    268c:	7e f4       	brtc	.+30     	; 0x26ac <__addsf3x+0x7c>
    268e:	1f 16       	cp	r1, r31
    2690:	ba 0b       	sbc	r27, r26
    2692:	62 0b       	sbc	r22, r18
    2694:	73 0b       	sbc	r23, r19
    2696:	84 0b       	sbc	r24, r20
    2698:	ba f0       	brmi	.+46     	; 0x26c8 <__addsf3x+0x98>
    269a:	91 50       	subi	r25, 0x01	; 1
    269c:	a1 f0       	breq	.+40     	; 0x26c6 <__addsf3x+0x96>
    269e:	ff 0f       	add	r31, r31
    26a0:	bb 1f       	adc	r27, r27
    26a2:	66 1f       	adc	r22, r22
    26a4:	77 1f       	adc	r23, r23
    26a6:	88 1f       	adc	r24, r24
    26a8:	c2 f7       	brpl	.-16     	; 0x269a <__addsf3x+0x6a>
    26aa:	0e c0       	rjmp	.+28     	; 0x26c8 <__addsf3x+0x98>
    26ac:	ba 0f       	add	r27, r26
    26ae:	62 1f       	adc	r22, r18
    26b0:	73 1f       	adc	r23, r19
    26b2:	84 1f       	adc	r24, r20
    26b4:	48 f4       	brcc	.+18     	; 0x26c8 <__addsf3x+0x98>
    26b6:	87 95       	ror	r24
    26b8:	77 95       	ror	r23
    26ba:	67 95       	ror	r22
    26bc:	b7 95       	ror	r27
    26be:	f7 95       	ror	r31
    26c0:	9e 3f       	cpi	r25, 0xFE	; 254
    26c2:	08 f0       	brcs	.+2      	; 0x26c6 <__addsf3x+0x96>
    26c4:	b3 cf       	rjmp	.-154    	; 0x262c <__addsf3+0x1e>
    26c6:	93 95       	inc	r25
    26c8:	88 0f       	add	r24, r24
    26ca:	08 f0       	brcs	.+2      	; 0x26ce <__addsf3x+0x9e>
    26cc:	99 27       	eor	r25, r25
    26ce:	ee 0f       	add	r30, r30
    26d0:	97 95       	ror	r25
    26d2:	87 95       	ror	r24
    26d4:	08 95       	ret

000026d6 <__cmpsf2>:
    26d6:	16 d1       	rcall	.+556    	; 0x2904 <__fp_cmp>
    26d8:	08 f4       	brcc	.+2      	; 0x26dc <__cmpsf2+0x6>
    26da:	81 e0       	ldi	r24, 0x01	; 1
    26dc:	08 95       	ret

000026de <__divsf3>:
    26de:	0c d0       	rcall	.+24     	; 0x26f8 <__divsf3x>
    26e0:	5c c1       	rjmp	.+696    	; 0x299a <__fp_round>
    26e2:	54 d1       	rcall	.+680    	; 0x298c <__fp_pscB>
    26e4:	40 f0       	brcs	.+16     	; 0x26f6 <__divsf3+0x18>
    26e6:	4b d1       	rcall	.+662    	; 0x297e <__fp_pscA>
    26e8:	30 f0       	brcs	.+12     	; 0x26f6 <__divsf3+0x18>
    26ea:	21 f4       	brne	.+8      	; 0x26f4 <__divsf3+0x16>
    26ec:	5f 3f       	cpi	r21, 0xFF	; 255
    26ee:	19 f0       	breq	.+6      	; 0x26f6 <__divsf3+0x18>
    26f0:	2d c1       	rjmp	.+602    	; 0x294c <__fp_inf>
    26f2:	51 11       	cpse	r21, r1
    26f4:	86 c1       	rjmp	.+780    	; 0x2a02 <__fp_szero>
    26f6:	30 c1       	rjmp	.+608    	; 0x2958 <__fp_nan>

000026f8 <__divsf3x>:
    26f8:	61 d1       	rcall	.+706    	; 0x29bc <__fp_split3>
    26fa:	98 f3       	brcs	.-26     	; 0x26e2 <__divsf3+0x4>

000026fc <__divsf3_pse>:
__divsf3_pse():
    26fc:	99 23       	and	r25, r25
    26fe:	c9 f3       	breq	.-14     	; 0x26f2 <__divsf3+0x14>
    2700:	55 23       	and	r21, r21
    2702:	b1 f3       	breq	.-20     	; 0x26f0 <__divsf3+0x12>
    2704:	95 1b       	sub	r25, r21
    2706:	55 0b       	sbc	r21, r21
    2708:	bb 27       	eor	r27, r27
    270a:	aa 27       	eor	r26, r26
    270c:	62 17       	cp	r22, r18
    270e:	73 07       	cpc	r23, r19
    2710:	84 07       	cpc	r24, r20
    2712:	38 f0       	brcs	.+14     	; 0x2722 <__divsf3_pse+0x26>
    2714:	9f 5f       	subi	r25, 0xFF	; 255
    2716:	5f 4f       	sbci	r21, 0xFF	; 255
    2718:	22 0f       	add	r18, r18
    271a:	33 1f       	adc	r19, r19
    271c:	44 1f       	adc	r20, r20
    271e:	aa 1f       	adc	r26, r26
    2720:	a9 f3       	breq	.-22     	; 0x270c <__divsf3_pse+0x10>
    2722:	33 d0       	rcall	.+102    	; 0x278a <__divsf3_pse+0x8e>
    2724:	0e 2e       	mov	r0, r30
    2726:	3a f0       	brmi	.+14     	; 0x2736 <__divsf3_pse+0x3a>
    2728:	e0 e8       	ldi	r30, 0x80	; 128
    272a:	30 d0       	rcall	.+96     	; 0x278c <__divsf3_pse+0x90>
    272c:	91 50       	subi	r25, 0x01	; 1
    272e:	50 40       	sbci	r21, 0x00	; 0
    2730:	e6 95       	lsr	r30
    2732:	00 1c       	adc	r0, r0
    2734:	ca f7       	brpl	.-14     	; 0x2728 <__divsf3_pse+0x2c>
    2736:	29 d0       	rcall	.+82     	; 0x278a <__divsf3_pse+0x8e>
    2738:	fe 2f       	mov	r31, r30
    273a:	27 d0       	rcall	.+78     	; 0x278a <__divsf3_pse+0x8e>
    273c:	66 0f       	add	r22, r22
    273e:	77 1f       	adc	r23, r23
    2740:	88 1f       	adc	r24, r24
    2742:	bb 1f       	adc	r27, r27
    2744:	26 17       	cp	r18, r22
    2746:	37 07       	cpc	r19, r23
    2748:	48 07       	cpc	r20, r24
    274a:	ab 07       	cpc	r26, r27
    274c:	b0 e8       	ldi	r27, 0x80	; 128
    274e:	09 f0       	breq	.+2      	; 0x2752 <__divsf3_pse+0x56>
    2750:	bb 0b       	sbc	r27, r27
    2752:	80 2d       	mov	r24, r0
    2754:	bf 01       	movw	r22, r30
    2756:	ff 27       	eor	r31, r31
    2758:	93 58       	subi	r25, 0x83	; 131
    275a:	5f 4f       	sbci	r21, 0xFF	; 255
    275c:	2a f0       	brmi	.+10     	; 0x2768 <__divsf3_pse+0x6c>
    275e:	9e 3f       	cpi	r25, 0xFE	; 254
    2760:	51 05       	cpc	r21, r1
    2762:	68 f0       	brcs	.+26     	; 0x277e <__divsf3_pse+0x82>
    2764:	f3 c0       	rjmp	.+486    	; 0x294c <__fp_inf>
    2766:	4d c1       	rjmp	.+666    	; 0x2a02 <__fp_szero>
    2768:	5f 3f       	cpi	r21, 0xFF	; 255
    276a:	ec f3       	brlt	.-6      	; 0x2766 <__divsf3_pse+0x6a>
    276c:	98 3e       	cpi	r25, 0xE8	; 232
    276e:	dc f3       	brlt	.-10     	; 0x2766 <__divsf3_pse+0x6a>
    2770:	86 95       	lsr	r24
    2772:	77 95       	ror	r23
    2774:	67 95       	ror	r22
    2776:	b7 95       	ror	r27
    2778:	f7 95       	ror	r31
    277a:	9f 5f       	subi	r25, 0xFF	; 255
    277c:	c9 f7       	brne	.-14     	; 0x2770 <__divsf3_pse+0x74>
    277e:	88 0f       	add	r24, r24
    2780:	91 1d       	adc	r25, r1
    2782:	96 95       	lsr	r25
    2784:	87 95       	ror	r24
    2786:	97 f9       	bld	r25, 7
    2788:	08 95       	ret
    278a:	e1 e0       	ldi	r30, 0x01	; 1
    278c:	66 0f       	add	r22, r22
    278e:	77 1f       	adc	r23, r23
    2790:	88 1f       	adc	r24, r24
    2792:	bb 1f       	adc	r27, r27
    2794:	62 17       	cp	r22, r18
    2796:	73 07       	cpc	r23, r19
    2798:	84 07       	cpc	r24, r20
    279a:	ba 07       	cpc	r27, r26
    279c:	20 f0       	brcs	.+8      	; 0x27a6 <__divsf3_pse+0xaa>
    279e:	62 1b       	sub	r22, r18
    27a0:	73 0b       	sbc	r23, r19
    27a2:	84 0b       	sbc	r24, r20
    27a4:	ba 0b       	sbc	r27, r26
    27a6:	ee 1f       	adc	r30, r30
    27a8:	88 f7       	brcc	.-30     	; 0x278c <__divsf3_pse+0x90>
    27aa:	e0 95       	com	r30
    27ac:	08 95       	ret

000027ae <__fixunssfsi>:
__fixunssfsi():
    27ae:	0e d1       	rcall	.+540    	; 0x29cc <__fp_splitA>
    27b0:	88 f0       	brcs	.+34     	; 0x27d4 <__fixunssfsi+0x26>
    27b2:	9f 57       	subi	r25, 0x7F	; 127
    27b4:	90 f0       	brcs	.+36     	; 0x27da <__fixunssfsi+0x2c>
    27b6:	b9 2f       	mov	r27, r25
    27b8:	99 27       	eor	r25, r25
    27ba:	b7 51       	subi	r27, 0x17	; 23
    27bc:	a0 f0       	brcs	.+40     	; 0x27e6 <__fixunssfsi+0x38>
    27be:	d1 f0       	breq	.+52     	; 0x27f4 <__fixunssfsi+0x46>
    27c0:	66 0f       	add	r22, r22
    27c2:	77 1f       	adc	r23, r23
    27c4:	88 1f       	adc	r24, r24
    27c6:	99 1f       	adc	r25, r25
    27c8:	1a f0       	brmi	.+6      	; 0x27d0 <__fixunssfsi+0x22>
    27ca:	ba 95       	dec	r27
    27cc:	c9 f7       	brne	.-14     	; 0x27c0 <__fixunssfsi+0x12>
    27ce:	12 c0       	rjmp	.+36     	; 0x27f4 <__fixunssfsi+0x46>
    27d0:	b1 30       	cpi	r27, 0x01	; 1
    27d2:	81 f0       	breq	.+32     	; 0x27f4 <__fixunssfsi+0x46>
    27d4:	15 d1       	rcall	.+554    	; 0x2a00 <__fp_zero>
    27d6:	b1 e0       	ldi	r27, 0x01	; 1
    27d8:	08 95       	ret
    27da:	12 c1       	rjmp	.+548    	; 0x2a00 <__fp_zero>
    27dc:	67 2f       	mov	r22, r23
    27de:	78 2f       	mov	r23, r24
    27e0:	88 27       	eor	r24, r24
    27e2:	b8 5f       	subi	r27, 0xF8	; 248
    27e4:	39 f0       	breq	.+14     	; 0x27f4 <__fixunssfsi+0x46>
    27e6:	b9 3f       	cpi	r27, 0xF9	; 249
    27e8:	cc f3       	brlt	.-14     	; 0x27dc <__fixunssfsi+0x2e>
    27ea:	86 95       	lsr	r24
    27ec:	77 95       	ror	r23
    27ee:	67 95       	ror	r22
    27f0:	b3 95       	inc	r27
    27f2:	d9 f7       	brne	.-10     	; 0x27ea <__fixunssfsi+0x3c>
    27f4:	3e f4       	brtc	.+14     	; 0x2804 <__fixunssfsi+0x56>
    27f6:	90 95       	com	r25
    27f8:	80 95       	com	r24
    27fa:	70 95       	com	r23
    27fc:	61 95       	neg	r22
    27fe:	7f 4f       	sbci	r23, 0xFF	; 255
    2800:	8f 4f       	sbci	r24, 0xFF	; 255
    2802:	9f 4f       	sbci	r25, 0xFF	; 255
    2804:	08 95       	ret

00002806 <__floatdisf>:
__floatdisf():
    2806:	97 fb       	bst	r25, 7
    2808:	0e f4       	brtc	.+2      	; 0x280c <__floatdisf+0x6>
    280a:	a9 d0       	rcall	.+338    	; 0x295e <__fp_negdi>
    280c:	3e c0       	rjmp	.+124    	; 0x288a <__fp_di2sf>

0000280e <__floatunsisf>:
__floatunsisf():
    280e:	e8 94       	clt
    2810:	09 c0       	rjmp	.+18     	; 0x2824 <__floatsisf+0x12>

00002812 <__floatsisf>:
    2812:	97 fb       	bst	r25, 7
    2814:	3e f4       	brtc	.+14     	; 0x2824 <__floatsisf+0x12>
    2816:	90 95       	com	r25
    2818:	80 95       	com	r24
    281a:	70 95       	com	r23
    281c:	61 95       	neg	r22
    281e:	7f 4f       	sbci	r23, 0xFF	; 255
    2820:	8f 4f       	sbci	r24, 0xFF	; 255
    2822:	9f 4f       	sbci	r25, 0xFF	; 255
    2824:	99 23       	and	r25, r25
    2826:	a9 f0       	breq	.+42     	; 0x2852 <__floatsisf+0x40>
    2828:	f9 2f       	mov	r31, r25
    282a:	96 e9       	ldi	r25, 0x96	; 150
    282c:	bb 27       	eor	r27, r27
    282e:	93 95       	inc	r25
    2830:	f6 95       	lsr	r31
    2832:	87 95       	ror	r24
    2834:	77 95       	ror	r23
    2836:	67 95       	ror	r22
    2838:	b7 95       	ror	r27
    283a:	f1 11       	cpse	r31, r1
    283c:	f8 cf       	rjmp	.-16     	; 0x282e <__floatsisf+0x1c>
    283e:	fa f4       	brpl	.+62     	; 0x287e <__floatsisf+0x6c>
    2840:	bb 0f       	add	r27, r27
    2842:	11 f4       	brne	.+4      	; 0x2848 <__floatsisf+0x36>
    2844:	60 ff       	sbrs	r22, 0
    2846:	1b c0       	rjmp	.+54     	; 0x287e <__floatsisf+0x6c>
    2848:	6f 5f       	subi	r22, 0xFF	; 255
    284a:	7f 4f       	sbci	r23, 0xFF	; 255
    284c:	8f 4f       	sbci	r24, 0xFF	; 255
    284e:	9f 4f       	sbci	r25, 0xFF	; 255
    2850:	16 c0       	rjmp	.+44     	; 0x287e <__floatsisf+0x6c>
    2852:	88 23       	and	r24, r24
    2854:	11 f0       	breq	.+4      	; 0x285a <__floatsisf+0x48>
    2856:	96 e9       	ldi	r25, 0x96	; 150
    2858:	11 c0       	rjmp	.+34     	; 0x287c <__floatsisf+0x6a>
    285a:	77 23       	and	r23, r23
    285c:	21 f0       	breq	.+8      	; 0x2866 <__floatsisf+0x54>
    285e:	9e e8       	ldi	r25, 0x8E	; 142
    2860:	87 2f       	mov	r24, r23
    2862:	76 2f       	mov	r23, r22
    2864:	05 c0       	rjmp	.+10     	; 0x2870 <__floatsisf+0x5e>
    2866:	66 23       	and	r22, r22
    2868:	71 f0       	breq	.+28     	; 0x2886 <__floatsisf+0x74>
    286a:	96 e8       	ldi	r25, 0x86	; 134
    286c:	86 2f       	mov	r24, r22
    286e:	70 e0       	ldi	r23, 0x00	; 0
    2870:	60 e0       	ldi	r22, 0x00	; 0
    2872:	2a f0       	brmi	.+10     	; 0x287e <__floatsisf+0x6c>
    2874:	9a 95       	dec	r25
    2876:	66 0f       	add	r22, r22
    2878:	77 1f       	adc	r23, r23
    287a:	88 1f       	adc	r24, r24
    287c:	da f7       	brpl	.-10     	; 0x2874 <__floatsisf+0x62>
    287e:	88 0f       	add	r24, r24
    2880:	96 95       	lsr	r25
    2882:	87 95       	ror	r24
    2884:	97 f9       	bld	r25, 7
    2886:	08 95       	ret

00002888 <__floatundisf>:
__floatundisf():
    2888:	e8 94       	clt

0000288a <__fp_di2sf>:
    288a:	f9 2f       	mov	r31, r25
    288c:	96 eb       	ldi	r25, 0xB6	; 182
    288e:	ff 23       	and	r31, r31
    2890:	81 f0       	breq	.+32     	; 0x28b2 <__fp_di2sf+0x28>
    2892:	12 16       	cp	r1, r18
    2894:	13 06       	cpc	r1, r19
    2896:	14 06       	cpc	r1, r20
    2898:	44 0b       	sbc	r20, r20
    289a:	93 95       	inc	r25
    289c:	f6 95       	lsr	r31
    289e:	87 95       	ror	r24
    28a0:	77 95       	ror	r23
    28a2:	67 95       	ror	r22
    28a4:	57 95       	ror	r21
    28a6:	40 40       	sbci	r20, 0x00	; 0
    28a8:	ff 23       	and	r31, r31
    28aa:	b9 f7       	brne	.-18     	; 0x289a <__fp_di2sf+0x10>
    28ac:	1b c0       	rjmp	.+54     	; 0x28e4 <__fp_di2sf+0x5a>
    28ae:	99 27       	eor	r25, r25
    28b0:	08 95       	ret
    28b2:	88 23       	and	r24, r24
    28b4:	51 f4       	brne	.+20     	; 0x28ca <__fp_di2sf+0x40>
    28b6:	98 50       	subi	r25, 0x08	; 8
    28b8:	d2 f7       	brpl	.-12     	; 0x28ae <__fp_di2sf+0x24>
    28ba:	87 2b       	or	r24, r23
    28bc:	76 2f       	mov	r23, r22
    28be:	65 2f       	mov	r22, r21
    28c0:	54 2f       	mov	r21, r20
    28c2:	43 2f       	mov	r20, r19
    28c4:	32 2f       	mov	r19, r18
    28c6:	20 e0       	ldi	r18, 0x00	; 0
    28c8:	b1 f3       	breq	.-20     	; 0x28b6 <__fp_di2sf+0x2c>
    28ca:	12 16       	cp	r1, r18
    28cc:	13 06       	cpc	r1, r19
    28ce:	14 06       	cpc	r1, r20
    28d0:	44 0b       	sbc	r20, r20
    28d2:	88 23       	and	r24, r24
    28d4:	3a f0       	brmi	.+14     	; 0x28e4 <__fp_di2sf+0x5a>
    28d6:	9a 95       	dec	r25
    28d8:	44 0f       	add	r20, r20
    28da:	55 1f       	adc	r21, r21
    28dc:	66 1f       	adc	r22, r22
    28de:	77 1f       	adc	r23, r23
    28e0:	88 1f       	adc	r24, r24
    28e2:	ca f7       	brpl	.-14     	; 0x28d6 <__fp_di2sf+0x4c>
    28e4:	55 23       	and	r21, r21
    28e6:	4a f4       	brpl	.+18     	; 0x28fa <__fp_di2sf+0x70>
    28e8:	44 0f       	add	r20, r20
    28ea:	55 1f       	adc	r21, r21
    28ec:	11 f4       	brne	.+4      	; 0x28f2 <__fp_di2sf+0x68>
    28ee:	60 ff       	sbrs	r22, 0
    28f0:	04 c0       	rjmp	.+8      	; 0x28fa <__fp_di2sf+0x70>
    28f2:	6f 5f       	subi	r22, 0xFF	; 255
    28f4:	7f 4f       	sbci	r23, 0xFF	; 255
    28f6:	8f 4f       	sbci	r24, 0xFF	; 255
    28f8:	9f 4f       	sbci	r25, 0xFF	; 255
    28fa:	88 0f       	add	r24, r24
    28fc:	96 95       	lsr	r25
    28fe:	87 95       	ror	r24
    2900:	97 f9       	bld	r25, 7
    2902:	08 95       	ret

00002904 <__fp_cmp>:
__fp_cmp():
    2904:	99 0f       	add	r25, r25
    2906:	00 08       	sbc	r0, r0
    2908:	55 0f       	add	r21, r21
    290a:	aa 0b       	sbc	r26, r26
    290c:	e0 e8       	ldi	r30, 0x80	; 128
    290e:	fe ef       	ldi	r31, 0xFE	; 254
    2910:	16 16       	cp	r1, r22
    2912:	17 06       	cpc	r1, r23
    2914:	e8 07       	cpc	r30, r24
    2916:	f9 07       	cpc	r31, r25
    2918:	c0 f0       	brcs	.+48     	; 0x294a <__fp_cmp+0x46>
    291a:	12 16       	cp	r1, r18
    291c:	13 06       	cpc	r1, r19
    291e:	e4 07       	cpc	r30, r20
    2920:	f5 07       	cpc	r31, r21
    2922:	98 f0       	brcs	.+38     	; 0x294a <__fp_cmp+0x46>
    2924:	62 1b       	sub	r22, r18
    2926:	73 0b       	sbc	r23, r19
    2928:	84 0b       	sbc	r24, r20
    292a:	95 0b       	sbc	r25, r21
    292c:	39 f4       	brne	.+14     	; 0x293c <__fp_cmp+0x38>
    292e:	0a 26       	eor	r0, r26
    2930:	61 f0       	breq	.+24     	; 0x294a <__fp_cmp+0x46>
    2932:	23 2b       	or	r18, r19
    2934:	24 2b       	or	r18, r20
    2936:	25 2b       	or	r18, r21
    2938:	21 f4       	brne	.+8      	; 0x2942 <__fp_cmp+0x3e>
    293a:	08 95       	ret
    293c:	0a 26       	eor	r0, r26
    293e:	09 f4       	brne	.+2      	; 0x2942 <__fp_cmp+0x3e>
    2940:	a1 40       	sbci	r26, 0x01	; 1
    2942:	a6 95       	lsr	r26
    2944:	8f ef       	ldi	r24, 0xFF	; 255
    2946:	81 1d       	adc	r24, r1
    2948:	81 1d       	adc	r24, r1
    294a:	08 95       	ret

0000294c <__fp_inf>:
__fp_inf():
    294c:	97 f9       	bld	r25, 7
    294e:	9f 67       	ori	r25, 0x7F	; 127
    2950:	80 e8       	ldi	r24, 0x80	; 128
    2952:	70 e0       	ldi	r23, 0x00	; 0
    2954:	60 e0       	ldi	r22, 0x00	; 0
    2956:	08 95       	ret

00002958 <__fp_nan>:
__fp_nan():
    2958:	9f ef       	ldi	r25, 0xFF	; 255
    295a:	80 ec       	ldi	r24, 0xC0	; 192
    295c:	08 95       	ret

0000295e <__fp_negdi>:
__fp_negdi():
    295e:	90 95       	com	r25
    2960:	80 95       	com	r24
    2962:	70 95       	com	r23
    2964:	60 95       	com	r22
    2966:	50 95       	com	r21
    2968:	40 95       	com	r20
    296a:	30 95       	com	r19
    296c:	21 95       	neg	r18
    296e:	3f 4f       	sbci	r19, 0xFF	; 255
    2970:	4f 4f       	sbci	r20, 0xFF	; 255
    2972:	5f 4f       	sbci	r21, 0xFF	; 255
    2974:	6f 4f       	sbci	r22, 0xFF	; 255
    2976:	7f 4f       	sbci	r23, 0xFF	; 255
    2978:	8f 4f       	sbci	r24, 0xFF	; 255
    297a:	9f 4f       	sbci	r25, 0xFF	; 255
    297c:	08 95       	ret

0000297e <__fp_pscA>:
__fp_pscA():
    297e:	00 24       	eor	r0, r0
    2980:	0a 94       	dec	r0
    2982:	16 16       	cp	r1, r22
    2984:	17 06       	cpc	r1, r23
    2986:	18 06       	cpc	r1, r24
    2988:	09 06       	cpc	r0, r25
    298a:	08 95       	ret

0000298c <__fp_pscB>:
__fp_pscB():
    298c:	00 24       	eor	r0, r0
    298e:	0a 94       	dec	r0
    2990:	12 16       	cp	r1, r18
    2992:	13 06       	cpc	r1, r19
    2994:	14 06       	cpc	r1, r20
    2996:	05 06       	cpc	r0, r21
    2998:	08 95       	ret

0000299a <__fp_round>:
__fp_round():
    299a:	09 2e       	mov	r0, r25
    299c:	03 94       	inc	r0
    299e:	00 0c       	add	r0, r0
    29a0:	11 f4       	brne	.+4      	; 0x29a6 <__fp_round+0xc>
    29a2:	88 23       	and	r24, r24
    29a4:	52 f0       	brmi	.+20     	; 0x29ba <__fp_round+0x20>
    29a6:	bb 0f       	add	r27, r27
    29a8:	40 f4       	brcc	.+16     	; 0x29ba <__fp_round+0x20>
    29aa:	bf 2b       	or	r27, r31
    29ac:	11 f4       	brne	.+4      	; 0x29b2 <__fp_round+0x18>
    29ae:	60 ff       	sbrs	r22, 0
    29b0:	04 c0       	rjmp	.+8      	; 0x29ba <__fp_round+0x20>
    29b2:	6f 5f       	subi	r22, 0xFF	; 255
    29b4:	7f 4f       	sbci	r23, 0xFF	; 255
    29b6:	8f 4f       	sbci	r24, 0xFF	; 255
    29b8:	9f 4f       	sbci	r25, 0xFF	; 255
    29ba:	08 95       	ret

000029bc <__fp_split3>:
__fp_split3():
    29bc:	57 fd       	sbrc	r21, 7
    29be:	90 58       	subi	r25, 0x80	; 128
    29c0:	44 0f       	add	r20, r20
    29c2:	55 1f       	adc	r21, r21
    29c4:	59 f0       	breq	.+22     	; 0x29dc <__fp_splitA+0x10>
    29c6:	5f 3f       	cpi	r21, 0xFF	; 255
    29c8:	71 f0       	breq	.+28     	; 0x29e6 <__fp_splitA+0x1a>
    29ca:	47 95       	ror	r20

000029cc <__fp_splitA>:
    29cc:	88 0f       	add	r24, r24
    29ce:	97 fb       	bst	r25, 7
    29d0:	99 1f       	adc	r25, r25
    29d2:	61 f0       	breq	.+24     	; 0x29ec <__fp_splitA+0x20>
    29d4:	9f 3f       	cpi	r25, 0xFF	; 255
    29d6:	79 f0       	breq	.+30     	; 0x29f6 <__fp_splitA+0x2a>
    29d8:	87 95       	ror	r24
    29da:	08 95       	ret
    29dc:	12 16       	cp	r1, r18
    29de:	13 06       	cpc	r1, r19
    29e0:	14 06       	cpc	r1, r20
    29e2:	55 1f       	adc	r21, r21
    29e4:	f2 cf       	rjmp	.-28     	; 0x29ca <__fp_split3+0xe>
    29e6:	46 95       	lsr	r20
    29e8:	f1 df       	rcall	.-30     	; 0x29cc <__fp_splitA>
    29ea:	08 c0       	rjmp	.+16     	; 0x29fc <__fp_splitA+0x30>
    29ec:	16 16       	cp	r1, r22
    29ee:	17 06       	cpc	r1, r23
    29f0:	18 06       	cpc	r1, r24
    29f2:	99 1f       	adc	r25, r25
    29f4:	f1 cf       	rjmp	.-30     	; 0x29d8 <__fp_splitA+0xc>
    29f6:	86 95       	lsr	r24
    29f8:	71 05       	cpc	r23, r1
    29fa:	61 05       	cpc	r22, r1
    29fc:	08 94       	sec
    29fe:	08 95       	ret

00002a00 <__fp_zero>:
__fp_zero():
    2a00:	e8 94       	clt

00002a02 <__fp_szero>:
    2a02:	bb 27       	eor	r27, r27
    2a04:	66 27       	eor	r22, r22
    2a06:	77 27       	eor	r23, r23
    2a08:	cb 01       	movw	r24, r22
    2a0a:	97 f9       	bld	r25, 7
    2a0c:	08 95       	ret

00002a0e <__gesf2>:
__gesf2():
    2a0e:	7a df       	rcall	.-268    	; 0x2904 <__fp_cmp>
    2a10:	08 f4       	brcc	.+2      	; 0x2a14 <__gesf2+0x6>
    2a12:	8f ef       	ldi	r24, 0xFF	; 255
    2a14:	08 95       	ret

00002a16 <__mulsf3>:
__mulsf3():
    2a16:	0b d0       	rcall	.+22     	; 0x2a2e <__mulsf3x>
    2a18:	c0 cf       	rjmp	.-128    	; 0x299a <__fp_round>
    2a1a:	b1 df       	rcall	.-158    	; 0x297e <__fp_pscA>
    2a1c:	28 f0       	brcs	.+10     	; 0x2a28 <__mulsf3+0x12>
    2a1e:	b6 df       	rcall	.-148    	; 0x298c <__fp_pscB>
    2a20:	18 f0       	brcs	.+6      	; 0x2a28 <__mulsf3+0x12>
    2a22:	95 23       	and	r25, r21
    2a24:	09 f0       	breq	.+2      	; 0x2a28 <__mulsf3+0x12>
    2a26:	92 cf       	rjmp	.-220    	; 0x294c <__fp_inf>
    2a28:	97 cf       	rjmp	.-210    	; 0x2958 <__fp_nan>
    2a2a:	11 24       	eor	r1, r1
    2a2c:	ea cf       	rjmp	.-44     	; 0x2a02 <__fp_szero>

00002a2e <__mulsf3x>:
__mulsf3x():
    2a2e:	c6 df       	rcall	.-116    	; 0x29bc <__fp_split3>
    2a30:	a0 f3       	brcs	.-24     	; 0x2a1a <__mulsf3+0x4>

00002a32 <__mulsf3_pse>:
    2a32:	95 9f       	mul	r25, r21
    2a34:	d1 f3       	breq	.-12     	; 0x2a2a <__mulsf3+0x14>
    2a36:	95 0f       	add	r25, r21
    2a38:	50 e0       	ldi	r21, 0x00	; 0
    2a3a:	55 1f       	adc	r21, r21
    2a3c:	62 9f       	mul	r22, r18
    2a3e:	f0 01       	movw	r30, r0
    2a40:	72 9f       	mul	r23, r18
    2a42:	bb 27       	eor	r27, r27
    2a44:	f0 0d       	add	r31, r0
    2a46:	b1 1d       	adc	r27, r1
    2a48:	63 9f       	mul	r22, r19
    2a4a:	aa 27       	eor	r26, r26
    2a4c:	f0 0d       	add	r31, r0
    2a4e:	b1 1d       	adc	r27, r1
    2a50:	aa 1f       	adc	r26, r26
    2a52:	64 9f       	mul	r22, r20
    2a54:	66 27       	eor	r22, r22
    2a56:	b0 0d       	add	r27, r0
    2a58:	a1 1d       	adc	r26, r1
    2a5a:	66 1f       	adc	r22, r22
    2a5c:	82 9f       	mul	r24, r18
    2a5e:	22 27       	eor	r18, r18
    2a60:	b0 0d       	add	r27, r0
    2a62:	a1 1d       	adc	r26, r1
    2a64:	62 1f       	adc	r22, r18
    2a66:	73 9f       	mul	r23, r19
    2a68:	b0 0d       	add	r27, r0
    2a6a:	a1 1d       	adc	r26, r1
    2a6c:	62 1f       	adc	r22, r18
    2a6e:	83 9f       	mul	r24, r19
    2a70:	a0 0d       	add	r26, r0
    2a72:	61 1d       	adc	r22, r1
    2a74:	22 1f       	adc	r18, r18
    2a76:	74 9f       	mul	r23, r20
    2a78:	33 27       	eor	r19, r19
    2a7a:	a0 0d       	add	r26, r0
    2a7c:	61 1d       	adc	r22, r1
    2a7e:	23 1f       	adc	r18, r19
    2a80:	84 9f       	mul	r24, r20
    2a82:	60 0d       	add	r22, r0
    2a84:	21 1d       	adc	r18, r1
    2a86:	82 2f       	mov	r24, r18
    2a88:	76 2f       	mov	r23, r22
    2a8a:	6a 2f       	mov	r22, r26
    2a8c:	11 24       	eor	r1, r1
    2a8e:	9f 57       	subi	r25, 0x7F	; 127
    2a90:	50 40       	sbci	r21, 0x00	; 0
    2a92:	8a f0       	brmi	.+34     	; 0x2ab6 <__mulsf3_pse+0x84>
    2a94:	e1 f0       	breq	.+56     	; 0x2ace <__mulsf3_pse+0x9c>
    2a96:	88 23       	and	r24, r24
    2a98:	4a f0       	brmi	.+18     	; 0x2aac <__mulsf3_pse+0x7a>
    2a9a:	ee 0f       	add	r30, r30
    2a9c:	ff 1f       	adc	r31, r31
    2a9e:	bb 1f       	adc	r27, r27
    2aa0:	66 1f       	adc	r22, r22
    2aa2:	77 1f       	adc	r23, r23
    2aa4:	88 1f       	adc	r24, r24
    2aa6:	91 50       	subi	r25, 0x01	; 1
    2aa8:	50 40       	sbci	r21, 0x00	; 0
    2aaa:	a9 f7       	brne	.-22     	; 0x2a96 <__mulsf3_pse+0x64>
    2aac:	9e 3f       	cpi	r25, 0xFE	; 254
    2aae:	51 05       	cpc	r21, r1
    2ab0:	70 f0       	brcs	.+28     	; 0x2ace <__mulsf3_pse+0x9c>
    2ab2:	4c cf       	rjmp	.-360    	; 0x294c <__fp_inf>
    2ab4:	a6 cf       	rjmp	.-180    	; 0x2a02 <__fp_szero>
    2ab6:	5f 3f       	cpi	r21, 0xFF	; 255
    2ab8:	ec f3       	brlt	.-6      	; 0x2ab4 <__mulsf3_pse+0x82>
    2aba:	98 3e       	cpi	r25, 0xE8	; 232
    2abc:	dc f3       	brlt	.-10     	; 0x2ab4 <__mulsf3_pse+0x82>
    2abe:	86 95       	lsr	r24
    2ac0:	77 95       	ror	r23
    2ac2:	67 95       	ror	r22
    2ac4:	b7 95       	ror	r27
    2ac6:	f7 95       	ror	r31
    2ac8:	e7 95       	ror	r30
    2aca:	9f 5f       	subi	r25, 0xFF	; 255
    2acc:	c1 f7       	brne	.-16     	; 0x2abe <__mulsf3_pse+0x8c>
    2ace:	fe 2b       	or	r31, r30
    2ad0:	88 0f       	add	r24, r24
    2ad2:	91 1d       	adc	r25, r1
    2ad4:	96 95       	lsr	r25
    2ad6:	87 95       	ror	r24
    2ad8:	97 f9       	bld	r25, 7
    2ada:	08 95       	ret

00002adc <pow>:
    2adc:	fa 01       	movw	r30, r20
    2ade:	ee 0f       	add	r30, r30
    2ae0:	ff 1f       	adc	r31, r31
    2ae2:	30 96       	adiw	r30, 0x00	; 0
    2ae4:	21 05       	cpc	r18, r1
    2ae6:	31 05       	cpc	r19, r1
    2ae8:	99 f1       	breq	.+102    	; 0x2b50 <pow+0x74>
    2aea:	61 15       	cp	r22, r1
    2aec:	71 05       	cpc	r23, r1
    2aee:	61 f4       	brne	.+24     	; 0x2b08 <pow+0x2c>
    2af0:	80 38       	cpi	r24, 0x80	; 128
    2af2:	bf e3       	ldi	r27, 0x3F	; 63
    2af4:	9b 07       	cpc	r25, r27
    2af6:	49 f1       	breq	.+82     	; 0x2b4a <pow+0x6e>
    2af8:	68 94       	set
    2afa:	90 38       	cpi	r25, 0x80	; 128
    2afc:	81 05       	cpc	r24, r1
    2afe:	61 f0       	breq	.+24     	; 0x2b18 <pow+0x3c>
pow():
    2b00:	80 38       	cpi	r24, 0x80	; 128
    2b02:	bf ef       	ldi	r27, 0xFF	; 255
    2b04:	9b 07       	cpc	r25, r27
    2b06:	41 f0       	breq	.+16     	; 0x2b18 <pow+0x3c>
    2b08:	99 23       	and	r25, r25
    2b0a:	42 f5       	brpl	.+80     	; 0x2b5c <pow+0x80>
    2b0c:	ff 3f       	cpi	r31, 0xFF	; 255
    2b0e:	e1 05       	cpc	r30, r1
    2b10:	31 05       	cpc	r19, r1
    2b12:	21 05       	cpc	r18, r1
    2b14:	11 f1       	breq	.+68     	; 0x2b5a <pow+0x7e>
    2b16:	e8 94       	clt
    2b18:	08 94       	sec
    2b1a:	e7 95       	ror	r30
    2b1c:	d9 01       	movw	r26, r18
    2b1e:	aa 23       	and	r26, r26
    2b20:	29 f4       	brne	.+10     	; 0x2b2c <pow+0x50>
    2b22:	ab 2f       	mov	r26, r27
    2b24:	be 2f       	mov	r27, r30
    2b26:	f8 5f       	subi	r31, 0xF8	; 248
    2b28:	d0 f3       	brcs	.-12     	; 0x2b1e <pow+0x42>
    2b2a:	10 c0       	rjmp	.+32     	; 0x2b4c <pow+0x70>
    2b2c:	ff 5f       	subi	r31, 0xFF	; 255
    2b2e:	70 f4       	brcc	.+28     	; 0x2b4c <pow+0x70>
    2b30:	a6 95       	lsr	r26
    2b32:	e0 f7       	brcc	.-8      	; 0x2b2c <pow+0x50>
    2b34:	f7 39       	cpi	r31, 0x97	; 151
    2b36:	50 f0       	brcs	.+20     	; 0x2b4c <pow+0x70>
    2b38:	19 f0       	breq	.+6      	; 0x2b40 <pow+0x64>
    2b3a:	ff 3a       	cpi	r31, 0xAF	; 175
    2b3c:	38 f4       	brcc	.+14     	; 0x2b4c <pow+0x70>
    2b3e:	9f 77       	andi	r25, 0x7F	; 127
    2b40:	9f 93       	push	r25
    2b42:	0c d0       	rcall	.+24     	; 0x2b5c <pow+0x80>
    2b44:	0f 90       	pop	r0
    2b46:	07 fc       	sbrc	r0, 7
    2b48:	90 58       	subi	r25, 0x80	; 128
    2b4a:	08 95       	ret
    2b4c:	3e f0       	brts	.+14     	; 0x2b5c <pow+0x80>
    2b4e:	04 cf       	rjmp	.-504    	; 0x2958 <__fp_nan>
    2b50:	60 e0       	ldi	r22, 0x00	; 0
    2b52:	70 e0       	ldi	r23, 0x00	; 0
    2b54:	80 e8       	ldi	r24, 0x80	; 128
    2b56:	9f e3       	ldi	r25, 0x3F	; 63
    2b58:	08 95       	ret
    2b5a:	4f e7       	ldi	r20, 0x7F	; 127
    2b5c:	9f 77       	andi	r25, 0x7F	; 127
    2b5e:	5f 93       	push	r21
    2b60:	4f 93       	push	r20
    2b62:	3f 93       	push	r19
    2b64:	2f 93       	push	r18
    2b66:	a2 d0       	rcall	.+324    	; 0x2cac <log>
    2b68:	2f 91       	pop	r18
    2b6a:	3f 91       	pop	r19
    2b6c:	4f 91       	pop	r20
    2b6e:	5f 91       	pop	r21
    2b70:	52 df       	rcall	.-348    	; 0x2a16 <__mulsf3>
    2b72:	09 c0       	rjmp	.+18     	; 0x2b86 <exp>

00002b74 <__unordsf2>:
__unordsf2():
    2b74:	c7 de       	rcall	.-626    	; 0x2904 <__fp_cmp>
    2b76:	88 0b       	sbc	r24, r24
    2b78:	99 0b       	sbc	r25, r25
    2b7a:	08 95       	ret
    2b7c:	19 f4       	brne	.+6      	; 0x2b84 <__unordsf2+0x10>
    2b7e:	0e f0       	brts	.+2      	; 0x2b82 <__unordsf2+0xe>
    2b80:	e5 ce       	rjmp	.-566    	; 0x294c <__fp_inf>
    2b82:	3e cf       	rjmp	.-388    	; 0x2a00 <__fp_zero>
    2b84:	e9 ce       	rjmp	.-558    	; 0x2958 <__fp_nan>

00002b86 <exp>:
exp():
    2b86:	22 df       	rcall	.-444    	; 0x29cc <__fp_splitA>
    2b88:	c8 f3       	brcs	.-14     	; 0x2b7c <__unordsf2+0x8>
    2b8a:	96 38       	cpi	r25, 0x86	; 134
    2b8c:	c0 f7       	brcc	.-16     	; 0x2b7e <__unordsf2+0xa>
    2b8e:	07 f8       	bld	r0, 7
    2b90:	0f 92       	push	r0
    2b92:	e8 94       	clt
    2b94:	2b e3       	ldi	r18, 0x3B	; 59
    2b96:	3a ea       	ldi	r19, 0xAA	; 170
    2b98:	48 eb       	ldi	r20, 0xB8	; 184
    2b9a:	5f e7       	ldi	r21, 0x7F	; 127
    2b9c:	4a df       	rcall	.-364    	; 0x2a32 <__mulsf3_pse>
    2b9e:	0f 92       	push	r0
    2ba0:	0f 92       	push	r0
    2ba2:	0f 92       	push	r0
    2ba4:	4d b7       	in	r20, 0x3d	; 61
    2ba6:	5e b7       	in	r21, 0x3e	; 62
    2ba8:	0f 92       	push	r0
    2baa:	c0 d0       	rcall	.+384    	; 0x2d2c <modf>
    2bac:	e8 e7       	ldi	r30, 0x78	; 120
    2bae:	f0 e0       	ldi	r31, 0x00	; 0
    2bb0:	16 d0       	rcall	.+44     	; 0x2bde <__fp_powser>
    2bb2:	4f 91       	pop	r20
    2bb4:	5f 91       	pop	r21
    2bb6:	ef 91       	pop	r30
    2bb8:	ff 91       	pop	r31
    2bba:	e5 95       	asr	r30
    2bbc:	ee 1f       	adc	r30, r30
    2bbe:	ff 1f       	adc	r31, r31
    2bc0:	49 f0       	breq	.+18     	; 0x2bd4 <exp+0x4e>
    2bc2:	fe 57       	subi	r31, 0x7E	; 126
    2bc4:	e0 68       	ori	r30, 0x80	; 128
    2bc6:	44 27       	eor	r20, r20
    2bc8:	ee 0f       	add	r30, r30
    2bca:	44 1f       	adc	r20, r20
    2bcc:	fa 95       	dec	r31
    2bce:	e1 f7       	brne	.-8      	; 0x2bc8 <exp+0x42>
    2bd0:	41 95       	neg	r20
    2bd2:	55 0b       	sbc	r21, r21
    2bd4:	32 d0       	rcall	.+100    	; 0x2c3a <ldexp>
    2bd6:	0f 90       	pop	r0
    2bd8:	07 fe       	sbrs	r0, 7
    2bda:	26 c0       	rjmp	.+76     	; 0x2c28 <inverse>
    2bdc:	08 95       	ret

00002bde <__fp_powser>:
    2bde:	df 93       	push	r29
    2be0:	cf 93       	push	r28
    2be2:	1f 93       	push	r17
    2be4:	0f 93       	push	r16
    2be6:	ff 92       	push	r15
    2be8:	ef 92       	push	r14
    2bea:	df 92       	push	r13
    2bec:	7b 01       	movw	r14, r22
    2bee:	8c 01       	movw	r16, r24
    2bf0:	68 94       	set
    2bf2:	05 c0       	rjmp	.+10     	; 0x2bfe <__fp_powser+0x20>
    2bf4:	da 2e       	mov	r13, r26
    2bf6:	ef 01       	movw	r28, r30
    2bf8:	1a df       	rcall	.-460    	; 0x2a2e <__mulsf3x>
__fp_powser():
    2bfa:	fe 01       	movw	r30, r28
    2bfc:	e8 94       	clt
    2bfe:	a5 91       	lpm	r26, Z+
    2c00:	25 91       	lpm	r18, Z+
    2c02:	35 91       	lpm	r19, Z+
    2c04:	45 91       	lpm	r20, Z+
    2c06:	55 91       	lpm	r21, Z+
    2c08:	ae f3       	brts	.-22     	; 0x2bf4 <__fp_powser+0x16>
    2c0a:	ef 01       	movw	r28, r30
    2c0c:	11 dd       	rcall	.-1502   	; 0x2630 <__addsf3x>
    2c0e:	fe 01       	movw	r30, r28
    2c10:	97 01       	movw	r18, r14
    2c12:	a8 01       	movw	r20, r16
    2c14:	da 94       	dec	r13
    2c16:	79 f7       	brne	.-34     	; 0x2bf6 <__fp_powser+0x18>
    2c18:	df 90       	pop	r13
    2c1a:	ef 90       	pop	r14
    2c1c:	ff 90       	pop	r15
    2c1e:	0f 91       	pop	r16
    2c20:	1f 91       	pop	r17
    2c22:	cf 91       	pop	r28
    2c24:	df 91       	pop	r29
    2c26:	08 95       	ret

00002c28 <inverse>:
inverse():
    2c28:	9b 01       	movw	r18, r22
    2c2a:	ac 01       	movw	r20, r24
    2c2c:	60 e0       	ldi	r22, 0x00	; 0
    2c2e:	70 e0       	ldi	r23, 0x00	; 0
    2c30:	80 e8       	ldi	r24, 0x80	; 128
    2c32:	9f e3       	ldi	r25, 0x3F	; 63
    2c34:	54 cd       	rjmp	.-1368   	; 0x26de <__divsf3>
    2c36:	8a ce       	rjmp	.-748    	; 0x294c <__fp_inf>
    2c38:	ac c0       	rjmp	.+344    	; 0x2d92 <__fp_mpack>

00002c3a <ldexp>:
ldexp():
    2c3a:	c8 de       	rcall	.-624    	; 0x29cc <__fp_splitA>
    2c3c:	e8 f3       	brcs	.-6      	; 0x2c38 <inverse+0x10>
    2c3e:	99 23       	and	r25, r25
    2c40:	d9 f3       	breq	.-10     	; 0x2c38 <inverse+0x10>
    2c42:	94 0f       	add	r25, r20
    2c44:	51 1d       	adc	r21, r1
    2c46:	bb f3       	brvs	.-18     	; 0x2c36 <inverse+0xe>
    2c48:	91 50       	subi	r25, 0x01	; 1
    2c4a:	50 40       	sbci	r21, 0x00	; 0
    2c4c:	94 f0       	brlt	.+36     	; 0x2c72 <ldexp+0x38>
    2c4e:	59 f0       	breq	.+22     	; 0x2c66 <ldexp+0x2c>
    2c50:	88 23       	and	r24, r24
    2c52:	32 f0       	brmi	.+12     	; 0x2c60 <ldexp+0x26>
    2c54:	66 0f       	add	r22, r22
    2c56:	77 1f       	adc	r23, r23
    2c58:	88 1f       	adc	r24, r24
    2c5a:	91 50       	subi	r25, 0x01	; 1
    2c5c:	50 40       	sbci	r21, 0x00	; 0
    2c5e:	c1 f7       	brne	.-16     	; 0x2c50 <ldexp+0x16>
    2c60:	9e 3f       	cpi	r25, 0xFE	; 254
    2c62:	51 05       	cpc	r21, r1
    2c64:	44 f7       	brge	.-48     	; 0x2c36 <inverse+0xe>
    2c66:	88 0f       	add	r24, r24
    2c68:	91 1d       	adc	r25, r1
    2c6a:	96 95       	lsr	r25
    2c6c:	87 95       	ror	r24
    2c6e:	97 f9       	bld	r25, 7
    2c70:	08 95       	ret
    2c72:	5f 3f       	cpi	r21, 0xFF	; 255
    2c74:	ac f0       	brlt	.+42     	; 0x2ca0 <ldexp+0x66>
    2c76:	98 3e       	cpi	r25, 0xE8	; 232
    2c78:	9c f0       	brlt	.+38     	; 0x2ca0 <ldexp+0x66>
    2c7a:	bb 27       	eor	r27, r27
    2c7c:	86 95       	lsr	r24
    2c7e:	77 95       	ror	r23
    2c80:	67 95       	ror	r22
    2c82:	b7 95       	ror	r27
    2c84:	08 f4       	brcc	.+2      	; 0x2c88 <ldexp+0x4e>
    2c86:	b1 60       	ori	r27, 0x01	; 1
    2c88:	93 95       	inc	r25
    2c8a:	c1 f7       	brne	.-16     	; 0x2c7c <ldexp+0x42>
    2c8c:	bb 0f       	add	r27, r27
    2c8e:	58 f7       	brcc	.-42     	; 0x2c66 <ldexp+0x2c>
    2c90:	11 f4       	brne	.+4      	; 0x2c96 <ldexp+0x5c>
    2c92:	60 ff       	sbrs	r22, 0
    2c94:	e8 cf       	rjmp	.-48     	; 0x2c66 <ldexp+0x2c>
    2c96:	6f 5f       	subi	r22, 0xFF	; 255
    2c98:	7f 4f       	sbci	r23, 0xFF	; 255
    2c9a:	8f 4f       	sbci	r24, 0xFF	; 255
    2c9c:	9f 4f       	sbci	r25, 0xFF	; 255
    2c9e:	e3 cf       	rjmp	.-58     	; 0x2c66 <ldexp+0x2c>
    2ca0:	b0 ce       	rjmp	.-672    	; 0x2a02 <__fp_szero>
    2ca2:	0e f0       	brts	.+2      	; 0x2ca6 <ldexp+0x6c>
    2ca4:	76 c0       	rjmp	.+236    	; 0x2d92 <__fp_mpack>
    2ca6:	58 ce       	rjmp	.-848    	; 0x2958 <__fp_nan>
    2ca8:	68 94       	set
    2caa:	50 ce       	rjmp	.-864    	; 0x294c <__fp_inf>

00002cac <log>:
    2cac:	8f de       	rcall	.-738    	; 0x29cc <__fp_splitA>
log():
    2cae:	c8 f3       	brcs	.-14     	; 0x2ca2 <ldexp+0x68>
    2cb0:	99 23       	and	r25, r25
    2cb2:	d1 f3       	breq	.-12     	; 0x2ca8 <ldexp+0x6e>
    2cb4:	c6 f3       	brts	.-16     	; 0x2ca6 <ldexp+0x6c>
    2cb6:	df 93       	push	r29
    2cb8:	cf 93       	push	r28
    2cba:	1f 93       	push	r17
    2cbc:	0f 93       	push	r16
    2cbe:	ff 92       	push	r15
    2cc0:	c9 2f       	mov	r28, r25
    2cc2:	dd 27       	eor	r29, r29
    2cc4:	88 23       	and	r24, r24
    2cc6:	2a f0       	brmi	.+10     	; 0x2cd2 <log+0x26>
    2cc8:	21 97       	sbiw	r28, 0x01	; 1
    2cca:	66 0f       	add	r22, r22
    2ccc:	77 1f       	adc	r23, r23
    2cce:	88 1f       	adc	r24, r24
    2cd0:	da f7       	brpl	.-10     	; 0x2cc8 <log+0x1c>
    2cd2:	20 e0       	ldi	r18, 0x00	; 0
    2cd4:	30 e0       	ldi	r19, 0x00	; 0
    2cd6:	40 e8       	ldi	r20, 0x80	; 128
    2cd8:	5f eb       	ldi	r21, 0xBF	; 191
    2cda:	9f e3       	ldi	r25, 0x3F	; 63
    2cdc:	88 39       	cpi	r24, 0x98	; 152
    2cde:	20 f0       	brcs	.+8      	; 0x2ce8 <log+0x3c>
    2ce0:	80 3e       	cpi	r24, 0xE0	; 224
    2ce2:	30 f0       	brcs	.+12     	; 0x2cf0 <log+0x44>
    2ce4:	21 96       	adiw	r28, 0x01	; 1
    2ce6:	8f 77       	andi	r24, 0x7F	; 127
    2ce8:	92 dc       	rcall	.-1756   	; 0x260e <__addsf3>
    2cea:	e0 ea       	ldi	r30, 0xA0	; 160
    2cec:	f0 e0       	ldi	r31, 0x00	; 0
    2cee:	03 c0       	rjmp	.+6      	; 0x2cf6 <log+0x4a>
    2cf0:	8e dc       	rcall	.-1764   	; 0x260e <__addsf3>
    2cf2:	ed ec       	ldi	r30, 0xCD	; 205
    2cf4:	f0 e0       	ldi	r31, 0x00	; 0
    2cf6:	73 df       	rcall	.-282    	; 0x2bde <__fp_powser>
    2cf8:	8b 01       	movw	r16, r22
    2cfa:	be 01       	movw	r22, r28
    2cfc:	ec 01       	movw	r28, r24
    2cfe:	fb 2e       	mov	r15, r27
    2d00:	6f 57       	subi	r22, 0x7F	; 127
    2d02:	71 09       	sbc	r23, r1
    2d04:	75 95       	asr	r23
    2d06:	77 1f       	adc	r23, r23
    2d08:	88 0b       	sbc	r24, r24
    2d0a:	99 0b       	sbc	r25, r25
    2d0c:	82 dd       	rcall	.-1276   	; 0x2812 <__floatsisf>
    2d0e:	28 e1       	ldi	r18, 0x18	; 24
    2d10:	32 e7       	ldi	r19, 0x72	; 114
    2d12:	41 e3       	ldi	r20, 0x31	; 49
    2d14:	5f e3       	ldi	r21, 0x3F	; 63
    2d16:	8b de       	rcall	.-746    	; 0x2a2e <__mulsf3x>
    2d18:	af 2d       	mov	r26, r15
    2d1a:	98 01       	movw	r18, r16
    2d1c:	ae 01       	movw	r20, r28
    2d1e:	ff 90       	pop	r15
    2d20:	0f 91       	pop	r16
    2d22:	1f 91       	pop	r17
    2d24:	cf 91       	pop	r28
    2d26:	df 91       	pop	r29
    2d28:	83 dc       	rcall	.-1786   	; 0x2630 <__addsf3x>
    2d2a:	37 ce       	rjmp	.-914    	; 0x299a <__fp_round>

00002d2c <modf>:
    2d2c:	fa 01       	movw	r30, r20
    2d2e:	dc 01       	movw	r26, r24
    2d30:	aa 0f       	add	r26, r26
    2d32:	bb 1f       	adc	r27, r27
    2d34:	9b 01       	movw	r18, r22
    2d36:	ac 01       	movw	r20, r24
    2d38:	bf 57       	subi	r27, 0x7F	; 127
    2d3a:	28 f4       	brcc	.+10     	; 0x2d46 <modf+0x1a>
    2d3c:	22 27       	eor	r18, r18
    2d3e:	33 27       	eor	r19, r19
    2d40:	44 27       	eor	r20, r20
    2d42:	50 78       	andi	r21, 0x80	; 128
    2d44:	1f c0       	rjmp	.+62     	; 0x2d84 <modf+0x58>
    2d46:	b7 51       	subi	r27, 0x17	; 23
    2d48:	88 f4       	brcc	.+34     	; 0x2d6c <modf+0x40>
    2d4a:	ab 2f       	mov	r26, r27
modf():
    2d4c:	00 24       	eor	r0, r0
    2d4e:	46 95       	lsr	r20
    2d50:	37 95       	ror	r19
    2d52:	27 95       	ror	r18
    2d54:	01 1c       	adc	r0, r1
    2d56:	a3 95       	inc	r26
    2d58:	d2 f3       	brmi	.-12     	; 0x2d4e <modf+0x22>
    2d5a:	00 20       	and	r0, r0
    2d5c:	69 f0       	breq	.+26     	; 0x2d78 <modf+0x4c>
    2d5e:	22 0f       	add	r18, r18
    2d60:	33 1f       	adc	r19, r19
    2d62:	44 1f       	adc	r20, r20
    2d64:	b3 95       	inc	r27
    2d66:	da f3       	brmi	.-10     	; 0x2d5e <modf+0x32>
    2d68:	0d d0       	rcall	.+26     	; 0x2d84 <modf+0x58>
    2d6a:	50 cc       	rjmp	.-1888   	; 0x260c <__subsf3>
    2d6c:	61 30       	cpi	r22, 0x01	; 1
    2d6e:	71 05       	cpc	r23, r1
    2d70:	a0 e8       	ldi	r26, 0x80	; 128
    2d72:	8a 07       	cpc	r24, r26
    2d74:	b9 46       	sbci	r27, 0x69	; 105
    2d76:	30 f4       	brcc	.+12     	; 0x2d84 <modf+0x58>
    2d78:	9b 01       	movw	r18, r22
    2d7a:	ac 01       	movw	r20, r24
    2d7c:	66 27       	eor	r22, r22
    2d7e:	77 27       	eor	r23, r23
    2d80:	88 27       	eor	r24, r24
    2d82:	90 78       	andi	r25, 0x80	; 128
    2d84:	30 96       	adiw	r30, 0x00	; 0
    2d86:	21 f0       	breq	.+8      	; 0x2d90 <modf+0x64>
    2d88:	20 83       	st	Z, r18
    2d8a:	31 83       	std	Z+1, r19	; 0x01
    2d8c:	42 83       	std	Z+2, r20	; 0x02
    2d8e:	53 83       	std	Z+3, r21	; 0x03
    2d90:	08 95       	ret

00002d92 <__fp_mpack>:
__fp_mpack():
    2d92:	9f 3f       	cpi	r25, 0xFF	; 255
    2d94:	31 f0       	breq	.+12     	; 0x2da2 <__fp_mpack_finite+0xc>

00002d96 <__fp_mpack_finite>:
    2d96:	91 50       	subi	r25, 0x01	; 1
    2d98:	20 f4       	brcc	.+8      	; 0x2da2 <__fp_mpack_finite+0xc>
    2d9a:	87 95       	ror	r24
    2d9c:	77 95       	ror	r23
    2d9e:	67 95       	ror	r22
    2da0:	b7 95       	ror	r27
    2da2:	88 0f       	add	r24, r24
    2da4:	91 1d       	adc	r25, r1
    2da6:	96 95       	lsr	r25
    2da8:	87 95       	ror	r24
    2daa:	97 f9       	bld	r25, 7
    2dac:	08 95       	ret

00002dae <__mulsi3>:
__mulsi3():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:648
    2dae:	db 01       	movw	r26, r22
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:649
    2db0:	8f 93       	push	r24
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:650
    2db2:	9f 93       	push	r25
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:651
    2db4:	2d d0       	rcall	.+90     	; 0x2e10 <__muluhisi3>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:652
    2db6:	bf 91       	pop	r27
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:653
    2db8:	af 91       	pop	r26
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:655
    2dba:	a2 9f       	mul	r26, r18
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:656
    2dbc:	80 0d       	add	r24, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:657
    2dbe:	91 1d       	adc	r25, r1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:658
    2dc0:	a3 9f       	mul	r26, r19
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:659
    2dc2:	90 0d       	add	r25, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:660
    2dc4:	b2 9f       	mul	r27, r18
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:661
    2dc6:	90 0d       	add	r25, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:662
    2dc8:	11 24       	eor	r1, r1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:663
    2dca:	08 95       	ret

00002dcc <__udivmodsi4>:
__udivmodsi4():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1638
    2dcc:	a1 e2       	ldi	r26, 0x21	; 33
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1639
    2dce:	1a 2e       	mov	r1, r26
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1640
    2dd0:	aa 1b       	sub	r26, r26
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1641
    2dd2:	bb 1b       	sub	r27, r27
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1642
    2dd4:	fd 01       	movw	r30, r26
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1644
    2dd6:	0d c0       	rjmp	.+26     	; 0x2df2 <__udivmodsi4_ep>

00002dd8 <__udivmodsi4_loop>:
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1646
    2dd8:	aa 1f       	adc	r26, r26
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1647
    2dda:	bb 1f       	adc	r27, r27
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1648
    2ddc:	ee 1f       	adc	r30, r30
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1649
    2dde:	ff 1f       	adc	r31, r31
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1650
    2de0:	a2 17       	cp	r26, r18
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1651
    2de2:	b3 07       	cpc	r27, r19
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1652
    2de4:	e4 07       	cpc	r30, r20
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1653
    2de6:	f5 07       	cpc	r31, r21
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1654
    2de8:	20 f0       	brcs	.+8      	; 0x2df2 <__udivmodsi4_ep>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1655
    2dea:	a2 1b       	sub	r26, r18
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1656
    2dec:	b3 0b       	sbc	r27, r19
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1657
    2dee:	e4 0b       	sbc	r30, r20
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1658
    2df0:	f5 0b       	sbc	r31, r21

00002df2 <__udivmodsi4_ep>:
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1660
    2df2:	66 1f       	adc	r22, r22
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1661
    2df4:	77 1f       	adc	r23, r23
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1662
    2df6:	88 1f       	adc	r24, r24
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1663
    2df8:	99 1f       	adc	r25, r25
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1664
    2dfa:	1a 94       	dec	r1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1665
    2dfc:	69 f7       	brne	.-38     	; 0x2dd8 <__udivmodsi4_loop>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1667
    2dfe:	60 95       	com	r22
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1668
    2e00:	70 95       	com	r23
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1669
    2e02:	80 95       	com	r24
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1670
    2e04:	90 95       	com	r25
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1672
    2e06:	9b 01       	movw	r18, r22
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1674
    2e08:	ac 01       	movw	r20, r24
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1676
    2e0a:	bd 01       	movw	r22, r26
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1678
    2e0c:	cf 01       	movw	r24, r30
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1680
    2e0e:	08 95       	ret

00002e10 <__muluhisi3>:
__muluhisi3():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:626
    2e10:	52 d1       	rcall	.+676    	; 0x30b6 <__umulhisi3>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:627
    2e12:	a5 9f       	mul	r26, r21
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:628
    2e14:	90 0d       	add	r25, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:629
    2e16:	b4 9f       	mul	r27, r20
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:630
    2e18:	90 0d       	add	r25, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:631
    2e1a:	a4 9f       	mul	r26, r20
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:632
    2e1c:	80 0d       	add	r24, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:633
    2e1e:	91 1d       	adc	r25, r1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:634
    2e20:	11 24       	eor	r1, r1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:635
    2e22:	08 95       	ret

00002e24 <__mulshisi3>:
__mulshisi3():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:603
    2e24:	b7 ff       	sbrs	r27, 7
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:605
    2e26:	f4 cf       	rjmp	.-24     	; 0x2e10 <__muluhisi3>

00002e28 <__mulohisi3>:
__mulohisi3():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:613
    2e28:	f3 df       	rcall	.-26     	; 0x2e10 <__muluhisi3>
    2e2a:	82 1b       	sub	r24, r18
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:615
    2e2c:	93 0b       	sbc	r25, r19
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:616
    2e2e:	08 95       	ret

00002e30 <__muldi3>:
__muldi3():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:617
    2e30:	df 93       	push	r29
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:895
    2e32:	cf 93       	push	r28
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:896
    2e34:	1f 93       	push	r17
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:897
    2e36:	0f 93       	push	r16
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:902
    2e38:	9a 9d       	mul	r25, r10
    2e3a:	f0 2d       	mov	r31, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:903
    2e3c:	21 9f       	mul	r18, r17
    2e3e:	f0 0d       	add	r31, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:904
    2e40:	8b 9d       	mul	r24, r11
    2e42:	f0 0d       	add	r31, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:905
    2e44:	8a 9d       	mul	r24, r10
    2e46:	e0 2d       	mov	r30, r0
    2e48:	f1 0d       	add	r31, r1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:906
    2e4a:	03 9f       	mul	r16, r19
    2e4c:	f0 0d       	add	r31, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:907
    2e4e:	02 9f       	mul	r16, r18
    2e50:	e0 0d       	add	r30, r0
    2e52:	f1 1d       	adc	r31, r1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:910
    2e54:	4e 9d       	mul	r20, r14
    2e56:	e0 0d       	add	r30, r0
    2e58:	f1 1d       	adc	r31, r1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:911
    2e5a:	5e 9d       	mul	r21, r14
    2e5c:	f0 0d       	add	r31, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:912
    2e5e:	4f 9d       	mul	r20, r15
    2e60:	f0 0d       	add	r31, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:914
    2e62:	7f 93       	push	r23
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:915
    2e64:	6f 93       	push	r22
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:916
    2e66:	bf 92       	push	r11
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:917
    2e68:	af 92       	push	r10
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:918
    2e6a:	5f 93       	push	r21
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:919
    2e6c:	4f 93       	push	r20
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:922
    2e6e:	d5 01       	movw	r26, r10
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:923
    2e70:	22 d1       	rcall	.+580    	; 0x30b6 <__umulhisi3>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:924
    2e72:	8b 01       	movw	r16, r22
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:925
    2e74:	ac 01       	movw	r20, r24
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:929
    2e76:	d7 01       	movw	r26, r14
    2e78:	1e d1       	rcall	.+572    	; 0x30b6 <__umulhisi3>
    2e7a:	eb 01       	movw	r28, r22
    2e7c:	e8 0f       	add	r30, r24
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:931
    2e7e:	f9 1f       	adc	r31, r25
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:933
    2e80:	d6 01       	movw	r26, r12
    2e82:	1e d0       	rcall	.+60     	; 0x2ec0 <__muldi3_6>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:936
    2e84:	2f 91       	pop	r18
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:938
    2e86:	3f 91       	pop	r19
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:939
    2e88:	d6 01       	movw	r26, r12
    2e8a:	15 d1       	rcall	.+554    	; 0x30b6 <__umulhisi3>
    2e8c:	c6 0f       	add	r28, r22
    2e8e:	d7 1f       	adc	r29, r23
    2e90:	e8 1f       	adc	r30, r24
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:941
    2e92:	f9 1f       	adc	r31, r25
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:944
    2e94:	af 91       	pop	r26
    2e96:	bf 91       	pop	r27
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:946
    2e98:	13 d0       	rcall	.+38     	; 0x2ec0 <__muldi3_6>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:947
    2e9a:	2f 91       	pop	r18
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:949
    2e9c:	3f 91       	pop	r19
    2e9e:	0b d1       	rcall	.+534    	; 0x30b6 <__umulhisi3>
    2ea0:	c6 0f       	add	r28, r22
    2ea2:	d7 1f       	adc	r29, r23
    2ea4:	e8 1f       	adc	r30, r24
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:952
    2ea6:	f9 1f       	adc	r31, r25
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:953
    2ea8:	d6 01       	movw	r26, r12
    2eaa:	05 d1       	rcall	.+522    	; 0x30b6 <__umulhisi3>
    2eac:	e6 0f       	add	r30, r22
    2eae:	f7 1f       	adc	r31, r23
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:956
    2eb0:	98 01       	movw	r18, r16
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:958
    2eb2:	be 01       	movw	r22, r28
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:959
    2eb4:	cf 01       	movw	r24, r30
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:961
    2eb6:	0f 91       	pop	r16
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:962
    2eb8:	1f 91       	pop	r17
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:963
    2eba:	cf 91       	pop	r28
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:964
    2ebc:	df 91       	pop	r29
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:965
    2ebe:	08 95       	ret

00002ec0 <__muldi3_6>:
__muldi3_6():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:973
    2ec0:	fa d0       	rcall	.+500    	; 0x30b6 <__umulhisi3>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:974
    2ec2:	46 0f       	add	r20, r22
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:975
    2ec4:	57 1f       	adc	r21, r23
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:976
    2ec6:	c8 1f       	adc	r28, r24
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:977
    2ec8:	d9 1f       	adc	r29, r25
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:978
    2eca:	08 f4       	brcc	.+2      	; 0x2ece <__muldi3_6+0xe>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:979
    2ecc:	31 96       	adiw	r30, 0x01	; 1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:980
    2ece:	08 95       	ret

00002ed0 <__moddi3>:
__moddi3():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1964
    2ed0:	68 94       	set
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1965
    2ed2:	01 c0       	rjmp	.+2      	; 0x2ed6 <__divdi3_moddi3>

00002ed4 <__divdi3>:
__divdi3():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1972
    2ed4:	e8 94       	clt

00002ed6 <__divdi3_moddi3>:
__divdi3_moddi3():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1977
    2ed6:	f9 2f       	mov	r31, r25
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1978
    2ed8:	f1 2b       	or	r31, r17
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1979
    2eda:	0a f0       	brmi	.+2      	; 0x2ede <__divdi3_moddi3+0x8>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1981
    2edc:	27 c0       	rjmp	.+78     	; 0x2f2c <__udivdi3_umoddi3>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1987
    2ede:	a0 e0       	ldi	r26, 0x00	; 0
    2ee0:	b0 e0       	ldi	r27, 0x00	; 0
    2ee2:	e4 e7       	ldi	r30, 0x74	; 116
    2ee4:	f7 e1       	ldi	r31, 0x17	; 23
    2ee6:	67 cb       	rjmp	.-2354   	; 0x25b6 <__prologue_saves__+0xc>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1991
    2ee8:	09 2e       	mov	r0, r25
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1997
    2eea:	05 94       	asr	r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2002
    2eec:	1a f4       	brpl	.+6      	; 0x2ef4 <__divdi3_moddi3+0x1e>
    2eee:	79 d0       	rcall	.+242    	; 0x2fe2 <__negdi2>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2005
    2ef0:	11 23       	and	r17, r17
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2006
    2ef2:	92 f4       	brpl	.+36     	; 0x2f18 <__divdi3_moddi3+0x42>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2007
    2ef4:	f0 e8       	ldi	r31, 0x80	; 128
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2008
    2ef6:	0f 26       	eor	r0, r31
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2010
    2ef8:	ff ef       	ldi	r31, 0xFF	; 255
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2011
    2efa:	e0 94       	com	r14
    2efc:	f0 94       	com	r15
    2efe:	00 95       	com	r16
    2f00:	10 95       	com	r17
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2012
    2f02:	b0 94       	com	r11
    2f04:	c0 94       	com	r12
    2f06:	d0 94       	com	r13
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2013
    2f08:	a1 94       	neg	r10
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2014
    2f0a:	bf 0a       	sbc	r11, r31
    2f0c:	cf 0a       	sbc	r12, r31
    2f0e:	df 0a       	sbc	r13, r31
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2015
    2f10:	ef 0a       	sbc	r14, r31
    2f12:	ff 0a       	sbc	r15, r31
    2f14:	0f 0b       	sbc	r16, r31
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2018
    2f16:	1f 0b       	sbc	r17, r31
    2f18:	13 d0       	rcall	.+38     	; 0x2f40 <__udivmod64>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2025
    2f1a:	07 fc       	sbrc	r0, 7
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2027
    2f1c:	62 d0       	rcall	.+196    	; 0x2fe2 <__negdi2>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2030
    2f1e:	cd b7       	in	r28, 0x3d	; 61
    2f20:	de b7       	in	r29, 0x3e	; 62
    2f22:	ec e0       	ldi	r30, 0x0C	; 12
    2f24:	61 cb       	rjmp	.-2366   	; 0x25e8 <__epilogue_restores__+0xc>

00002f26 <__umoddi3>:
__umoddi3():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1806
    2f26:	68 94       	set
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1807
    2f28:	01 c0       	rjmp	.+2      	; 0x2f2c <__udivdi3_umoddi3>

00002f2a <__udivdi3>:
__udivdi3():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1814
    2f2a:	e8 94       	clt

00002f2c <__udivdi3_umoddi3>:
__udivdi3_umoddi3():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1818
    2f2c:	8f 92       	push	r8
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1819
    2f2e:	9f 92       	push	r9
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1820
    2f30:	cf 93       	push	r28
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1821
    2f32:	df 93       	push	r29
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1822
    2f34:	05 d0       	rcall	.+10     	; 0x2f40 <__udivmod64>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1823
    2f36:	df 91       	pop	r29
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1824
    2f38:	cf 91       	pop	r28
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1825
    2f3a:	9f 90       	pop	r9
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1826
    2f3c:	8f 90       	pop	r8
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1827
    2f3e:	08 95       	ret

00002f40 <__udivmod64>:
__udivmod64():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1842
    2f40:	88 24       	eor	r8, r8
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1843
    2f42:	99 24       	eor	r9, r9
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1844
    2f44:	f4 01       	movw	r30, r8
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1845
    2f46:	e4 01       	movw	r28, r8
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1846
    2f48:	b0 e4       	ldi	r27, 0x40	; 64
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1856
    2f4a:	9f 93       	push	r25
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1857
    2f4c:	aa 27       	eor	r26, r26
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1861
    2f4e:	9a 15       	cp	r25, r10
    2f50:	8b 04       	cpc	r8, r11
    2f52:	9c 04       	cpc	r9, r12
    2f54:	ed 05       	cpc	r30, r13
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1862
    2f56:	fe 05       	cpc	r31, r14
    2f58:	cf 05       	cpc	r28, r15
    2f5a:	d0 07       	cpc	r29, r16
    2f5c:	a1 07       	cpc	r26, r17
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1863
    2f5e:	98 f4       	brcc	.+38     	; 0x2f86 <__udivmod64+0x46>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1866
    2f60:	ad 2f       	mov	r26, r29
    2f62:	dc 2f       	mov	r29, r28
    2f64:	cf 2f       	mov	r28, r31
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1867
    2f66:	fe 2f       	mov	r31, r30
    2f68:	e9 2d       	mov	r30, r9
    2f6a:	98 2c       	mov	r9, r8
    2f6c:	89 2e       	mov	r8, r25
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1868
    2f6e:	98 2f       	mov	r25, r24
    2f70:	87 2f       	mov	r24, r23
    2f72:	76 2f       	mov	r23, r22
    2f74:	65 2f       	mov	r22, r21
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1869
    2f76:	54 2f       	mov	r21, r20
    2f78:	43 2f       	mov	r20, r19
    2f7a:	32 2f       	mov	r19, r18
    2f7c:	22 27       	eor	r18, r18
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1872
    2f7e:	b8 50       	subi	r27, 0x08	; 8
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1873
    2f80:	31 f7       	brne	.-52     	; 0x2f4e <__udivmod64+0xe>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1876
    2f82:	bf 91       	pop	r27
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1881
    2f84:	27 c0       	rjmp	.+78     	; 0x2fd4 <__udivmod64+0x94>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1884
    2f86:	1b 2e       	mov	r1, r27
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1887
    2f88:	bf 91       	pop	r27
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1888
    2f8a:	bb 27       	eor	r27, r27
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1916
    2f8c:	22 0f       	add	r18, r18
    2f8e:	33 1f       	adc	r19, r19
    2f90:	44 1f       	adc	r20, r20
    2f92:	55 1f       	adc	r21, r21
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1917
    2f94:	66 1f       	adc	r22, r22
    2f96:	77 1f       	adc	r23, r23
    2f98:	88 1f       	adc	r24, r24
    2f9a:	99 1f       	adc	r25, r25
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1920
    2f9c:	88 1c       	adc	r8, r8
    2f9e:	99 1c       	adc	r9, r9
    2fa0:	ee 1f       	adc	r30, r30
    2fa2:	ff 1f       	adc	r31, r31
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1921
    2fa4:	cc 1f       	adc	r28, r28
    2fa6:	dd 1f       	adc	r29, r29
    2fa8:	aa 1f       	adc	r26, r26
    2faa:	bb 1f       	adc	r27, r27
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1924
    2fac:	8a 14       	cp	r8, r10
    2fae:	9b 04       	cpc	r9, r11
    2fb0:	ec 05       	cpc	r30, r12
    2fb2:	fd 05       	cpc	r31, r13
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1925
    2fb4:	ce 05       	cpc	r28, r14
    2fb6:	df 05       	cpc	r29, r15
    2fb8:	a0 07       	cpc	r26, r16
    2fba:	b1 07       	cpc	r27, r17
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1927
    2fbc:	48 f0       	brcs	.+18     	; 0x2fd0 <__udivmod64+0x90>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1930
    2fbe:	8a 18       	sub	r8, r10
    2fc0:	9b 08       	sbc	r9, r11
    2fc2:	ec 09       	sbc	r30, r12
    2fc4:	fd 09       	sbc	r31, r13
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1931
    2fc6:	ce 09       	sbc	r28, r14
    2fc8:	df 09       	sbc	r29, r15
    2fca:	a0 0b       	sbc	r26, r16
    2fcc:	b1 0b       	sbc	r27, r17
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1935
    2fce:	21 60       	ori	r18, 0x01	; 1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1938
    2fd0:	1a 94       	dec	r1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1939
    2fd2:	e1 f6       	brne	.-72     	; 0x2f8c <__udivmod64+0x4c>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1944
    2fd4:	2e f4       	brtc	.+10     	; 0x2fe0 <__udivmod64+0xa0>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1945
    2fd6:	94 01       	movw	r18, r8
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1946
    2fd8:	af 01       	movw	r20, r30
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1947
    2fda:	be 01       	movw	r22, r28
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1948
    2fdc:	cd 01       	movw	r24, r26
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1950
    2fde:	00 0c       	add	r0, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1952
    2fe0:	08 95       	ret

00002fe2 <__negdi2>:
__negdi2():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2117
    2fe2:	60 95       	com	r22
    2fe4:	70 95       	com	r23
    2fe6:	80 95       	com	r24
    2fe8:	90 95       	com	r25
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2118
    2fea:	30 95       	com	r19
    2fec:	40 95       	com	r20
    2fee:	50 95       	com	r21
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2119
    2ff0:	21 95       	neg	r18
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2120
    2ff2:	3f 4f       	sbci	r19, 0xFF	; 255
    2ff4:	4f 4f       	sbci	r20, 0xFF	; 255
    2ff6:	5f 4f       	sbci	r21, 0xFF	; 255
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2121
    2ff8:	6f 4f       	sbci	r22, 0xFF	; 255
    2ffa:	7f 4f       	sbci	r23, 0xFF	; 255
    2ffc:	8f 4f       	sbci	r24, 0xFF	; 255
    2ffe:	9f 4f       	sbci	r25, 0xFF	; 255
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2122
    3000:	08 95       	ret

00003002 <__ashldi3>:
__ashldi3():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3169
    3002:	00 2e       	mov	r0, r16
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3170
    3004:	08 30       	cpi	r16, 0x08	; 8
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3171
    3006:	90 f0       	brcs	.+36     	; 0x302c <__ashldi3+0x2a>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3172
    3008:	98 2f       	mov	r25, r24
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3173
    300a:	87 2f       	mov	r24, r23
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3174
    300c:	76 2f       	mov	r23, r22
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3175
    300e:	65 2f       	mov	r22, r21
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3176
    3010:	54 2f       	mov	r21, r20
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3177
    3012:	43 2f       	mov	r20, r19
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3178
    3014:	32 2f       	mov	r19, r18
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3179
    3016:	22 27       	eor	r18, r18
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3180
    3018:	08 50       	subi	r16, 0x08	; 8
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3181
    301a:	f4 cf       	rjmp	.-24     	; 0x3004 <__ashldi3+0x2>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3182
    301c:	22 0f       	add	r18, r18
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3183
    301e:	33 1f       	adc	r19, r19
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3184
    3020:	44 1f       	adc	r20, r20
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3185
    3022:	55 1f       	adc	r21, r21
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3186
    3024:	66 1f       	adc	r22, r22
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3187
    3026:	77 1f       	adc	r23, r23
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3188
    3028:	88 1f       	adc	r24, r24
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3189
    302a:	99 1f       	adc	r25, r25
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3190
    302c:	0a 95       	dec	r16
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3191
    302e:	b2 f7       	brpl	.-20     	; 0x301c <__ashldi3+0x1a>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3192
    3030:	00 2d       	mov	r16, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3193
    3032:	08 95       	ret

00003034 <__ashrdi3>:
__ashrdi3():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3122
    3034:	97 fd       	sbrc	r25, 7
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3123
    3036:	10 94       	com	r1

00003038 <__lshrdi3>:
__lshrdi3():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3131
    3038:	00 2e       	mov	r0, r16
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3132
    303a:	08 30       	cpi	r16, 0x08	; 8
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3133
    303c:	98 f0       	brcs	.+38     	; 0x3064 <__lshrdi3+0x2c>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3134
    303e:	08 50       	subi	r16, 0x08	; 8
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3135
    3040:	23 2f       	mov	r18, r19
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3136
    3042:	34 2f       	mov	r19, r20
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3137
    3044:	45 2f       	mov	r20, r21
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3138
    3046:	56 2f       	mov	r21, r22
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3139
    3048:	67 2f       	mov	r22, r23
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3140
    304a:	78 2f       	mov	r23, r24
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3141
    304c:	89 2f       	mov	r24, r25
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3142
    304e:	91 2d       	mov	r25, r1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3143
    3050:	f4 cf       	rjmp	.-24     	; 0x303a <__lshrdi3+0x2>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3144
    3052:	15 94       	asr	r1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3145
    3054:	97 95       	ror	r25
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3146
    3056:	87 95       	ror	r24
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3147
    3058:	77 95       	ror	r23
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3148
    305a:	67 95       	ror	r22
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3149
    305c:	57 95       	ror	r21
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3150
    305e:	47 95       	ror	r20
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3151
    3060:	37 95       	ror	r19
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3152
    3062:	27 95       	ror	r18
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3153
    3064:	0a 95       	dec	r16
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3154
    3066:	aa f7       	brpl	.-22     	; 0x3052 <__lshrdi3+0x1a>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3155
    3068:	11 24       	eor	r1, r1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3156
    306a:	00 2d       	mov	r16, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3157
    306c:	08 95       	ret

0000306e <__adddi3>:
__adddi3():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2051
    306e:	2a 0d       	add	r18, r10
    3070:	3b 1d       	adc	r19, r11
    3072:	4c 1d       	adc	r20, r12
    3074:	5d 1d       	adc	r21, r13
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2052
    3076:	6e 1d       	adc	r22, r14
    3078:	7f 1d       	adc	r23, r15
    307a:	80 1f       	adc	r24, r16
    307c:	91 1f       	adc	r25, r17
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2053
    307e:	08 95       	ret

00003080 <__subdi3>:
__subdi3():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2080
    3080:	2a 19       	sub	r18, r10
    3082:	3b 09       	sbc	r19, r11
    3084:	4c 09       	sbc	r20, r12
    3086:	5d 09       	sbc	r21, r13
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2081
    3088:	6e 09       	sbc	r22, r14
    308a:	7f 09       	sbc	r23, r15
    308c:	80 0b       	sbc	r24, r16
    308e:	91 0b       	sbc	r25, r17
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2082
    3090:	08 95       	ret

00003092 <__cmpdi2_s8>:
__cmpdi2_s8():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2102
    3092:	00 24       	eor	r0, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2103
    3094:	a7 fd       	sbrc	r26, 7
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2104
    3096:	00 94       	com	r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2105
    3098:	2a 17       	cp	r18, r26
    309a:	30 05       	cpc	r19, r0
    309c:	40 05       	cpc	r20, r0
    309e:	50 05       	cpc	r21, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2106
    30a0:	60 05       	cpc	r22, r0
    30a2:	70 05       	cpc	r23, r0
    30a4:	80 05       	cpc	r24, r0
    30a6:	90 05       	cpc	r25, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2107
    30a8:	08 95       	ret

000030aa <__tablejump2__>:
__tablejump2__():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2296
    30aa:	ee 0f       	add	r30, r30
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2297
    30ac:	ff 1f       	adc	r31, r31
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2328
    30ae:	05 90       	lpm	r0, Z+
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2329
    30b0:	f4 91       	lpm	r31, Z
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2330
    30b2:	e0 2d       	mov	r30, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2331
    30b4:	09 94       	ijmp

000030b6 <__umulhisi3>:
__umulhisi3():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:564
    30b6:	a2 9f       	mul	r26, r18
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:565
    30b8:	b0 01       	movw	r22, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:566
    30ba:	b3 9f       	mul	r27, r19
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:567
    30bc:	c0 01       	movw	r24, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:568
    30be:	a3 9f       	mul	r26, r19
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:573
    30c0:	70 0d       	add	r23, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:574
    30c2:	81 1d       	adc	r24, r1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:575
    30c4:	11 24       	eor	r1, r1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:576
    30c6:	91 1d       	adc	r25, r1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:580
    30c8:	b2 9f       	mul	r27, r18
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:581
    30ca:	70 0d       	add	r23, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:582
    30cc:	81 1d       	adc	r24, r1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:583
    30ce:	11 24       	eor	r1, r1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:584
    30d0:	91 1d       	adc	r25, r1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:585
    30d2:	08 95       	ret

000030d4 <malloc>:
malloc():
    30d4:	0f 93       	push	r16
    30d6:	1f 93       	push	r17
    30d8:	cf 93       	push	r28
    30da:	df 93       	push	r29
    30dc:	82 30       	cpi	r24, 0x02	; 2
    30de:	91 05       	cpc	r25, r1
    30e0:	10 f4       	brcc	.+4      	; 0x30e6 <malloc+0x12>
    30e2:	82 e0       	ldi	r24, 0x02	; 2
    30e4:	90 e0       	ldi	r25, 0x00	; 0
    30e6:	e0 91 38 39 	lds	r30, 0x3938	; 0x803938 <__flp>
    30ea:	f0 91 39 39 	lds	r31, 0x3939	; 0x803939 <__flp+0x1>
    30ee:	30 e0       	ldi	r19, 0x00	; 0
    30f0:	20 e0       	ldi	r18, 0x00	; 0
    30f2:	b0 e0       	ldi	r27, 0x00	; 0
    30f4:	a0 e0       	ldi	r26, 0x00	; 0
    30f6:	30 97       	sbiw	r30, 0x00	; 0
    30f8:	99 f4       	brne	.+38     	; 0x3120 <malloc+0x4c>
    30fa:	21 15       	cp	r18, r1
    30fc:	31 05       	cpc	r19, r1
    30fe:	09 f4       	brne	.+2      	; 0x3102 <malloc+0x2e>
    3100:	4a c0       	rjmp	.+148    	; 0x3196 <malloc+0xc2>
    3102:	28 1b       	sub	r18, r24
    3104:	39 0b       	sbc	r19, r25
    3106:	24 30       	cpi	r18, 0x04	; 4
    3108:	31 05       	cpc	r19, r1
    310a:	d8 f5       	brcc	.+118    	; 0x3182 <malloc+0xae>
    310c:	8a 81       	ldd	r24, Y+2	; 0x02
    310e:	9b 81       	ldd	r25, Y+3	; 0x03
    3110:	61 15       	cp	r22, r1
    3112:	71 05       	cpc	r23, r1
    3114:	89 f1       	breq	.+98     	; 0x3178 <malloc+0xa4>
    3116:	fb 01       	movw	r30, r22
    3118:	82 83       	std	Z+2, r24	; 0x02
    311a:	93 83       	std	Z+3, r25	; 0x03
    311c:	fe 01       	movw	r30, r28
    311e:	11 c0       	rjmp	.+34     	; 0x3142 <malloc+0x6e>
    3120:	40 81       	ld	r20, Z
    3122:	51 81       	ldd	r21, Z+1	; 0x01
    3124:	02 81       	ldd	r16, Z+2	; 0x02
    3126:	13 81       	ldd	r17, Z+3	; 0x03
    3128:	48 17       	cp	r20, r24
    312a:	59 07       	cpc	r21, r25
    312c:	e0 f0       	brcs	.+56     	; 0x3166 <malloc+0x92>
    312e:	48 17       	cp	r20, r24
    3130:	59 07       	cpc	r21, r25
    3132:	99 f4       	brne	.+38     	; 0x315a <malloc+0x86>
    3134:	10 97       	sbiw	r26, 0x00	; 0
    3136:	61 f0       	breq	.+24     	; 0x3150 <malloc+0x7c>
    3138:	12 96       	adiw	r26, 0x02	; 2
    313a:	0c 93       	st	X, r16
    313c:	12 97       	sbiw	r26, 0x02	; 2
    313e:	13 96       	adiw	r26, 0x03	; 3
    3140:	1c 93       	st	X, r17
    3142:	32 96       	adiw	r30, 0x02	; 2
    3144:	cf 01       	movw	r24, r30
    3146:	df 91       	pop	r29
    3148:	cf 91       	pop	r28
    314a:	1f 91       	pop	r17
    314c:	0f 91       	pop	r16
    314e:	08 95       	ret
    3150:	00 93 38 39 	sts	0x3938, r16	; 0x803938 <__flp>
    3154:	10 93 39 39 	sts	0x3939, r17	; 0x803939 <__flp+0x1>
    3158:	f4 cf       	rjmp	.-24     	; 0x3142 <malloc+0x6e>
    315a:	21 15       	cp	r18, r1
    315c:	31 05       	cpc	r19, r1
    315e:	51 f0       	breq	.+20     	; 0x3174 <malloc+0xa0>
    3160:	42 17       	cp	r20, r18
    3162:	53 07       	cpc	r21, r19
    3164:	38 f0       	brcs	.+14     	; 0x3174 <malloc+0xa0>
    3166:	a9 01       	movw	r20, r18
    3168:	db 01       	movw	r26, r22
    316a:	9a 01       	movw	r18, r20
    316c:	bd 01       	movw	r22, r26
    316e:	df 01       	movw	r26, r30
    3170:	f8 01       	movw	r30, r16
    3172:	c1 cf       	rjmp	.-126    	; 0x30f6 <malloc+0x22>
    3174:	ef 01       	movw	r28, r30
    3176:	f9 cf       	rjmp	.-14     	; 0x316a <malloc+0x96>
    3178:	80 93 38 39 	sts	0x3938, r24	; 0x803938 <__flp>
    317c:	90 93 39 39 	sts	0x3939, r25	; 0x803939 <__flp+0x1>
    3180:	cd cf       	rjmp	.-102    	; 0x311c <malloc+0x48>
    3182:	fe 01       	movw	r30, r28
    3184:	e2 0f       	add	r30, r18
    3186:	f3 1f       	adc	r31, r19
    3188:	81 93       	st	Z+, r24
    318a:	91 93       	st	Z+, r25
    318c:	22 50       	subi	r18, 0x02	; 2
    318e:	31 09       	sbc	r19, r1
    3190:	28 83       	st	Y, r18
    3192:	39 83       	std	Y+1, r19	; 0x01
    3194:	d7 cf       	rjmp	.-82     	; 0x3144 <malloc+0x70>
    3196:	20 91 36 39 	lds	r18, 0x3936	; 0x803936 <__brkval>
    319a:	30 91 37 39 	lds	r19, 0x3937	; 0x803937 <__brkval+0x1>
    319e:	23 2b       	or	r18, r19
    31a0:	41 f4       	brne	.+16     	; 0x31b2 <malloc+0xde>
    31a2:	20 91 02 38 	lds	r18, 0x3802	; 0x803802 <__malloc_heap_start>
    31a6:	30 91 03 38 	lds	r19, 0x3803	; 0x803803 <__malloc_heap_start+0x1>
    31aa:	20 93 36 39 	sts	0x3936, r18	; 0x803936 <__brkval>
    31ae:	30 93 37 39 	sts	0x3937, r19	; 0x803937 <__brkval+0x1>
    31b2:	20 91 00 38 	lds	r18, 0x3800	; 0x803800 <__DATA_REGION_ORIGIN__>
    31b6:	30 91 01 38 	lds	r19, 0x3801	; 0x803801 <__DATA_REGION_ORIGIN__+0x1>
    31ba:	21 15       	cp	r18, r1
    31bc:	31 05       	cpc	r19, r1
    31be:	41 f4       	brne	.+16     	; 0x31d0 <malloc+0xfc>
    31c0:	2d b7       	in	r18, 0x3d	; 61
    31c2:	3e b7       	in	r19, 0x3e	; 62
    31c4:	40 91 04 38 	lds	r20, 0x3804	; 0x803804 <__malloc_margin>
    31c8:	50 91 05 38 	lds	r21, 0x3805	; 0x803805 <__malloc_margin+0x1>
    31cc:	24 1b       	sub	r18, r20
    31ce:	35 0b       	sbc	r19, r21
    31d0:	e0 91 36 39 	lds	r30, 0x3936	; 0x803936 <__brkval>
    31d4:	f0 91 37 39 	lds	r31, 0x3937	; 0x803937 <__brkval+0x1>
    31d8:	e2 17       	cp	r30, r18
    31da:	f3 07       	cpc	r31, r19
    31dc:	a0 f4       	brcc	.+40     	; 0x3206 <malloc+0x132>
    31de:	2e 1b       	sub	r18, r30
    31e0:	3f 0b       	sbc	r19, r31
    31e2:	28 17       	cp	r18, r24
    31e4:	39 07       	cpc	r19, r25
    31e6:	78 f0       	brcs	.+30     	; 0x3206 <malloc+0x132>
    31e8:	ac 01       	movw	r20, r24
    31ea:	4e 5f       	subi	r20, 0xFE	; 254
    31ec:	5f 4f       	sbci	r21, 0xFF	; 255
    31ee:	24 17       	cp	r18, r20
    31f0:	35 07       	cpc	r19, r21
    31f2:	48 f0       	brcs	.+18     	; 0x3206 <malloc+0x132>
    31f4:	4e 0f       	add	r20, r30
    31f6:	5f 1f       	adc	r21, r31
    31f8:	40 93 36 39 	sts	0x3936, r20	; 0x803936 <__brkval>
    31fc:	50 93 37 39 	sts	0x3937, r21	; 0x803937 <__brkval+0x1>
    3200:	81 93       	st	Z+, r24
    3202:	91 93       	st	Z+, r25
    3204:	9f cf       	rjmp	.-194    	; 0x3144 <malloc+0x70>
    3206:	f0 e0       	ldi	r31, 0x00	; 0
    3208:	e0 e0       	ldi	r30, 0x00	; 0
    320a:	9c cf       	rjmp	.-200    	; 0x3144 <malloc+0x70>

0000320c <free>:
free():
    320c:	cf 93       	push	r28
    320e:	df 93       	push	r29
    3210:	00 97       	sbiw	r24, 0x00	; 0
    3212:	e9 f0       	breq	.+58     	; 0x324e <free+0x42>
    3214:	fc 01       	movw	r30, r24
    3216:	32 97       	sbiw	r30, 0x02	; 2
    3218:	12 82       	std	Z+2, r1	; 0x02
    321a:	13 82       	std	Z+3, r1	; 0x03
    321c:	a0 91 38 39 	lds	r26, 0x3938	; 0x803938 <__flp>
    3220:	b0 91 39 39 	lds	r27, 0x3939	; 0x803939 <__flp+0x1>
    3224:	ed 01       	movw	r28, r26
    3226:	30 e0       	ldi	r19, 0x00	; 0
    3228:	20 e0       	ldi	r18, 0x00	; 0
    322a:	10 97       	sbiw	r26, 0x00	; 0
    322c:	a1 f4       	brne	.+40     	; 0x3256 <free+0x4a>
    322e:	20 81       	ld	r18, Z
    3230:	31 81       	ldd	r19, Z+1	; 0x01
    3232:	82 0f       	add	r24, r18
    3234:	93 1f       	adc	r25, r19
    3236:	20 91 36 39 	lds	r18, 0x3936	; 0x803936 <__brkval>
    323a:	30 91 37 39 	lds	r19, 0x3937	; 0x803937 <__brkval+0x1>
    323e:	28 17       	cp	r18, r24
    3240:	39 07       	cpc	r19, r25
    3242:	09 f0       	breq	.+2      	; 0x3246 <free+0x3a>
    3244:	61 c0       	rjmp	.+194    	; 0x3308 <free+0xfc>
    3246:	e0 93 36 39 	sts	0x3936, r30	; 0x803936 <__brkval>
    324a:	f0 93 37 39 	sts	0x3937, r31	; 0x803937 <__brkval+0x1>
    324e:	df 91       	pop	r29
    3250:	cf 91       	pop	r28
    3252:	08 95       	ret
    3254:	ea 01       	movw	r28, r20
    3256:	ce 17       	cp	r28, r30
    3258:	df 07       	cpc	r29, r31
    325a:	e8 f5       	brcc	.+122    	; 0x32d6 <free+0xca>
    325c:	4a 81       	ldd	r20, Y+2	; 0x02
    325e:	5b 81       	ldd	r21, Y+3	; 0x03
    3260:	9e 01       	movw	r18, r28
    3262:	41 15       	cp	r20, r1
    3264:	51 05       	cpc	r21, r1
    3266:	b1 f7       	brne	.-20     	; 0x3254 <free+0x48>
    3268:	e9 01       	movw	r28, r18
    326a:	ea 83       	std	Y+2, r30	; 0x02
    326c:	fb 83       	std	Y+3, r31	; 0x03
    326e:	49 91       	ld	r20, Y+
    3270:	59 91       	ld	r21, Y+
    3272:	c4 0f       	add	r28, r20
    3274:	d5 1f       	adc	r29, r21
    3276:	ec 17       	cp	r30, r28
    3278:	fd 07       	cpc	r31, r29
    327a:	61 f4       	brne	.+24     	; 0x3294 <free+0x88>
    327c:	80 81       	ld	r24, Z
    327e:	91 81       	ldd	r25, Z+1	; 0x01
    3280:	02 96       	adiw	r24, 0x02	; 2
    3282:	84 0f       	add	r24, r20
    3284:	95 1f       	adc	r25, r21
    3286:	e9 01       	movw	r28, r18
    3288:	88 83       	st	Y, r24
    328a:	99 83       	std	Y+1, r25	; 0x01
    328c:	82 81       	ldd	r24, Z+2	; 0x02
    328e:	93 81       	ldd	r25, Z+3	; 0x03
    3290:	8a 83       	std	Y+2, r24	; 0x02
    3292:	9b 83       	std	Y+3, r25	; 0x03
    3294:	f0 e0       	ldi	r31, 0x00	; 0
    3296:	e0 e0       	ldi	r30, 0x00	; 0
    3298:	12 96       	adiw	r26, 0x02	; 2
    329a:	8d 91       	ld	r24, X+
    329c:	9c 91       	ld	r25, X
    329e:	13 97       	sbiw	r26, 0x03	; 3
    32a0:	00 97       	sbiw	r24, 0x00	; 0
    32a2:	b9 f5       	brne	.+110    	; 0x3312 <free+0x106>
    32a4:	2d 91       	ld	r18, X+
    32a6:	3c 91       	ld	r19, X
    32a8:	11 97       	sbiw	r26, 0x01	; 1
    32aa:	cd 01       	movw	r24, r26
    32ac:	02 96       	adiw	r24, 0x02	; 2
    32ae:	82 0f       	add	r24, r18
    32b0:	93 1f       	adc	r25, r19
    32b2:	20 91 36 39 	lds	r18, 0x3936	; 0x803936 <__brkval>
    32b6:	30 91 37 39 	lds	r19, 0x3937	; 0x803937 <__brkval+0x1>
    32ba:	28 17       	cp	r18, r24
    32bc:	39 07       	cpc	r19, r25
    32be:	39 f6       	brne	.-114    	; 0x324e <free+0x42>
    32c0:	30 97       	sbiw	r30, 0x00	; 0
    32c2:	51 f5       	brne	.+84     	; 0x3318 <free+0x10c>
    32c4:	10 92 38 39 	sts	0x3938, r1	; 0x803938 <__flp>
    32c8:	10 92 39 39 	sts	0x3939, r1	; 0x803939 <__flp+0x1>
    32cc:	a0 93 36 39 	sts	0x3936, r26	; 0x803936 <__brkval>
    32d0:	b0 93 37 39 	sts	0x3937, r27	; 0x803937 <__brkval+0x1>
    32d4:	bc cf       	rjmp	.-136    	; 0x324e <free+0x42>
    32d6:	c2 83       	std	Z+2, r28	; 0x02
    32d8:	d3 83       	std	Z+3, r29	; 0x03
    32da:	40 81       	ld	r20, Z
    32dc:	51 81       	ldd	r21, Z+1	; 0x01
    32de:	84 0f       	add	r24, r20
    32e0:	95 1f       	adc	r25, r21
    32e2:	c8 17       	cp	r28, r24
    32e4:	d9 07       	cpc	r29, r25
    32e6:	61 f4       	brne	.+24     	; 0x3300 <free+0xf4>
    32e8:	4e 5f       	subi	r20, 0xFE	; 254
    32ea:	5f 4f       	sbci	r21, 0xFF	; 255
    32ec:	88 81       	ld	r24, Y
    32ee:	99 81       	ldd	r25, Y+1	; 0x01
    32f0:	48 0f       	add	r20, r24
    32f2:	59 1f       	adc	r21, r25
    32f4:	40 83       	st	Z, r20
    32f6:	51 83       	std	Z+1, r21	; 0x01
    32f8:	8a 81       	ldd	r24, Y+2	; 0x02
    32fa:	9b 81       	ldd	r25, Y+3	; 0x03
    32fc:	82 83       	std	Z+2, r24	; 0x02
    32fe:	93 83       	std	Z+3, r25	; 0x03
    3300:	21 15       	cp	r18, r1
    3302:	31 05       	cpc	r19, r1
    3304:	09 f0       	breq	.+2      	; 0x3308 <free+0xfc>
    3306:	b0 cf       	rjmp	.-160    	; 0x3268 <free+0x5c>
    3308:	e0 93 38 39 	sts	0x3938, r30	; 0x803938 <__flp>
    330c:	f0 93 39 39 	sts	0x3939, r31	; 0x803939 <__flp+0x1>
    3310:	9e cf       	rjmp	.-196    	; 0x324e <free+0x42>
    3312:	fd 01       	movw	r30, r26
    3314:	dc 01       	movw	r26, r24
    3316:	c0 cf       	rjmp	.-128    	; 0x3298 <free+0x8c>
    3318:	12 82       	std	Z+2, r1	; 0x02
    331a:	13 82       	std	Z+3, r1	; 0x03
    331c:	d7 cf       	rjmp	.-82     	; 0x32cc <free+0xc0>

0000331e <strncpy>:
strncpy():
    331e:	fb 01       	movw	r30, r22
    3320:	dc 01       	movw	r26, r24
    3322:	41 50       	subi	r20, 0x01	; 1
    3324:	50 40       	sbci	r21, 0x00	; 0
    3326:	48 f0       	brcs	.+18     	; 0x333a <strncpy+0x1c>
    3328:	01 90       	ld	r0, Z+
    332a:	0d 92       	st	X+, r0
    332c:	00 20       	and	r0, r0
    332e:	c9 f7       	brne	.-14     	; 0x3322 <strncpy+0x4>
    3330:	01 c0       	rjmp	.+2      	; 0x3334 <strncpy+0x16>
    3332:	1d 92       	st	X+, r1
    3334:	41 50       	subi	r20, 0x01	; 1
    3336:	50 40       	sbci	r21, 0x00	; 0
    3338:	e0 f7       	brcc	.-8      	; 0x3332 <strncpy+0x14>
    333a:	08 95       	ret

0000333c <__do_global_dtors>:
__do_global_dtors():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2496
    333c:	10 e0       	ldi	r17, 0x00	; 0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2497
    333e:	c6 ea       	ldi	r28, 0xA6	; 166
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2498
    3340:	d0 e0       	ldi	r29, 0x00	; 0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2502
    3342:	03 c0       	rjmp	.+6      	; 0x334a <__do_global_dtors+0xe>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2508
    3344:	fe 01       	movw	r30, r28
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2509
    3346:	b1 de       	rcall	.-670    	; 0x30aa <__tablejump2__>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2510
    3348:	21 96       	adiw	r28, 0x01	; 1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2515
    334a:	c7 3a       	cpi	r28, 0xA7	; 167
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2516
    334c:	d1 07       	cpc	r29, r17
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2521
    334e:	d1 f7       	brne	.-12     	; 0x3344 <__do_global_dtors+0x8>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2278
    3350:	f8 94       	cli

00003352 <__stop_program>:
__stop_program():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2280
    3352:	ff cf       	rjmp	.-2      	; 0x3352 <__stop_program>
