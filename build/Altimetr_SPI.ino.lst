
g:\Studia\PUT Rocket LAB\altimetr\Altimetr_SPI\build/Altimetr_SPI.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
__vectors():
../../../../crt1/gcrt1.S:61
       0:	a6 c0       	rjmp	.+332    	; 0x14e <__dtors_end>
       2:	00 00       	nop
../../../../crt1/gcrt1.S:67
       4:	d8 c0       	rjmp	.+432    	; 0x1b6 <__bad_interrupt>
       6:	00 00       	nop
../../../../crt1/gcrt1.S:68
       8:	d6 c0       	rjmp	.+428    	; 0x1b6 <__bad_interrupt>
       a:	00 00       	nop
../../../../crt1/gcrt1.S:69
       c:	d4 c0       	rjmp	.+424    	; 0x1b6 <__bad_interrupt>
       e:	00 00       	nop
../../../../crt1/gcrt1.S:70
      10:	d2 c0       	rjmp	.+420    	; 0x1b6 <__bad_interrupt>
      12:	00 00       	nop
../../../../crt1/gcrt1.S:71
      14:	d0 c0       	rjmp	.+416    	; 0x1b6 <__bad_interrupt>
      16:	00 00       	nop
../../../../crt1/gcrt1.S:72
      18:	ce c0       	rjmp	.+412    	; 0x1b6 <__bad_interrupt>
      1a:	00 00       	nop
../../../../crt1/gcrt1.S:73
      1c:	cc c0       	rjmp	.+408    	; 0x1b6 <__bad_interrupt>
      1e:	00 00       	nop
../../../../crt1/gcrt1.S:74
      20:	ca c0       	rjmp	.+404    	; 0x1b6 <__bad_interrupt>
      22:	00 00       	nop
../../../../crt1/gcrt1.S:75
      24:	c8 c0       	rjmp	.+400    	; 0x1b6 <__bad_interrupt>
      26:	00 00       	nop
../../../../crt1/gcrt1.S:76
      28:	c6 c0       	rjmp	.+396    	; 0x1b6 <__bad_interrupt>
      2a:	00 00       	nop
../../../../crt1/gcrt1.S:77
      2c:	c4 c0       	rjmp	.+392    	; 0x1b6 <__bad_interrupt>
      2e:	00 00       	nop
../../../../crt1/gcrt1.S:78
      30:	c2 c0       	rjmp	.+388    	; 0x1b6 <__bad_interrupt>
      32:	00 00       	nop
../../../../crt1/gcrt1.S:79
      34:	c0 c0       	rjmp	.+384    	; 0x1b6 <__bad_interrupt>
      36:	00 00       	nop
../../../../crt1/gcrt1.S:80
      38:	0c 94 c4 0e 	jmp	0x1d88	; 0x1d88 <__vector_14>
../../../../crt1/gcrt1.S:81
      3c:	bc c0       	rjmp	.+376    	; 0x1b6 <__bad_interrupt>
      3e:	00 00       	nop
../../../../crt1/gcrt1.S:82
      40:	ba c0       	rjmp	.+372    	; 0x1b6 <__bad_interrupt>
      42:	00 00       	nop
../../../../crt1/gcrt1.S:83
      44:	0c 94 2e 0e 	jmp	0x1c5c	; 0x1c5c <__vector_17>
../../../../crt1/gcrt1.S:84
      48:	0c 94 29 0e 	jmp	0x1c52	; 0x1c52 <__vector_18>
../../../../crt1/gcrt1.S:85
      4c:	0c 94 33 0e 	jmp	0x1c66	; 0x1c66 <__vector_19>
../../../../crt1/gcrt1.S:86
      50:	b2 c0       	rjmp	.+356    	; 0x1b6 <__bad_interrupt>
      52:	00 00       	nop
../../../../crt1/gcrt1.S:87
      54:	b0 c0       	rjmp	.+352    	; 0x1b6 <__bad_interrupt>
      56:	00 00       	nop
../../../../crt1/gcrt1.S:88
      58:	ae c0       	rjmp	.+348    	; 0x1b6 <__bad_interrupt>
      5a:	00 00       	nop
../../../../crt1/gcrt1.S:89
      5c:	ac c0       	rjmp	.+344    	; 0x1b6 <__bad_interrupt>
      5e:	00 00       	nop
../../../../crt1/gcrt1.S:90
      60:	aa c0       	rjmp	.+340    	; 0x1b6 <__bad_interrupt>
      62:	00 00       	nop
../../../../crt1/gcrt1.S:91
      64:	0c 94 9c 0e 	jmp	0x1d38	; 0x1d38 <__vector_25>
../../../../crt1/gcrt1.S:92
      68:	a6 c0       	rjmp	.+332    	; 0x1b6 <__bad_interrupt>
      6a:	00 00       	nop
../../../../crt1/gcrt1.S:93
      6c:	a4 c0       	rjmp	.+328    	; 0x1b6 <__bad_interrupt>
      6e:	00 00       	nop
../../../../crt1/gcrt1.S:94
      70:	a2 c0       	rjmp	.+324    	; 0x1b6 <__bad_interrupt>
      72:	00 00       	nop
../../../../crt1/gcrt1.S:95
      74:	a0 c0       	rjmp	.+320    	; 0x1b6 <__bad_interrupt>
      76:	00 00       	nop
      78:	07 63       	ori	r16, 0x37	; 55
      7a:	42 36       	cpi	r20, 0x62	; 98
      7c:	b7 9b       	sbis	0x16, 7	; 22
      7e:	d8 a7       	std	Y+40, r29	; 0x28
      80:	1a 39       	cpi	r17, 0x9A	; 154
      82:	68 56       	subi	r22, 0x68	; 104
      84:	18 ae       	std	Y+56, r1	; 0x38
      86:	ba ab       	std	Y+50, r27	; 0x32
      88:	55 8c       	ldd	r5, Z+29	; 0x1d
      8a:	1d 3c       	cpi	r17, 0xCD	; 205
      8c:	b7 cc       	rjmp	.-1682   	; 0xfffff9fc <__eeprom_end+0xff7ef9f8>
      8e:	57 63       	ori	r21, 0x37	; 55
      90:	bd 6d       	ori	r27, 0xDD	; 221
      92:	ed fd       	.word	0xfded	; ????
      94:	75 3e       	cpi	r23, 0xE5	; 229
      96:	f6 17       	cp	r31, r22
      98:	72 31       	cpi	r23, 0x12	; 18
      9a:	bf 00       	.word	0x00bf	; ????
      9c:	00 00       	nop
      9e:	80 3f       	cpi	r24, 0xF0	; 240
      a0:	08 00       	.word	0x0008	; ????
      a2:	00 00       	nop
      a4:	be 92       	st	-X, r11
      a6:	24 49       	sbci	r18, 0x94	; 148
      a8:	12 3e       	cpi	r17, 0xE2	; 226
      aa:	ab aa       	std	Y+51, r10	; 0x33
      ac:	aa 2a       	or	r10, r26
      ae:	be cd       	rjmp	.-1156   	; 0xfffffc2c <__eeprom_end+0xff7efc28>
      b0:	cc cc       	rjmp	.-1640   	; 0xfffffa4a <__eeprom_end+0xff7efa46>
      b2:	4c 3e       	cpi	r20, 0xEC	; 236
      b4:	00 00       	nop
      b6:	00 80       	ld	r0, Z
      b8:	be ab       	std	Y+54, r27	; 0x36
      ba:	aa aa       	std	Y+50, r10	; 0x32
      bc:	aa 3e       	cpi	r26, 0xEA	; 234
      be:	00 00       	nop
      c0:	00 00       	nop
      c2:	bf 00       	.word	0x00bf	; ????
      c4:	00 00       	nop
      c6:	80 3f       	cpi	r24, 0xF0	; 240
      c8:	00 00       	nop
      ca:	00 00       	nop
      cc:	00 08       	sbc	r0, r0
      ce:	41 78       	andi	r20, 0x81	; 129
      d0:	d3 bb       	out	0x13, r29	; 19
      d2:	43 87       	std	Z+11, r20	; 0x0b
      d4:	d1 13       	cpse	r29, r17
      d6:	3d 19       	sub	r19, r13
      d8:	0e 3c       	cpi	r16, 0xCE	; 206
      da:	c3 bd       	out	0x23, r28	; 35
      dc:	42 82       	std	Z+2, r4	; 0x02
      de:	ad 2b       	or	r26, r29
      e0:	3e 68       	ori	r19, 0x8E	; 142
      e2:	ec 82       	std	Y+4, r14	; 0x04
      e4:	76 be       	out	0x36, r7	; 54
      e6:	d9 8f       	std	Y+25, r29	; 0x19
      e8:	e1 a9       	ldd	r30, Z+49	; 0x31
      ea:	3e 4c       	sbci	r19, 0xCE	; 206
      ec:	80 ef       	ldi	r24, 0xF0	; 240
      ee:	ff be       	out	0x3f, r15	; 63
      f0:	01 c4       	rjmp	.+2050   	; 0x8f4 <SPIClass::endTransaction()+0x8e>
      f2:	ff 7f       	andi	r31, 0xFF	; 255
      f4:	3f 00       	.word	0x003f	; ????
      f6:	00 00       	nop
	...

000000fa <__trampolines_end>:
__trampolines_start():
      fa:	43 6f       	ori	r20, 0xF3	; 243
      fc:	75 6c       	ori	r23, 0xC5	; 197
      fe:	64 20       	and	r6, r4
     100:	6e 6f       	ori	r22, 0xFE	; 254
     102:	74 20       	and	r7, r4
     104:	66 69       	ori	r22, 0x96	; 150
     106:	6e 64       	ori	r22, 0x4E	; 78
     108:	20 61       	ori	r18, 0x10	; 16
     10a:	20 76       	andi	r18, 0x60	; 96
     10c:	61 6c       	ori	r22, 0xC1	; 193
     10e:	69 64       	ori	r22, 0x49	; 73
     110:	20 42       	sbci	r18, 0x20	; 32
     112:	4d 50       	subi	r20, 0x0D	; 13
     114:	32 38       	cpi	r19, 0x82	; 130
     116:	30 20       	and	r3, r0
     118:	73 65       	ori	r23, 0x53	; 83
     11a:	6e 73       	andi	r22, 0x3E	; 62
     11c:	6f 72       	andi	r22, 0x2F	; 47
     11e:	2c 20       	and	r2, r12
     120:	63 68       	ori	r22, 0x83	; 131
     122:	65 63       	ori	r22, 0x35	; 53
     124:	6b 20       	and	r6, r11
     126:	77 69       	ori	r23, 0x97	; 151
     128:	72 69       	ori	r23, 0x92	; 146
     12a:	6e 67       	ori	r22, 0x7E	; 126
     12c:	20 6f       	ori	r18, 0xF0	; 240
     12e:	72 20       	and	r7, r2
     130:	74 72       	andi	r23, 0x24	; 36
     132:	79 20       	and	r7, r9
     134:	61 20       	and	r6, r1
     136:	64 69       	ori	r22, 0x94	; 148
     138:	66 66       	ori	r22, 0x66	; 102
     13a:	65 72       	andi	r22, 0x25	; 37
     13c:	65 6e       	ori	r22, 0xE5	; 229
     13e:	74 20       	and	r7, r4
     140:	61 64       	ori	r22, 0x41	; 65
     142:	64 72       	andi	r22, 0x24	; 36
     144:	65 73       	andi	r22, 0x35	; 53
     146:	73 21       	and	r23, r3
	...

0000014a <__ctors_start>:
__ctors_start():
     14a:	5e 0f       	add	r21, r30

0000014c <__ctors_end>:
__dtors_start():
     14c:	be 12       	cpse	r11, r30

0000014e <__dtors_end>:
__dtors_end():
../../../../crt1/gcrt1.S:230
     14e:	11 24       	eor	r1, r1
../../../../crt1/gcrt1.S:231
     150:	1f be       	out	0x3f, r1	; 63
../../../../crt1/gcrt1.S:232
     152:	cf ef       	ldi	r28, 0xFF	; 255
../../../../crt1/gcrt1.S:234
     154:	cd bf       	out	0x3d, r28	; 61
../../../../crt1/gcrt1.S:236
     156:	df e3       	ldi	r29, 0x3F	; 63
../../../../crt1/gcrt1.S:237
     158:	de bf       	out	0x3e, r29	; 62

0000015a <_initThreeStuff()>:
_Z15_initThreeStuffv():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/main.cpp:95
 * (many are available reasonably cheaply on aliexpress et al.) end up being very useful        *
 * for this sort of thing.                                                                      */

  void __attribute__((weak)) init_reset_flags();
  void __attribute__((weak)) init_reset_flags() {
    uint8_t flags = RSTCTRL.RSTFR;
     15a:	80 91 40 00 	lds	r24, 0x0040	; 0x800040 <vtable for Adafruit_BMP280_Temp+0x7f4c22>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/main.cpp:96
    RSTCTRL.RSTFR = flags;
     15e:	80 93 40 00 	sts	0x0040, r24	; 0x800040 <vtable for Adafruit_BMP280_Temp+0x7f4c22>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/main.cpp:97
    if (flags == 0) {
     162:	81 11       	cpse	r24, r1
     164:	05 c0       	rjmp	.+10     	; 0x170 <_initThreeStuff()+0x16>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/main.cpp:98
      _PROTECTED_WRITE(RSTCTRL.SWRR, 1);
     166:	98 ed       	ldi	r25, 0xD8	; 216
     168:	21 e0       	ldi	r18, 0x01	; 1
     16a:	94 bf       	out	0x34, r25	; 52
     16c:	20 93 41 00 	sts	0x0041, r18	; 0x800041 <vtable for Adafruit_BMP280_Temp+0x7f4c23>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/main.cpp:100
    }
    GPIOR0 = flags;
     170:	8c bb       	out	0x1c, r24	; 28

00000172 <__do_clear_bss>:
__do_clear_bss():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2441
     172:	29 e3       	ldi	r18, 0x39	; 57
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2442
     174:	a6 e0       	ldi	r26, 0x06	; 6
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2443
     176:	b8 e3       	ldi	r27, 0x38	; 56
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2444
     178:	01 c0       	rjmp	.+2      	; 0x17c <.do_clear_bss_start>

0000017a <.do_clear_bss_loop>:
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2446
     17a:	1d 92       	st	X+, r1

0000017c <.do_clear_bss_start>:
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2448
     17c:	aa 33       	cpi	r26, 0x3A	; 58
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2449
     17e:	b2 07       	cpc	r27, r18
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2450
     180:	e1 f7       	brne	.-8      	; 0x17a <.do_clear_bss_loop>

00000182 <__do_copy_data>:
__do_copy_data():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2409
     182:	18 e3       	ldi	r17, 0x38	; 56
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2410
     184:	a0 e0       	ldi	r26, 0x00	; 0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2411
     186:	b8 e3       	ldi	r27, 0x38	; 56
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2412
     188:	e6 e6       	ldi	r30, 0x66	; 102
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2413
     18a:	f4 e3       	ldi	r31, 0x34	; 52
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2414
     18c:	02 c0       	rjmp	.+4      	; 0x192 <__do_copy_data+0x10>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2417
     18e:	05 90       	lpm	r0, Z+
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2422
     190:	0d 92       	st	X+, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2424
     192:	a6 30       	cpi	r26, 0x06	; 6
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2425
     194:	b1 07       	cpc	r27, r17
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2426
     196:	d9 f7       	brne	.-10     	; 0x18e <__do_copy_data+0xc>

00000198 <__do_global_ctors>:
__do_global_ctors():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2466
     198:	10 e0       	ldi	r17, 0x00	; 0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2467
     19a:	c6 ea       	ldi	r28, 0xA6	; 166
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2468
     19c:	d0 e0       	ldi	r29, 0x00	; 0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2472
     19e:	04 c0       	rjmp	.+8      	; 0x1a8 <__do_global_ctors+0x10>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2474
     1a0:	21 97       	sbiw	r28, 0x01	; 1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2480
     1a2:	fe 01       	movw	r30, r28
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2481
     1a4:	0e 94 81 18 	call	0x3102	; 0x3102 <__tablejump2__>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2483
     1a8:	c5 3a       	cpi	r28, 0xA5	; 165
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2484
     1aa:	d1 07       	cpc	r29, r17
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2489
     1ac:	c9 f7       	brne	.-14     	; 0x1a0 <__do_global_ctors+0x8>
../../../../crt1/gcrt1.S:314
     1ae:	0e 94 52 10 	call	0x20a4	; 0x20a4 <main>
../../../../crt1/gcrt1.S:315
     1b2:	0c 94 ca 19 	jmp	0x3394	; 0x3394 <__do_global_dtors>

000001b6 <__bad_interrupt>:
__vector_22():
../../../../crt1/gcrt1.S:209
     1b6:	24 cf       	rjmp	.-440    	; 0x0 <__vectors>

000001b8 <NotifyUser_onReceive.constprop.5>:
NotifyUser_onReceive.constprop.5():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:762
      uint8_t* rxHead   = &(_data->_bytesToReadWrite);
    #else                                           // Separate tx/rx Buffers
      uint8_t* rxHead   = &(_data->_bytesToRead);
    #endif
  #endif
  if (_data->user_onReceive != NULL) {
     1b8:	e0 91 c5 38 	lds	r30, 0x38C5	; 0x8038c5 <Wire+0x16>
     1bc:	f0 91 c6 38 	lds	r31, 0x38C6	; 0x8038c6 <Wire+0x17>
     1c0:	30 97       	sbiw	r30, 0x00	; 0
     1c2:	31 f0       	breq	.+12     	; 0x1d0 <NotifyUser_onReceive.constprop.5+0x18>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:763
    if ((*rxHead) > 0) {
     1c4:	80 91 c0 38 	lds	r24, 0x38C0	; 0x8038c0 <Wire+0x11>
     1c8:	88 23       	and	r24, r24
     1ca:	11 f0       	breq	.+4      	; 0x1d0 <NotifyUser_onReceive.constprop.5+0x18>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:764
      _data->user_onReceive((*rxHead));
     1cc:	90 e0       	ldi	r25, 0x00	; 0
     1ce:	09 94       	ijmp
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:767
    }
  }
}
     1d0:	08 95       	ret

000001d2 <Print::write(unsigned char const*, unsigned int)>:
_ZN5Print5writeEPKhj():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:29
#include "Print.h"

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size) {
     1d2:	af 92       	push	r10
     1d4:	bf 92       	push	r11
     1d6:	cf 92       	push	r12
     1d8:	df 92       	push	r13
     1da:	ef 92       	push	r14
     1dc:	ff 92       	push	r15
     1de:	0f 93       	push	r16
     1e0:	1f 93       	push	r17
     1e2:	cf 93       	push	r28
     1e4:	df 93       	push	r29
     1e6:	6c 01       	movw	r12, r24
     1e8:	7b 01       	movw	r14, r22
     1ea:	8b 01       	movw	r16, r22
     1ec:	04 0f       	add	r16, r20
     1ee:	15 1f       	adc	r17, r21
     1f0:	eb 01       	movw	r28, r22
     1f2:	5e 01       	movw	r10, r28
     1f4:	ae 18       	sub	r10, r14
     1f6:	bf 08       	sbc	r11, r15
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:31
  size_t n = 0;
  while (size--) {
     1f8:	c0 17       	cp	r28, r16
     1fa:	d1 07       	cpc	r29, r17
     1fc:	59 f0       	breq	.+22     	; 0x214 <Print::write(unsigned char const*, unsigned int)+0x42>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:32
    if (write(*buffer++)) {
     1fe:	69 91       	ld	r22, Y+
     200:	d6 01       	movw	r26, r12
     202:	ed 91       	ld	r30, X+
     204:	fc 91       	ld	r31, X
     206:	01 90       	ld	r0, Z+
     208:	f0 81       	ld	r31, Z
     20a:	e0 2d       	mov	r30, r0
     20c:	c6 01       	movw	r24, r12
     20e:	09 95       	icall
     210:	89 2b       	or	r24, r25
     212:	79 f7       	brne	.-34     	; 0x1f2 <Print::write(unsigned char const*, unsigned int)+0x20>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:39
    } else {
      break;
    }
  }
  return n;
}
     214:	c5 01       	movw	r24, r10
     216:	df 91       	pop	r29
     218:	cf 91       	pop	r28
     21a:	1f 91       	pop	r17
     21c:	0f 91       	pop	r16
     21e:	ff 90       	pop	r15
     220:	ef 90       	pop	r14
     222:	df 90       	pop	r13
     224:	cf 90       	pop	r12
     226:	bf 90       	pop	r11
     228:	af 90       	pop	r10
     22a:	08 95       	ret

0000022c <UartClass::availableForWrite()>:
_ZN9UartClass17availableForWriteEv():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:642
  int UartClass::availableForWrite(void) {
    tx_buffer_index_t head;
    tx_buffer_index_t tail;

    TX_BUFFER_ATOMIC {
      head = _tx_buffer_head;
     22c:	fc 01       	movw	r30, r24
     22e:	53 89       	ldd	r21, Z+19	; 0x13
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:643
      tail = _tx_buffer_tail;
     230:	44 89       	ldd	r20, Z+20	; 0x14
     232:	25 2f       	mov	r18, r21
     234:	30 e0       	ldi	r19, 0x00	; 0
     236:	84 2f       	mov	r24, r20
     238:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:646
    }
    if (head >= tail) {
      return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
     23a:	82 1b       	sub	r24, r18
     23c:	93 0b       	sbc	r25, r19
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:645

    TX_BUFFER_ATOMIC {
      head = _tx_buffer_head;
      tail = _tx_buffer_tail;
    }
    if (head >= tail) {
     23e:	54 17       	cp	r21, r20
     240:	10 f0       	brcs	.+4      	; 0x246 <UartClass::availableForWrite()+0x1a>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:646
      return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
     242:	cf 96       	adiw	r24, 0x3f	; 63
     244:	08 95       	ret
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:648
    }
    return tail - head - 1;
     246:	01 97       	sbiw	r24, 0x01	; 1
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:649
  }
     248:	08 95       	ret

0000024a <UartClass::read()>:
_ZN9UartClass4readEv():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:626
    } else {
      return _rx_buffer[_rx_buffer_tail];
    }
  }

  int UartClass::read(void) {
     24a:	fc 01       	movw	r30, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:628
    // if the head isn't ahead of the tail, we don't have any characters
    if (_rx_buffer_head == _rx_buffer_tail) {
     24c:	91 89       	ldd	r25, Z+17	; 0x11
     24e:	82 89       	ldd	r24, Z+18	; 0x12
     250:	98 17       	cp	r25, r24
     252:	61 f0       	breq	.+24     	; 0x26c <UartClass::read()+0x22>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:631
      return -1;
    } else {
      unsigned char c = _rx_buffer[_rx_buffer_tail];
     254:	a2 89       	ldd	r26, Z+18	; 0x12
     256:	ae 0f       	add	r26, r30
     258:	bf 2f       	mov	r27, r31
     25a:	b1 1d       	adc	r27, r1
     25c:	55 96       	adiw	r26, 0x15	; 21
     25e:	8c 91       	ld	r24, X
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:632
      _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) & (SERIAL_RX_BUFFER_SIZE - 1); // % SERIAL_RX_BUFFER_SIZE;
     260:	92 89       	ldd	r25, Z+18	; 0x12
     262:	9f 5f       	subi	r25, 0xFF	; 255
     264:	9f 73       	andi	r25, 0x3F	; 63
     266:	92 8b       	std	Z+18, r25	; 0x12
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:633
      return c;
     268:	90 e0       	ldi	r25, 0x00	; 0
     26a:	08 95       	ret
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:629
  }

  int UartClass::read(void) {
    // if the head isn't ahead of the tail, we don't have any characters
    if (_rx_buffer_head == _rx_buffer_tail) {
      return -1;
     26c:	8f ef       	ldi	r24, 0xFF	; 255
     26e:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:635
    } else {
      unsigned char c = _rx_buffer[_rx_buffer_tail];
      _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) & (SERIAL_RX_BUFFER_SIZE - 1); // % SERIAL_RX_BUFFER_SIZE;
      return c;
    }
  }
     270:	08 95       	ret

00000272 <UartClass::peek()>:
_ZN9UartClass4peekEv():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:618
}
  int UartClass::available(void) {
    return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) & (SERIAL_RX_BUFFER_SIZE - 1); //% SERIAL_RX_BUFFER_SIZE;
  }

  int UartClass::peek(void) {
     272:	fc 01       	movw	r30, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:619
    if (_rx_buffer_head == _rx_buffer_tail) {
     274:	91 89       	ldd	r25, Z+17	; 0x11
     276:	82 89       	ldd	r24, Z+18	; 0x12
     278:	98 17       	cp	r25, r24
     27a:	31 f0       	breq	.+12     	; 0x288 <UartClass::peek()+0x16>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:622
      return -1;
    } else {
      return _rx_buffer[_rx_buffer_tail];
     27c:	82 89       	ldd	r24, Z+18	; 0x12
     27e:	e8 0f       	add	r30, r24
     280:	f1 1d       	adc	r31, r1
     282:	85 89       	ldd	r24, Z+21	; 0x15
     284:	90 e0       	ldi	r25, 0x00	; 0
     286:	08 95       	ret
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:620
    return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) & (SERIAL_RX_BUFFER_SIZE - 1); //% SERIAL_RX_BUFFER_SIZE;
  }

  int UartClass::peek(void) {
    if (_rx_buffer_head == _rx_buffer_tail) {
      return -1;
     288:	8f ef       	ldi	r24, 0xFF	; 255
     28a:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:624
    } else {
      return _rx_buffer[_rx_buffer_tail];
    }
  }
     28c:	08 95       	ret

0000028e <UartClass::available()>:
_ZN9UartClass9availableEv():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:614

  // Note: Does not change output pins
  // though the datasheetsays turning the TX module sets it to input.
  _state = 0;
}
  int UartClass::available(void) {
     28e:	fc 01       	movw	r30, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:615
    return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) & (SERIAL_RX_BUFFER_SIZE - 1); //% SERIAL_RX_BUFFER_SIZE;
     290:	91 89       	ldd	r25, Z+17	; 0x11
     292:	22 89       	ldd	r18, Z+18	; 0x12
     294:	89 2f       	mov	r24, r25
     296:	90 e0       	ldi	r25, 0x00	; 0
     298:	80 5c       	subi	r24, 0xC0	; 192
     29a:	9f 4f       	sbci	r25, 0xFF	; 255
     29c:	82 1b       	sub	r24, r18
     29e:	91 09       	sbc	r25, r1
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:616
  }
     2a0:	8f 73       	andi	r24, 0x3F	; 63
     2a2:	99 27       	eor	r25, r25
     2a4:	08 95       	ret

000002a6 <UartClass::end()>:
_ZN9UartClass3endEv():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:598
    pinMode(_usart_pins[muxrow][3], OUTPUT); // make XDIR output.
  }
  */
}

void UartClass::end() {
     2a6:	cf 93       	push	r28
     2a8:	df 93       	push	r29
     2aa:	ec 01       	movw	r28, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:600
  // wait for transmission of outgoing data
  flush();
     2ac:	e8 81       	ld	r30, Y
     2ae:	f9 81       	ldd	r31, Y+1	; 0x01
     2b0:	06 80       	ldd	r0, Z+6	; 0x06
     2b2:	f7 81       	ldd	r31, Z+7	; 0x07
     2b4:	e0 2d       	mov	r30, r0
     2b6:	09 95       	icall
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:603
  // Disable receiver and transmitter as well as the RX complete and the data register empty interrupts.
  // TXCIE only used in half duplex - we can just turn the damned thing off yo!
  volatile USART_t * temp = _hwserial_module; /* compiler does a slightly better job with this. */
     2b8:	ec 85       	ldd	r30, Y+12	; 0x0c
     2ba:	fd 85       	ldd	r31, Y+13	; 0x0d
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:604
  temp -> CTRLB &= 0; //~(USART_RXEN_bm | USART_TXEN_bm);
     2bc:	86 81       	ldd	r24, Z+6	; 0x06
     2be:	16 82       	std	Z+6, r1	; 0x06
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:605
  temp -> CTRLA &= 0; //~(USART_RXCIE_bm | USART_DREIE_bm | USART_TXCIE_bm);
     2c0:	85 81       	ldd	r24, Z+5	; 0x05
     2c2:	15 82       	std	Z+5, r1	; 0x05
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:606
  temp -> STATUS =  USART_TXCIF_bm; // want to make sure no chanceofthat firing in error.
     2c4:	80 e4       	ldi	r24, 0x40	; 64
     2c6:	84 83       	std	Z+4, r24	; 0x04
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:608
  // clear any received data
  _rx_buffer_head = _rx_buffer_tail;
     2c8:	8a 89       	ldd	r24, Y+18	; 0x12
     2ca:	89 8b       	std	Y+17, r24	; 0x11
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:612

  // Note: Does not change output pins
  // though the datasheetsays turning the TX module sets it to input.
  _state = 0;
     2cc:	18 8a       	std	Y+16, r1	; 0x10
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:613
}
     2ce:	df 91       	pop	r29
     2d0:	cf 91       	pop	r28
     2d2:	08 95       	ret

000002d4 <UartClass::_poll_tx_data_empty()>:
_ZN9UartClass19_poll_tx_data_emptyEv():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:352
    uartClass._tx_buffer_tail = txTail;
  }
#endif

// To invoke data empty "interrupt" via a call, use this method
void UartClass::_poll_tx_data_empty(void) {
     2d4:	fc 01       	movw	r30, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:353
  if ((!(SREG & CPU_I_bm)) ||  CPUINT.STATUS) {
     2d6:	0f b6       	in	r0, 0x3f	; 63
     2d8:	07 fe       	sbrs	r0, 7
     2da:	04 c0       	rjmp	.+8      	; 0x2e4 <UartClass::_poll_tx_data_empty()+0x10>
     2dc:	80 91 11 01 	lds	r24, 0x0111	; 0x800111 <vtable for Adafruit_BMP280_Temp+0x7f4cf3>
     2e0:	88 23       	and	r24, r24
     2e2:	a9 f0       	breq	.+42     	; 0x30e <_poll_dre_done>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:370
    // so we'll have to poll the "data register empty" flag ourselves.
    // If it is set, pretend an interrupt has happened and call the handler
    // to free up space for us.
    // -Spence 10/23/20
    // Invoke interrupt handler only if conditions data register is empty
    if ((*_hwserial_module).STATUS & USART_DREIF_bm) {
     2e4:	a4 85       	ldd	r26, Z+12	; 0x0c
     2e6:	b5 85       	ldd	r27, Z+13	; 0x0d
     2e8:	14 96       	adiw	r26, 0x04	; 4
     2ea:	8c 91       	ld	r24, X
     2ec:	14 97       	sbiw	r26, 0x04	; 4
     2ee:	85 ff       	sbrs	r24, 5
     2f0:	0e c0       	rjmp	.+28     	; 0x30e <_poll_dre_done>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:371
      if (_tx_buffer_head != _tx_buffer_tail) {
     2f2:	93 89       	ldd	r25, Z+19	; 0x13
     2f4:	84 89       	ldd	r24, Z+20	; 0x14
     2f6:	98 17       	cp	r25, r24
     2f8:	39 f0       	breq	.+14     	; 0x308 <UartClass::_poll_tx_data_empty()+0x34>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:373
        // Buffer empty, so disable "data register empty" interrupt
        (*_hwserial_module).CTRLA &= (~USART_DREIE_bm);
     2fa:	15 96       	adiw	r26, 0x05	; 5
     2fc:	8c 91       	ld	r24, X
     2fe:	15 97       	sbiw	r26, 0x05	; 5
     300:	8f 7d       	andi	r24, 0xDF	; 223
     302:	15 96       	adiw	r26, 0x05	; 5
     304:	8c 93       	st	X, r24
     306:	08 95       	ret
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:397
#ifdef USART1
                ::"z"((uint16_t)thisSerial)
#else
                ::"z"(&Serial)
#endif
                : "r18","r19","r24","r25","r26","r27");
     308:	e8 94       	clt
     30a:	0c 94 3e 0e 	jmp	0x1c7c	; 0x1c7c <_poll_dre>

0000030e <_poll_dre_done>:
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:404
    }
  }
  // In case interrupts are enabled, the interrupt routine will be invoked by itself
  // Note that this currently does not handle cases where the DRE interruopt becomes
  // disabled, yet you are actually attempting to send. I don't think it can happen.
}
     30e:	08 95       	ret

00000310 <UartClass::write(unsigned char)>:
_ZN9UartClass5writeEh():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:682
    // When we get here, nothing is queued anymore (DREIE is disabled) and
    // the hardware finished transmission (TXCIF is set).
  }


  size_t UartClass::write(uint8_t c) {
     310:	0f 93       	push	r16
     312:	1f 93       	push	r17
     314:	cf 93       	push	r28
     316:	df 93       	push	r29
     318:	ec 01       	movw	r28, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:683
    _state |= 1; // Record that we have written to serial since it was begun.
     31a:	88 89       	ldd	r24, Y+16	; 0x10
     31c:	98 2f       	mov	r25, r24
     31e:	91 60       	ori	r25, 0x01	; 1
     320:	98 8b       	std	Y+16, r25	; 0x10
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:688
    // If the buffer and the data register is empty, just write the byte
    // to the data register and be done. This shortcut helps
    // significantly improve the effective data rate at high (>
    // 500kbit/s) bit rates, where interrupt overhead becomes a slowdown.
    if ((_tx_buffer_head == _tx_buffer_tail) && ((*_hwserial_module).STATUS & USART_DREIF_bm)) {
     322:	2b 89       	ldd	r18, Y+19	; 0x13
     324:	9c 89       	ldd	r25, Y+20	; 0x14
     326:	29 13       	cpse	r18, r25
     328:	0a c0       	rjmp	.+20     	; 0x33e <UartClass::write(unsigned char)+0x2e>
     32a:	ec 85       	ldd	r30, Y+12	; 0x0c
     32c:	fd 85       	ldd	r31, Y+13	; 0x0d
     32e:	94 81       	ldd	r25, Z+4	; 0x04
     330:	95 ff       	sbrs	r25, 5
     332:	05 c0       	rjmp	.+10     	; 0x33e <UartClass::write(unsigned char)+0x2e>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:689
      if (_state & 2) { // in half duplex mode, we turn off RXC interrupt
     334:	81 fd       	sbrc	r24, 1
     336:	0d c0       	rjmp	.+26     	; 0x352 <UartClass::write(unsigned char)+0x42>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:696
        ctrla &= ~USART_RXCIE_bm;
        ctrla |=  USART_TXCIE_bm;
        (*_hwserial_module).STATUS = USART_TXCIF_bm;
        (*_hwserial_module).CTRLA = ctrla;
      } else {
        (*_hwserial_module).STATUS = USART_TXCIF_bm;
     338:	80 e4       	ldi	r24, 0x40	; 64
     33a:	84 83       	std	Z+4, r24	; 0x04
     33c:	12 c0       	rjmp	.+36     	; 0x362 <UartClass::write(unsigned char)+0x52>
     33e:	06 2f       	mov	r16, r22
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:714
       * // that the interrupt handler is called in this situation
       * (*_hwserial_module).CTRLA &= (~USART_DREIE_bm);
       */
      return 1;
    }
    tx_buffer_index_t i = (_tx_buffer_head + 1) & (SERIAL_TX_BUFFER_SIZE - 1);  // % SERIAL_TX_BUFFER_SIZE;
     340:	1b 89       	ldd	r17, Y+19	; 0x13
     342:	1f 5f       	subi	r17, 0xFF	; 255
     344:	1f 73       	andi	r17, 0x3F	; 63
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:718

    // If the output buffer is full, there's nothing we can do other than to
    // wait for the interrupt handler to empty it a bit (or emulate interrupts)
    while (i == _tx_buffer_tail) {
     346:	8c 89       	ldd	r24, Y+20	; 0x14
     348:	81 13       	cpse	r24, r17
     34a:	15 c0       	rjmp	.+42     	; 0x376 <UartClass::write(unsigned char)+0x66>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:719
      _poll_tx_data_empty();
     34c:	ce 01       	movw	r24, r28
     34e:	c2 df       	rcall	.-124    	; 0x2d4 <UartClass::_poll_tx_data_empty()>
     350:	fa cf       	rjmp	.-12     	; 0x346 <UartClass::write(unsigned char)+0x36>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:690
    // to the data register and be done. This shortcut helps
    // significantly improve the effective data rate at high (>
    // 500kbit/s) bit rates, where interrupt overhead becomes a slowdown.
    if ((_tx_buffer_head == _tx_buffer_tail) && ((*_hwserial_module).STATUS & USART_DREIF_bm)) {
      if (_state & 2) { // in half duplex mode, we turn off RXC interrupt
        uint8_t ctrla = (*_hwserial_module).CTRLA;
     352:	85 81       	ldd	r24, Z+5	; 0x05
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:691
        ctrla &= ~USART_RXCIE_bm;
     354:	8f 77       	andi	r24, 0x7F	; 127
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:692
        ctrla |=  USART_TXCIE_bm;
     356:	80 64       	ori	r24, 0x40	; 64
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:693
        (*_hwserial_module).STATUS = USART_TXCIF_bm;
     358:	90 e4       	ldi	r25, 0x40	; 64
     35a:	94 83       	std	Z+4, r25	; 0x04
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:694
        (*_hwserial_module).CTRLA = ctrla;
     35c:	ec 85       	ldd	r30, Y+12	; 0x0c
     35e:	fd 85       	ldd	r31, Y+13	; 0x0d
     360:	85 83       	std	Z+5, r24	; 0x05
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:699
      } else {
        (*_hwserial_module).STATUS = USART_TXCIF_bm;
      }
      // MUST clear TXCIF **before** writing new char, otherwise ill-timed interrupt can cause it to erase the flag after the new charchter has been sent!
      (*_hwserial_module).TXDATAL = c;
     362:	ec 85       	ldd	r30, Y+12	; 0x0c
     364:	fd 85       	ldd	r31, Y+13	; 0x0d
     366:	62 83       	std	Z+2, r22	; 0x02
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:734
    } else {
      // Enable "data register empty interrupt"
      (*_hwserial_module).CTRLA |= USART_DREIE_bm;
    }
    return 1;
  }
     368:	81 e0       	ldi	r24, 0x01	; 1
     36a:	90 e0       	ldi	r25, 0x00	; 0
     36c:	df 91       	pop	r29
     36e:	cf 91       	pop	r28
     370:	1f 91       	pop	r17
     372:	0f 91       	pop	r16
     374:	08 95       	ret
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:721
    // If the output buffer is full, there's nothing we can do other than to
    // wait for the interrupt handler to empty it a bit (or emulate interrupts)
    while (i == _tx_buffer_tail) {
      _poll_tx_data_empty();
    }
    _tx_buffer[_tx_buffer_head] = c;
     376:	eb 89       	ldd	r30, Y+19	; 0x13
     378:	ec 0f       	add	r30, r28
     37a:	fd 2f       	mov	r31, r29
     37c:	f1 1d       	adc	r31, r1
     37e:	eb 5a       	subi	r30, 0xAB	; 171
     380:	ff 4f       	sbci	r31, 0xFF	; 255
     382:	00 83       	st	Z, r16
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:722
    _tx_buffer_head = i;
     384:	1b 8b       	std	Y+19, r17	; 0x13
     386:	ec 85       	ldd	r30, Y+12	; 0x0c
     388:	fd 85       	ldd	r31, Y+13	; 0x0d
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:723
    if (_state & 2) { // in half duplex mode, we turn off RXC interrupt
     38a:	88 89       	ldd	r24, Y+16	; 0x10
     38c:	81 ff       	sbrs	r24, 1
     38e:	09 c0       	rjmp	.+18     	; 0x3a2 <UartClass::write(unsigned char)+0x92>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:724
      uint8_t ctrla = (*_hwserial_module).CTRLA;
     390:	85 81       	ldd	r24, Z+5	; 0x05
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:725
      ctrla &= ~USART_RXCIE_bm;
     392:	8f 77       	andi	r24, 0x7F	; 127
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:726
      ctrla |= USART_TXCIE_bm | USART_DREIE_bm;
     394:	80 66       	ori	r24, 0x60	; 96
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:727
      (*_hwserial_module).STATUS = USART_TXCIF_bm;
     396:	90 e4       	ldi	r25, 0x40	; 64
     398:	94 83       	std	Z+4, r25	; 0x04
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:728
      (*_hwserial_module).CTRLA = ctrla;
     39a:	ec 85       	ldd	r30, Y+12	; 0x0c
     39c:	fd 85       	ldd	r31, Y+13	; 0x0d
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:731
    } else {
      // Enable "data register empty interrupt"
      (*_hwserial_module).CTRLA |= USART_DREIE_bm;
     39e:	85 83       	std	Z+5, r24	; 0x05
     3a0:	e3 cf       	rjmp	.-58     	; 0x368 <UartClass::write(unsigned char)+0x58>
     3a2:	85 81       	ldd	r24, Z+5	; 0x05
     3a4:	80 62       	ori	r24, 0x20	; 32
     3a6:	fb cf       	rjmp	.-10     	; 0x39e <UartClass::write(unsigned char)+0x8e>

000003a8 <UartClass::flush()>:
_ZN9UartClass5flushEv():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:651
      return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
    }
    return tail - head - 1;
  }

  void UartClass::flush() {
     3a8:	cf 93       	push	r28
     3aa:	df 93       	push	r29
     3ac:	ec 01       	movw	r28, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:655
    // If we have never written a byte, no need to flush. This special
    // case is needed since there is no way to force the TXCIF (transmit
    // complete) bit to 1 during initialization
    if (!_state & 1) {
     3ae:	88 89       	ldd	r24, Y+16	; 0x10
     3b0:	88 23       	and	r24, r24
     3b2:	59 f0       	breq	.+22     	; 0x3ca <UartClass::flush()+0x22>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:670
    // it's appropriate to use for applications where it has only very small benefits, and significant risk of surprising the user and causing
    // breakage of code that would otherwise work. Finally, the previous implementation didn't check if it was called from the current lvl1 ISR
    // and in that case flush(), and write() with full buffer would just straight up hang...

    // Spin until the data-register-empty-interrupt is disabled and TX complete interrupt flag is raised
    while (((*_hwserial_module).CTRLA & USART_DREIE_bm) || (!((*_hwserial_module).STATUS & USART_TXCIF_bm))) {
     3b4:	ec 85       	ldd	r30, Y+12	; 0x0c
     3b6:	fd 85       	ldd	r31, Y+13	; 0x0d
     3b8:	85 81       	ldd	r24, Z+5	; 0x05
     3ba:	85 fd       	sbrc	r24, 5
     3bc:	03 c0       	rjmp	.+6      	; 0x3c4 <UartClass::flush()+0x1c>
     3be:	84 81       	ldd	r24, Z+4	; 0x04
     3c0:	86 fd       	sbrc	r24, 6
     3c2:	03 c0       	rjmp	.+6      	; 0x3ca <UartClass::flush()+0x22>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:675

      // If interrupts are globally disabled or the and DR empty interrupt is disabled,
      // poll the "data register empty" interrupt flag to prevent deadlock

      _poll_tx_data_empty();
     3c4:	ce 01       	movw	r24, r28
     3c6:	86 df       	rcall	.-244    	; 0x2d4 <UartClass::_poll_tx_data_empty()>
     3c8:	f5 cf       	rjmp	.-22     	; 0x3b4 <UartClass::flush()+0xc>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:679
    }
    // When we get here, nothing is queued anymore (DREIE is disabled) and
    // the hardware finished transmission (TXCIF is set).
  }
     3ca:	df 91       	pop	r29
     3cc:	cf 91       	pop	r28
     3ce:	08 95       	ret

000003d0 <UartClass::operator bool()>:
_ZN9UartClasscvbEv():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.h:293
    inline   size_t write(unsigned int n)   {return write((uint8_t)n);}
    inline   size_t write(int n)            {return write((uint8_t)n);}
    using Print::write; // pull in write(str) and write(buf, size) from Print
    explicit operator bool() {
      return true;
    }
     3d0:	81 e0       	ldi	r24, 0x01	; 1
     3d2:	08 95       	ret

000003d4 <_delayMicroseconds>:
_delayMicroseconds():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:962
  // we just burned 24 (22) cycles above, remove 3
  us -= 3; // 2 cycles

#elif F_CPU >= 20000000L
  // for a one-microsecond delay, burn 4 clocks and then return
  __asm__ __volatile__ (
     3d4:	00 c0       	rjmp	.+0      	; 0x3d6 <_delayMicroseconds+0x2>
     3d6:	00 00       	nop
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:966
    "rjmp .+0" "\n\t"     // 2 cycles
    "nop" );              // 1 cycle
                          // wait 3 cycles with 2 words
  if (us <= 1) return; //  = 3 cycles, (4 when true)
     3d8:	82 30       	cpi	r24, 0x02	; 2
     3da:	91 05       	cpc	r25, r1
     3dc:	40 f0       	brcs	.+16     	; 0x3ee <_delayMicroseconds+0x1a>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:969
  // the loop takes a 1/2 of a microsecond (10 cycles) per iteration
  // so execute it twice for each microsecond of delay requested.
  us = us << 1; // x2 us, = 2 cycles
     3de:	88 0f       	add	r24, r24
     3e0:	99 1f       	adc	r25, r25
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:972
  // we just burned 21 (23) cycles above, remove 2
  // us is at least 4 so we can subtract 2.
  us -= 2; // 2 cycles
     3e2:	02 97       	sbiw	r24, 0x02	; 2
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:1074
    "rjmp .+0"      "\n\t"            // 2 cycles
    "rjmp .+0"      "\n\t"            // 2 cycles
    "brne 1b" : "=w" (us) : "0" (us)  // 2 cycles
  );
#elif defined(DELAYMICROS_TEN)
  __asm__ __volatile__ (
     3e4:	01 97       	sbiw	r24, 0x01	; 1
     3e6:	00 c0       	rjmp	.+0      	; 0x3e8 <_delayMicroseconds+0x14>
     3e8:	00 c0       	rjmp	.+0      	; 0x3ea <_delayMicroseconds+0x16>
     3ea:	00 c0       	rjmp	.+0      	; 0x3ec <_delayMicroseconds+0x18>
     3ec:	d9 f7       	brne	.-10     	; 0x3e4 <_delayMicroseconds+0x10>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:1116
    "1: sbiw %0, 1" "\n\t"            // 2 cycles
    "brne 1b" : "=w" (us) : "0" (us)  // 2 cycles
  );
#endif
  // return = 4 cycles
}
     3ee:	08 95       	ret

000003f0 <micros>:
micros():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:271
    #else
      uint8_t ticks;
    #endif
    uint8_t flags;
    /* Save current state and disable interrupts */
    uint8_t oldSREG = SREG;
     3f0:	9f b7       	in	r25, 0x3f	; 63
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:272
    cli(); /* INTERRUPTS OFF */
     3f2:	f8 94       	cli
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:282
      TCD0.CTRLE = TCD_SCAPTUREA_bm;
      while (!(TCD0.STATUS & TCD_CMDRDY_bm)); // wait for sync - should be only one iteration of this loop
      flags = TCD0.INTFLAGS;
      ticks = TCD0.CAPTUREA;
    #else
      ticks = _timer->CNT;
     3f4:	e0 91 9a 0a 	lds	r30, 0x0A9A	; 0x800a9a <vtable for Adafruit_BMP280_Temp+0x7f567c>
     3f8:	f0 91 9b 0a 	lds	r31, 0x0A9B	; 0x800a9b <vtable for Adafruit_BMP280_Temp+0x7f567d>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:283
      flags = _timer->INTFLAGS;
     3fc:	80 91 96 0a 	lds	r24, 0x0A96	; 0x800a96 <vtable for Adafruit_BMP280_Temp+0x7f5678>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:293
     * doesn't matter.
     * Get current number of overflows and timer count */
    #if !(defined(MILLIS_USE_TIMERB0) || defined(MILLIS_USE_TIMERB1))
      overflows = timer_overflow_count;
    #else
      overflows = timer_millis;
     400:	20 91 06 38 	lds	r18, 0x3806	; 0x803806 <__data_end>
     404:	30 91 07 38 	lds	r19, 0x3807	; 0x803807 <__data_end+0x1>
     408:	40 91 08 38 	lds	r20, 0x3808	; 0x803808 <__data_end+0x2>
     40c:	50 91 09 38 	lds	r21, 0x3809	; 0x803809 <__data_end+0x3>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:296
    #endif
    /* Turn interrupts back on, assuming they were on when micros was called. */
    SREG = oldSREG; /* INTERRUPTS ON */
     410:	9f bf       	out	0x3f, r25	; 63
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:303
      if ((flags & TCD_OVF_bm) && (ticks < 0x07)) {
    #elif defined(MILLIS_USE_TIMERA0)
      ticks = (TIME_TRACKING_TIMER_PERIOD) - ticks;
      if ((flags & TCA_SPLIT_HUNF_bm) && (ticks < 0x4)) {
    #else // timerb
      if ((flags & TCB_CAPT_bm) && !(ticks & 0xFF00)) {
     412:	80 ff       	sbrs	r24, 0
     414:	08 c0       	rjmp	.+16     	; 0x426 <__LOCK_REGION_LENGTH__+0x26>
     416:	cf 01       	movw	r24, r30
     418:	88 27       	eor	r24, r24
     41a:	89 2b       	or	r24, r25
     41c:	21 f4       	brne	.+8      	; 0x426 <__LOCK_REGION_LENGTH__+0x26>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:308
    #endif
      #if ((defined(MILLIS_USE_TIMERB0) || defined(MILLIS_USE_TIMERB1)) && (F_CPU <= 1000000))
        overflows += 2;
      #else
        overflows++;
     41e:	2f 5f       	subi	r18, 0xFF	; 255
     420:	3f 4f       	sbci	r19, 0xFF	; 255
     422:	4f 4f       	sbci	r20, 0xFF	; 255
     424:	5f 4f       	sbci	r21, 0xFF	; 255
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:530
       * 46 replaced with 25 save 21 clocks @ 10 = 2.5 us saved
       * 56 replaced with 27 save 29 clocks @ 20 = 1.5 us saved
       * 66 replaced with 29 save 37 clocks @ 40 = 1 us saved
       */
      #elif (F_CPU == 40000000UL || F_CPU == 20000000UL || F_CPU == 10000000UL || F_CPU == 5000000UL)
        __asm__ __volatile__(
     426:	0f 01       	movw	r0, r30
     428:	16 94       	lsr	r1
     42a:	07 94       	ror	r0
     42c:	16 94       	lsr	r1
     42e:	07 94       	ror	r0
     430:	16 94       	lsr	r1
     432:	07 94       	ror	r0
     434:	f0 01       	movw	r30, r0
     436:	16 94       	lsr	r1
     438:	07 94       	ror	r0
     43a:	16 94       	lsr	r1
     43c:	07 94       	ror	r0
     43e:	e0 19       	sub	r30, r0
     440:	f1 09       	sbc	r31, r1
     442:	16 94       	lsr	r1
     444:	07 94       	ror	r0
     446:	06 94       	lsr	r0
     448:	10 2c       	mov	r1, r0
     44a:	16 94       	lsr	r1
     44c:	16 94       	lsr	r1
     44e:	01 18       	sub	r0, r1
     450:	16 94       	lsr	r1
     452:	16 94       	lsr	r1
     454:	01 0c       	add	r0, r1
     456:	11 24       	eor	r1, r1
     458:	e0 0d       	add	r30, r0
     45a:	f1 1d       	adc	r31, r1
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:567
          "add r0,r1"     "\n\t"  // + ticks >> 8
          "eor r1,r1"     "\n\t"  // restore zero_reg
          "add %A0,r0"    "\n\t"  // add to the shifted ticks
          "adc %B0,r1"    "\n"    // carry
          : "+r" (ticks));        // Do the rest in C
        microseconds = overflows * 1000 + ticks;
     45c:	a8 ee       	ldi	r26, 0xE8	; 232
     45e:	b3 e0       	ldi	r27, 0x03	; 3
     460:	0e 94 34 17 	call	0x2e68	; 0x2e68 <__muluhisi3>
     464:	6e 0f       	add	r22, r30
     466:	7f 1f       	adc	r23, r31
     468:	81 1d       	adc	r24, r1
     46a:	91 1d       	adc	r25, r1
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:656
        microseconds = ((overflows * millisClockCyclesToMicroseconds(TIME_TRACKING_CYCLES_PER_OVF))
                      + (ticks * (millisClockCyclesToMicroseconds(TIME_TRACKING_CYCLES_PER_OVF) / TIME_TRACKING_TIMER_PERIOD)));
      #endif
    #endif // end of timer-specific part of micros calculations
    return microseconds;
  }
     46c:	08 95       	ret

0000046e <delay>:
delay():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:724
        _delay_ms(1);
      }
    }
  }
#elif (PROGMEM_SIZE >= 16384 && !defined(MILLIS_USE_TIMERRTC))
  void delay(uint32_t ms) { /* Interrupts will not prolong this less flash-efficient delay */
     46e:	cf 92       	push	r12
     470:	df 92       	push	r13
     472:	ef 92       	push	r14
     474:	ff 92       	push	r15
     476:	cf 93       	push	r28
     478:	df 93       	push	r29
     47a:	6b 01       	movw	r12, r22
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:725
    uint16_t start = (uint16_t) micros();
     47c:	7c 01       	movw	r14, r24
     47e:	b8 df       	rcall	.-144    	; 0x3f0 <micros>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:727
    while (ms > 0) {
      while (((uint16_t) micros() - start) >= 1000 && ms) {
     480:	eb 01       	movw	r28, r22
     482:	b6 df       	rcall	.-148    	; 0x3f0 <micros>
     484:	6c 1b       	sub	r22, r28
     486:	7d 0b       	sbc	r23, r29
     488:	68 3e       	cpi	r22, 0xE8	; 232
     48a:	73 40       	sbci	r23, 0x03	; 3
     48c:	a0 f0       	brcs	.+40     	; 0x4b6 <delay+0x48>
     48e:	c1 14       	cp	r12, r1
     490:	d1 04       	cpc	r13, r1
     492:	e1 04       	cpc	r14, r1
     494:	f1 04       	cpc	r15, r1
     496:	39 f4       	brne	.+14     	; 0x4a6 <delay+0x38>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:732
        ms-- ;
        start += 1000;
      }
    }
  }
     498:	df 91       	pop	r29
     49a:	cf 91       	pop	r28
     49c:	ff 90       	pop	r15
     49e:	ef 90       	pop	r14
     4a0:	df 90       	pop	r13
     4a2:	cf 90       	pop	r12
     4a4:	08 95       	ret
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:728
#elif (PROGMEM_SIZE >= 16384 && !defined(MILLIS_USE_TIMERRTC))
  void delay(uint32_t ms) { /* Interrupts will not prolong this less flash-efficient delay */
    uint16_t start = (uint16_t) micros();
    while (ms > 0) {
      while (((uint16_t) micros() - start) >= 1000 && ms) {
        ms-- ;
     4a6:	81 e0       	ldi	r24, 0x01	; 1
     4a8:	c8 1a       	sub	r12, r24
     4aa:	d1 08       	sbc	r13, r1
     4ac:	e1 08       	sbc	r14, r1
     4ae:	f1 08       	sbc	r15, r1
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:729
        start += 1000;
     4b0:	c8 51       	subi	r28, 0x18	; 24
     4b2:	dc 4f       	sbci	r29, 0xFC	; 252
     4b4:	e6 cf       	rjmp	.-52     	; 0x482 <delay+0x14>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:726
    }
  }
#elif (PROGMEM_SIZE >= 16384 && !defined(MILLIS_USE_TIMERRTC))
  void delay(uint32_t ms) { /* Interrupts will not prolong this less flash-efficient delay */
    uint16_t start = (uint16_t) micros();
    while (ms > 0) {
     4b6:	c1 14       	cp	r12, r1
     4b8:	d1 04       	cpc	r13, r1
     4ba:	e1 04       	cpc	r14, r1
     4bc:	f1 04       	cpc	r15, r1
     4be:	09 f7       	brne	.-62     	; 0x482 <delay+0x14>
     4c0:	eb cf       	rjmp	.-42     	; 0x498 <delay+0x2a>

000004c2 <TwoWire::flush()>:
_ZN7TwoWire5flushEv():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:153
    _data->_module->SCTRLA  = 0x00;
    _data->_module->MCTRLA  = temp_MCTRLA;
    _data->_module->MSTATUS = 0x01;  // force TWI state machine into idle state
    _data->_module->SCTRLA  = temp_SCTRLA;
  #else
  _data->_module->MCTRLB |= TWI_FLUSH_bm;
     4c2:	dc 01       	movw	r26, r24
     4c4:	1c 96       	adiw	r26, 0x0c	; 12
     4c6:	ed 91       	ld	r30, X+
     4c8:	fc 91       	ld	r31, X
     4ca:	84 81       	ldd	r24, Z+4	; 0x04
     4cc:	88 60       	ori	r24, 0x08	; 8
     4ce:	84 83       	std	Z+4, r24	; 0x04
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:545
 *@return     void
 */
void TwoWire::flush(void) {
  /* Turn off and on TWI module */
  TWI_Flush(&vars);
}
     4d0:	08 95       	ret

000004d2 <TwoWire::peek()>:
_ZN7TwoWire4peekEv():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:523
      rxTail   = &(vars._bytesReadWritten);
      rxBuffer =   vars._trBuffer;
    #else                                        // Separate tx/rx Buffers
      rxHead   = &(vars._bytesToRead);
      rxTail   = &(vars._bytesRead);
      rxBuffer =   vars._rxBuffer;
     4d2:	9c 01       	movw	r18, r24
     4d4:	28 5c       	subi	r18, 0xC8	; 200
     4d6:	3f 4f       	sbci	r19, 0xFF	; 255
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:527
    #endif
  }

  if ((*rxTail) < (*rxHead)) {   // if there are bytes to read
     4d8:	dc 01       	movw	r26, r24
     4da:	52 96       	adiw	r26, 0x12	; 18
     4dc:	ec 91       	ld	r30, X
     4de:	52 97       	sbiw	r26, 0x12	; 18
     4e0:	51 96       	adiw	r26, 0x11	; 17
     4e2:	8c 91       	ld	r24, X
     4e4:	e8 17       	cp	r30, r24
     4e6:	30 f4       	brcc	.+12     	; 0x4f4 <TwoWire::peek()+0x22>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:528
    return rxBuffer[(*rxTail)];
     4e8:	e2 0f       	add	r30, r18
     4ea:	f3 2f       	mov	r31, r19
     4ec:	f1 1d       	adc	r31, r1
     4ee:	80 81       	ld	r24, Z
     4f0:	90 e0       	ldi	r25, 0x00	; 0
     4f2:	08 95       	ret
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:530
  } else {      // No bytes to read
    return -1;
     4f4:	8f ef       	ldi	r24, 0xFF	; 255
     4f6:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:532
  }
}
     4f8:	08 95       	ret

000004fa <TwoWire::read()>:
_ZN7TwoWire4readEv():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:454
 *@param      void
 *
 *@return     int
 *@retval     byte in the buffer or -1 if buffer is empty
 */
int TwoWire::read(void) {
     4fa:	fc 01       	movw	r30, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:475
      rxTail   = &(vars._bytesReadWritten);
      rxBuffer =   vars._trBuffer;
    #else                                        // Separate tx/rx Buffers
      rxHead   = &(vars._bytesToRead);
      rxTail   = &(vars._bytesRead);
      rxBuffer =   vars._rxBuffer;
     4fc:	dc 01       	movw	r26, r24
     4fe:	d8 96       	adiw	r26, 0x38	; 56
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:480
    #endif
  }


  if ((*rxTail) < (*rxHead)) {   // if there are bytes to read
     500:	92 89       	ldd	r25, Z+18	; 0x12
     502:	81 89       	ldd	r24, Z+17	; 0x11
     504:	98 17       	cp	r25, r24
     506:	40 f4       	brcc	.+16     	; 0x518 <TwoWire::read()+0x1e>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:481
    uint8_t c = rxBuffer[(*rxTail)];
     508:	a9 0f       	add	r26, r25
     50a:	b1 1d       	adc	r27, r1
     50c:	2c 91       	ld	r18, X
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:482
    (*rxTail)++;
     50e:	9f 5f       	subi	r25, 0xFF	; 255
     510:	92 8b       	std	Z+18, r25	; 0x12
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:483
    return c;
     512:	82 2f       	mov	r24, r18
     514:	90 e0       	ldi	r25, 0x00	; 0
     516:	08 95       	ret
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:485
  } else {                      // No bytes to read. At this point, rxTail moved up to
    return -1;                  // rxHead. To reset both to 0, a MasterRead or AddrWrite has to be called
     518:	8f ef       	ldi	r24, 0xFF	; 255
     51a:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:487
  }
}
     51c:	08 95       	ret

0000051e <TwoWire::available()>:
_ZN7TwoWire9availableEv():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:423
 *@param      void
 *
 *@return     int
 *@retval     amount of bytes available to read from the host buffer
 */
int TwoWire::available(void) {
     51e:	fc 01       	movw	r30, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:434
  #endif
  {
    #if defined(TWI_MERGE_BUFFERS)                // Same Buffers for tx/rx
      rxHead  = vars._bytesToReadWrite - vars._bytesReadWritten;
    #else                                         // Separate tx/rx Buffers
      rxHead  = vars._bytesToRead - vars._bytesRead;
     520:	81 89       	ldd	r24, Z+17	; 0x11
     522:	92 89       	ldd	r25, Z+18	; 0x12
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:438
    #endif
  }
  return rxHead;
}
     524:	89 1b       	sub	r24, r25
     526:	99 0b       	sbc	r25, r25
     528:	08 95       	ret

0000052a <TwoWire::write(unsigned char const*, unsigned int)>:
_ZN7TwoWire5writeEPKhj():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:399
 *
 *
 *@return     uint8_t
 *@retval     amount of bytes copied
 */
size_t TwoWire::write(const uint8_t *data, size_t quantity) {
     52a:	cf 92       	push	r12
     52c:	df 92       	push	r13
     52e:	ef 92       	push	r14
     530:	ff 92       	push	r15
     532:	0f 93       	push	r16
     534:	1f 93       	push	r17
     536:	cf 93       	push	r28
     538:	6c 01       	movw	r12, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:401
  uint8_t i = 0;  // uint8_t since we don't use bigger buffers
  uint8_t qty = quantity > BUFFER_LENGTH ? BUFFER_LENGTH : quantity; //Don't overfill the buffer.
     53a:	41 32       	cpi	r20, 0x21	; 33
     53c:	51 05       	cpc	r21, r1
     53e:	10 f0       	brcs	.+4      	; 0x544 <TwoWire::write(unsigned char const*, unsigned int)+0x1a>
     540:	40 e2       	ldi	r20, 0x20	; 32
     542:	50 e0       	ldi	r21, 0x00	; 0
     544:	c4 2f       	mov	r28, r20
     546:	7b 01       	movw	r14, r22
     548:	10 e0       	ldi	r17, 0x00	; 0
     54a:	00 e0       	ldi	r16, 0x00	; 0
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:402
  for (; i < qty; i++) {
     54c:	0c 17       	cp	r16, r28
     54e:	80 f4       	brcc	.+32     	; 0x570 <TwoWire::write(unsigned char const*, unsigned int)+0x46>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:403
    if (write(*(data + i)) == 0) break;   // break if buffer full
     550:	d7 01       	movw	r26, r14
     552:	6d 91       	ld	r22, X+
     554:	7d 01       	movw	r14, r26
     556:	d6 01       	movw	r26, r12
     558:	ed 91       	ld	r30, X+
     55a:	fc 91       	ld	r31, X
     55c:	01 90       	ld	r0, Z+
     55e:	f0 81       	ld	r31, Z
     560:	e0 2d       	mov	r30, r0
     562:	c6 01       	movw	r24, r12
     564:	09 95       	icall
     566:	98 01       	movw	r18, r16
     568:	2f 5f       	subi	r18, 0xFF	; 255
     56a:	3f 4f       	sbci	r19, 0xFF	; 255
     56c:	89 2b       	or	r24, r25
     56e:	49 f4       	brne	.+18     	; 0x582 <TwoWire::write(unsigned char const*, unsigned int)+0x58>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:407
  }

  return i;
}
     570:	c8 01       	movw	r24, r16
     572:	cf 91       	pop	r28
     574:	1f 91       	pop	r17
     576:	0f 91       	pop	r16
     578:	ff 90       	pop	r15
     57a:	ef 90       	pop	r14
     57c:	df 90       	pop	r13
     57e:	cf 90       	pop	r12
     580:	08 95       	ret
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:403
 */
size_t TwoWire::write(const uint8_t *data, size_t quantity) {
  uint8_t i = 0;  // uint8_t since we don't use bigger buffers
  uint8_t qty = quantity > BUFFER_LENGTH ? BUFFER_LENGTH : quantity; //Don't overfill the buffer.
  for (; i < qty; i++) {
    if (write(*(data + i)) == 0) break;   // break if buffer full
     582:	89 01       	movw	r16, r18
     584:	e3 cf       	rjmp	.-58     	; 0x54c <TwoWire::write(unsigned char const*, unsigned int)+0x22>

00000586 <TwoWire::write(unsigned char)>:
_ZN7TwoWire5writeEh():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:355
 *
 *
 *@return     uint8_t
 *@retval     1 if successful, 0 if the buffer is full
 */
size_t TwoWire::write(uint8_t data) {
     586:	fc 01       	movw	r30, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:377
    #endif
  }

  /* Put byte in txBuffer */

  if ((*txHead) < BUFFER_LENGTH) {      // while buffer not full, write to it
     588:	a0 89       	ldd	r26, Z+16	; 0x10
     58a:	a0 32       	cpi	r26, 0x20	; 32
     58c:	58 f4       	brcc	.+22     	; 0x5a4 <TwoWire::write(unsigned char)+0x1e>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:378
    txBuffer[(*txHead)] = data;             // Load data into the buffer
     58e:	a8 0f       	add	r26, r24
     590:	b9 2f       	mov	r27, r25
     592:	b1 1d       	adc	r27, r1
     594:	58 96       	adiw	r26, 0x18	; 24
     596:	6c 93       	st	X, r22
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:379
    (*txHead)++;                            // advancing the head
     598:	80 89       	ldd	r24, Z+16	; 0x10
     59a:	8f 5f       	subi	r24, 0xFF	; 255
     59c:	80 8b       	std	Z+16, r24	; 0x10
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:380
    return 1;
     59e:	81 e0       	ldi	r24, 0x01	; 1
     5a0:	90 e0       	ldi	r25, 0x00	; 0
     5a2:	08 95       	ret
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:382
  } else {
    return 0;
     5a4:	90 e0       	ldi	r25, 0x00	; 0
     5a6:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:384
  }
}
     5a8:	08 95       	ret

000005aa <Print::availableForWrite()>:
_ZN5Print17availableForWriteEv():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.h:65
      return write((const uint8_t *)buffer, size);
    }

    // default to zero, meaning "a single write may block"
    // should be overridden by subclasses with buffering
    virtual int availableForWrite() { return 0; }
     5aa:	90 e0       	ldi	r25, 0x00	; 0
     5ac:	80 e0       	ldi	r24, 0x00	; 0
     5ae:	08 95       	ret

000005b0 <TWI_MasterRead>:
TWI_MasterRead():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:374
 *            bool send_stop enables the STOP condition at the end of a write
 *
 *@return     uint8_t
 *@retval     amount of bytes that were actually read. If 0, no read took place due to a bus error
 */
uint8_t TWI_MasterRead(struct twiData *_data, uint8_t bytesToRead, bool send_stop) {
     5b0:	1f 93       	push	r17
     5b2:	cf 93       	push	r28
     5b4:	df 93       	push	r29
     5b6:	dc 01       	movw	r26, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:385
    uint8_t* rxHead   = &(_data->_bytesToRead);
    uint8_t* rxTail   = &(_data->_bytesRead);
    uint8_t* rxBuffer =   _data->_rxBuffer;
  #endif

  (*rxTail) = 0;                      // Reset counter
     5b8:	16 96       	adiw	r26, 0x06	; 6
     5ba:	1c 92       	st	X, r1
     5bc:	16 97       	sbiw	r26, 0x06	; 6
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:387

  TWI_t *module = _data->_module;     // Compiler treats the pointer to the TWI module as volatile and
     5be:	ed 91       	ld	r30, X+
     5c0:	fc 91       	ld	r31, X
     5c2:	11 97       	sbiw	r26, 0x01	; 1
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:392
                                      // creates bloat-y code, using a local variable fixes that

  TWIR_INIT_ERROR;             // local variable for errors
  uint8_t dataRead = 0;
  if ((module->MSTATUS & TWI_BUSSTATE_gm) != TWI_BUSSTATE_UNKNOWN_gc) {
     5c4:	85 81       	ldd	r24, Z+5	; 0x05
     5c6:	83 70       	andi	r24, 0x03	; 3
     5c8:	09 f4       	brne	.+2      	; 0x5cc <TWI_MasterRead+0x1c>
     5ca:	41 c0       	rjmp	.+130    	; 0x64e <TWI_MasterRead+0x9e>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:398
    uint8_t currentSM;
    uint8_t currentStatus;
    uint8_t command  = 0;
    uint16_t timeout = 0;

    module->MADDR = ADD_READ_BIT(_data->_clientAddress);  // Send Address with read bit
     5cc:	13 96       	adiw	r26, 0x03	; 3
     5ce:	8c 91       	ld	r24, X
     5d0:	13 97       	sbiw	r26, 0x03	; 3
     5d2:	81 60       	ori	r24, 0x01	; 1
     5d4:	87 83       	std	Z+7, r24	; 0x07
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:396
  uint8_t dataRead = 0;
  if ((module->MSTATUS & TWI_BUSSTATE_gm) != TWI_BUSSTATE_UNKNOWN_gc) {
    uint8_t currentSM;
    uint8_t currentStatus;
    uint8_t command  = 0;
    uint16_t timeout = 0;
     5d6:	30 e0       	ldi	r19, 0x00	; 0
     5d8:	20 e0       	ldi	r18, 0x00	; 0
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:395
  TWIR_INIT_ERROR;             // local variable for errors
  uint8_t dataRead = 0;
  if ((module->MSTATUS & TWI_BUSSTATE_gm) != TWI_BUSSTATE_UNKNOWN_gc) {
    uint8_t currentSM;
    uint8_t currentStatus;
    uint8_t command  = 0;
     5da:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:391

  TWI_t *module = _data->_module;     // Compiler treats the pointer to the TWI module as volatile and
                                      // creates bloat-y code, using a local variable fixes that

  TWIR_INIT_ERROR;             // local variable for errors
  uint8_t dataRead = 0;
     5dc:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:439
            rxBuffer[dataRead] = module->MDATA;      // save byte in the Buffer.
            dataRead++;                              // increment read counter
            timeout = 0;                             // reset timeout

            if (dataRead < bytesToRead) {            // expecting more bytes, so
              module->MCTRLB = TWI_MCMD_RECVTRANS_gc;  // send an ACK so the Slave so it can send the next byte
     5de:	12 e0       	ldi	r17, 0x02	; 2
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:401
    uint16_t timeout = 0;

    module->MADDR = ADD_READ_BIT(_data->_clientAddress);  // Send Address with read bit

    while (true) {
      currentStatus = module->MSTATUS;
     5e0:	55 81       	ldd	r21, Z+5	; 0x05
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:402
      currentSM = currentStatus & TWI_BUSSTATE_gm;  // get the current mode of the state machine
     5e2:	75 2f       	mov	r23, r21
     5e4:	73 70       	andi	r23, 0x03	; 3
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:405

      #if defined(TWI_TIMEOUT_ENABLE)
        if (++timeout > (F_CPU/1000)) {
     5e6:	2f 5f       	subi	r18, 0xFF	; 255
     5e8:	3f 4f       	sbci	r19, 0xFF	; 255
     5ea:	21 32       	cpi	r18, 0x21	; 33
     5ec:	ce e4       	ldi	r28, 0x4E	; 78
     5ee:	3c 07       	cpc	r19, r28
     5f0:	28 f4       	brcc	.+10     	; 0x5fc <TWI_MasterRead+0x4c>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:417
          }
          break;
        }
      #endif

      if (currentStatus & (TWI_ARBLOST_bm | TWI_BUSERR_bm)) {   // Check for Bus error
     5f2:	d5 2f       	mov	r29, r21
     5f4:	dc 70       	andi	r29, 0x0C	; 12
     5f6:	41 f0       	breq	.+16     	; 0x608 <TWI_MasterRead+0x58>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:418
        module->MSTATUS = (TWI_ARBLOST_bm | TWI_BUSERR_bm);     // reset error flags
     5f8:	9c e0       	ldi	r25, 0x0C	; 12
     5fa:	95 83       	std	Z+5, r25	; 0x05
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:458
          TWIR_SET_ERROR(TWI_ERR_RXACK);          // set error flag
          command = TWI_MCMD_STOP_gc;             // free the bus
        }
      }
    }
    (*rxHead) = dataRead;
     5fc:	15 96       	adiw	r26, 0x05	; 5
     5fe:	8c 93       	st	X, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:466
  }
  #if defined(TWI_READ_ERROR_ENABLED) && defined(TWI_ERROR_ENABLED)
    _data->_errors = TWIR_GET_ERROR;                // save error flags
  #endif
  return dataRead;
}
     600:	df 91       	pop	r29
     602:	cf 91       	pop	r28
     604:	1f 91       	pop	r17
     606:	08 95       	ret
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:423
        module->MSTATUS = (TWI_ARBLOST_bm | TWI_BUSERR_bm);     // reset error flags
        TWIR_SET_ERROR(TWI_ERR_BUS_ARB);                        // set error flag
        break;                                                  // leave TX loop
      }

      if (command != 0) {
     608:	99 23       	and	r25, r25
     60a:	a1 f0       	breq	.+40     	; 0x634 <TWI_MasterRead+0x84>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:424
        if (currentSM == TWI_BUSSTATE_OWNER_gc) {
     60c:	72 30       	cpi	r23, 0x02	; 2
     60e:	b1 f7       	brne	.-20     	; 0x5fc <TWI_MasterRead+0x4c>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:425
          module->MCTRLB = command;
     610:	94 83       	std	Z+4, r25	; 0x04
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:432
          break;
        }
      }

      if (currentSM == TWI_BUSSTATE_OWNER_gc) {  // Address sent, check for WIF/RIF
        if (currentStatus & TWI_RIF_bm) {         // data received
     612:	57 ff       	sbrs	r21, 7
     614:	18 c0       	rjmp	.+48     	; 0x646 <TWI_MasterRead+0x96>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:433
          if (dataRead < BUFFER_LENGTH) {          // Buffer still free
     616:	80 32       	cpi	r24, 0x20	; 32
     618:	a0 f4       	brcc	.+40     	; 0x642 <TWI_MasterRead+0x92>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:434
            rxBuffer[dataRead] = module->MDATA;      // save byte in the Buffer.
     61a:	50 85       	ldd	r21, Z+8	; 0x08
     61c:	9d 01       	movw	r18, r26
     61e:	28 0f       	add	r18, r24
     620:	31 1d       	adc	r19, r1
     622:	e9 01       	movw	r28, r18
     624:	5c a7       	std	Y+44, r21	; 0x2c
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:435
            dataRead++;                              // increment read counter
     626:	8f 5f       	subi	r24, 0xFF	; 255
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:438
            timeout = 0;                             // reset timeout

            if (dataRead < bytesToRead) {            // expecting more bytes, so
     628:	86 17       	cp	r24, r22
     62a:	38 f4       	brcc	.+14     	; 0x63a <TWI_MasterRead+0x8a>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:439
              module->MCTRLB = TWI_MCMD_RECVTRANS_gc;  // send an ACK so the Slave so it can send the next byte
     62c:	14 83       	std	Z+4, r17	; 0x04
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:436
      if (currentSM == TWI_BUSSTATE_OWNER_gc) {  // Address sent, check for WIF/RIF
        if (currentStatus & TWI_RIF_bm) {         // data received
          if (dataRead < BUFFER_LENGTH) {          // Buffer still free
            rxBuffer[dataRead] = module->MDATA;      // save byte in the Buffer.
            dataRead++;                              // increment read counter
            timeout = 0;                             // reset timeout
     62e:	30 e0       	ldi	r19, 0x00	; 0
     630:	20 e0       	ldi	r18, 0x00	; 0
     632:	d6 cf       	rjmp	.-84     	; 0x5e0 <TWI_MasterRead+0x30>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:431
        } else {
          break;
        }
      }

      if (currentSM == TWI_BUSSTATE_OWNER_gc) {  // Address sent, check for WIF/RIF
     634:	72 30       	cpi	r23, 0x02	; 2
     636:	a1 f6       	brne	.-88     	; 0x5e0 <TWI_MasterRead+0x30>
     638:	ec cf       	rjmp	.-40     	; 0x612 <TWI_MasterRead+0x62>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:441
            timeout = 0;                             // reset timeout

            if (dataRead < bytesToRead) {            // expecting more bytes, so
              module->MCTRLB = TWI_MCMD_RECVTRANS_gc;  // send an ACK so the Slave so it can send the next byte
            } else {                                 // Otherwise,
              if (send_stop != 0) {
     63a:	44 23       	and	r20, r20
     63c:	f9 f2       	breq	.-66     	; 0x5fc <TWI_MasterRead+0x4c>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:436
      if (currentSM == TWI_BUSSTATE_OWNER_gc) {  // Address sent, check for WIF/RIF
        if (currentStatus & TWI_RIF_bm) {         // data received
          if (dataRead < BUFFER_LENGTH) {          // Buffer still free
            rxBuffer[dataRead] = module->MDATA;      // save byte in the Buffer.
            dataRead++;                              // increment read counter
            timeout = 0;                             // reset timeout
     63e:	30 e0       	ldi	r19, 0x00	; 0
     640:	20 e0       	ldi	r18, 0x00	; 0
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:442

            if (dataRead < bytesToRead) {            // expecting more bytes, so
              module->MCTRLB = TWI_MCMD_RECVTRANS_gc;  // send an ACK so the Slave so it can send the next byte
            } else {                                 // Otherwise,
              if (send_stop != 0) {
                command = TWI_ACKACT_bm | TWI_MCMD_STOP_gc;   // send STOP + NACK
     642:	97 e0       	ldi	r25, 0x07	; 7
     644:	cd cf       	rjmp	.-102    	; 0x5e0 <TWI_MasterRead+0x30>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:452

          } else {                                        // Buffer overflow with the incoming byte
            TWIR_SET_ERROR(TWI_ERR_BUF_OVERFLOW);         // Set Error and
            command = TWI_ACKACT_bm | TWI_MCMD_STOP_gc;   // send STOP + NACK
          }
        } else if (currentStatus & TWI_WIF_bm) {  // Address NACKed
     646:	56 ff       	sbrs	r21, 6
     648:	cb cf       	rjmp	.-106    	; 0x5e0 <TWI_MasterRead+0x30>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:454
          TWIR_SET_ERROR(TWI_ERR_RXACK);          // set error flag
          command = TWI_MCMD_STOP_gc;             // free the bus
     64a:	93 e0       	ldi	r25, 0x03	; 3
     64c:	c9 cf       	rjmp	.-110    	; 0x5e0 <TWI_MasterRead+0x30>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:391

  TWI_t *module = _data->_module;     // Compiler treats the pointer to the TWI module as volatile and
                                      // creates bloat-y code, using a local variable fixes that

  TWIR_INIT_ERROR;             // local variable for errors
  uint8_t dataRead = 0;
     64e:	80 e0       	ldi	r24, 0x00	; 0
     650:	d7 cf       	rjmp	.-82     	; 0x600 <TWI_MasterRead+0x50>

00000652 <TWI_MasterWrite>:
TWI_MasterWrite():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:275
 *
 *@return     uint8_t
 *@retval     amount of bytes that were written. If 0, no write took place, either due
 *            to an error or because of an empty txBuffer
 */
uint8_t TWI_MasterWrite(struct twiData *_data, bool send_stop)  {
     652:	cf 93       	push	r28
     654:	df 93       	push	r29
     656:	dc 01       	movw	r26, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:284
  #else                                                       // Separate tx/rx Buffers
    uint8_t* txHead   = &(_data->_bytesToWrite);
    uint8_t* txBuffer =   _data->_txBuffer;
  #endif

  TWI_t *module = _data->_module;     // Compiler treats the pointer to the TWI module as volatile and
     658:	ed 91       	ld	r30, X+
     65a:	fc 91       	ld	r31, X
     65c:	11 97       	sbiw	r26, 0x01	; 1
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:293
  uint8_t currentStatus;
  uint8_t dataWritten = 0;
  uint16_t timeout = 0;


  if ((module->MSTATUS & TWI_BUSSTATE_gm) == TWI_BUSSTATE_UNKNOWN_gc) {
     65e:	85 81       	ldd	r24, Z+5	; 0x05
     660:	83 70       	andi	r24, 0x03	; 3
     662:	09 f4       	brne	.+2      	; 0x666 <TWI_MasterWrite+0x14>
     664:	41 c0       	rjmp	.+130    	; 0x6e8 <TWI_MasterWrite+0x96>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:290
                                      // creates bloat-y code, this fixes it
  TWI_INIT_ERROR;
  uint8_t currentSM;
  uint8_t currentStatus;
  uint8_t dataWritten = 0;
  uint16_t timeout = 0;
     666:	30 e0       	ldi	r19, 0x00	; 0
     668:	20 e0       	ldi	r18, 0x00	; 0
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:289
  TWI_t *module = _data->_module;     // Compiler treats the pointer to the TWI module as volatile and
                                      // creates bloat-y code, this fixes it
  TWI_INIT_ERROR;
  uint8_t currentSM;
  uint8_t currentStatus;
  uint8_t dataWritten = 0;
     66a:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:299
    return TWI_ERR_UNINIT;                     // If the bus was not initialized, return
  }


  while (true) {
    currentStatus = module->MSTATUS;
     66c:	45 81       	ldd	r20, Z+5	; 0x05
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:300
    currentSM = currentStatus & TWI_BUSSTATE_gm;  // get the current mode of the state machine
     66e:	84 2f       	mov	r24, r20
     670:	83 70       	andi	r24, 0x03	; 3
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:303

    #if defined(TWI_TIMEOUT_ENABLE)
      if (++timeout > (F_CPU/1000)) {
     672:	2f 5f       	subi	r18, 0xFF	; 255
     674:	3f 4f       	sbci	r19, 0xFF	; 255
     676:	21 32       	cpi	r18, 0x21	; 33
     678:	5e e4       	ldi	r21, 0x4E	; 78
     67a:	35 07       	cpc	r19, r21
     67c:	50 f0       	brcs	.+20     	; 0x692 <TWI_MasterWrite+0x40>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:304
        if        (currentSM == TWI_BUSSTATE_OWNER_gc) {
     67e:	82 30       	cpi	r24, 0x02	; 2
     680:	79 f1       	breq	.+94     	; 0x6e0 <TWI_MasterWrite+0x8e>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:306
          TWI_SET_ERROR(TWI_ERR_TIMEOUT);
        } else if (currentSM == TWI_BUSSTATE_IDLE_gc) {
     682:	81 30       	cpi	r24, 0x01	; 1
     684:	79 f1       	breq	.+94     	; 0x6e4 <TWI_MasterWrite+0x92>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:309
          TWI_SET_ERROR(TWI_ERR_PULLUP);
        } else {
          TWI_SET_ERROR(TWI_ERR_UNDEFINED);
     686:	84 e0       	ldi	r24, 0x04	; 4
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:346
    }
  }


  if ((send_stop != 0) || (TWI_ERR_SUCCESS != TWI_GET_ERROR)) {
    module->MCTRLB = TWI_MCMD_STOP_gc;                        // Send STOP
     688:	93 e0       	ldi	r25, 0x03	; 3
     68a:	94 83       	std	Z+4, r25	; 0x04
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:349
  }
  return TWI_GET_ERROR;
}
     68c:	df 91       	pop	r29
     68e:	cf 91       	pop	r28
     690:	08 95       	ret
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:315
        }
        break;
      }
    #endif

    if   (currentStatus & (TWI_ARBLOST_bm | TWI_BUSERR_bm)) {     // Check for Bus error
     692:	54 2f       	mov	r21, r20
     694:	5c 70       	andi	r21, 0x0C	; 12
     696:	21 f0       	breq	.+8      	; 0x6a0 <TWI_MasterWrite+0x4e>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:316
        module->MSTATUS = (TWI_ARBLOST_bm | TWI_BUSERR_bm);       // reset error flags
     698:	8c e0       	ldi	r24, 0x0C	; 12
     69a:	85 83       	std	Z+5, r24	; 0x05
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:317
        TWI_SET_ERROR(TWI_ERR_BUS_ARB);                           // set error flag
     69c:	82 e1       	ldi	r24, 0x12	; 18
     69e:	f4 cf       	rjmp	.-24     	; 0x688 <TWI_MasterWrite+0x36>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:321
        break;                                                    // leave RX loop
    }

    if (currentSM == TWI_BUSSTATE_IDLE_gc) {                      // Bus has not sent START yet and is not BUSY
     6a0:	81 30       	cpi	r24, 0x01	; 1
     6a2:	41 f4       	brne	.+16     	; 0x6b4 <TWI_MasterWrite+0x62>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:322
        module->MADDR = ADD_WRITE_BIT(_data->_clientAddress);
     6a4:	13 96       	adiw	r26, 0x03	; 3
     6a6:	8c 91       	ld	r24, X
     6a8:	13 97       	sbiw	r26, 0x03	; 3
     6aa:	8e 7f       	andi	r24, 0xFE	; 254
     6ac:	87 83       	std	Z+7, r24	; 0x07
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:334
          break;                                                  // leave loop
        } else {                                                  // otherwise WRITE was ACKed
          if (dataWritten < (*txHead)) {                          // check if there is data to be written
            module->MDATA = txBuffer[dataWritten];                // Writing to the register to send data
            dataWritten++;                                        // data was Written
            timeout = 0;                                          // reset timeout
     6ae:	30 e0       	ldi	r19, 0x00	; 0
     6b0:	20 e0       	ldi	r18, 0x00	; 0
     6b2:	dc cf       	rjmp	.-72     	; 0x66c <TWI_MasterWrite+0x1a>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:324
    }

    if (currentSM == TWI_BUSSTATE_IDLE_gc) {                      // Bus has not sent START yet and is not BUSY
        module->MADDR = ADD_WRITE_BIT(_data->_clientAddress);
        timeout = 0;
    } else if (currentSM == TWI_BUSSTATE_OWNER_gc) {              // Address was sent, host is owner
     6b4:	82 30       	cpi	r24, 0x02	; 2
     6b6:	d1 f6       	brne	.-76     	; 0x66c <TWI_MasterWrite+0x1a>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:325
      if     (currentStatus & TWI_WIF_bm) {                       // data sent
     6b8:	46 ff       	sbrs	r20, 6
     6ba:	d8 cf       	rjmp	.-80     	; 0x66c <TWI_MasterWrite+0x1a>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:326
        if   (currentStatus & TWI_RXACK_bm) {                     // AND the RXACK bit is set, last byte has failed
     6bc:	44 ff       	sbrs	r20, 4
     6be:	04 c0       	rjmp	.+8      	; 0x6c8 <TWI_MasterWrite+0x76>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:327
          if (dataWritten == 0) TWI_SET_ERROR(TWI_ERR_ACK_ADR);   // if dataWritten is 0, no payload was sent, so address was NACKed
     6c0:	99 23       	and	r25, r25
     6c2:	11 f3       	breq	.-60     	; 0x688 <TWI_MasterWrite+0x36>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:328
          else                  TWI_SET_ERROR(TWI_ERR_ACK_DAT);   // else payload was NACKed
     6c4:	83 e0       	ldi	r24, 0x03	; 3
     6c6:	e0 cf       	rjmp	.-64     	; 0x688 <TWI_MasterWrite+0x36>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:331
          break;                                                  // leave loop
        } else {                                                  // otherwise WRITE was ACKed
          if (dataWritten < (*txHead)) {                          // check if there is data to be written
     6c8:	14 96       	adiw	r26, 0x04	; 4
     6ca:	8c 91       	ld	r24, X
     6cc:	14 97       	sbiw	r26, 0x04	; 4
     6ce:	98 17       	cp	r25, r24
     6d0:	68 f4       	brcc	.+26     	; 0x6ec <TWI_MasterWrite+0x9a>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:332
            module->MDATA = txBuffer[dataWritten];                // Writing to the register to send data
     6d2:	ed 01       	movw	r28, r26
     6d4:	c9 0f       	add	r28, r25
     6d6:	d1 1d       	adc	r29, r1
     6d8:	8c 85       	ldd	r24, Y+12	; 0x0c
     6da:	80 87       	std	Z+8, r24	; 0x08
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:333
            dataWritten++;                                        // data was Written
     6dc:	9f 5f       	subi	r25, 0xFF	; 255
     6de:	e7 cf       	rjmp	.-50     	; 0x6ae <TWI_MasterWrite+0x5c>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:305
    currentSM = currentStatus & TWI_BUSSTATE_gm;  // get the current mode of the state machine

    #if defined(TWI_TIMEOUT_ENABLE)
      if (++timeout > (F_CPU/1000)) {
        if        (currentSM == TWI_BUSSTATE_OWNER_gc) {
          TWI_SET_ERROR(TWI_ERR_TIMEOUT);
     6e0:	85 e0       	ldi	r24, 0x05	; 5
     6e2:	d2 cf       	rjmp	.-92     	; 0x688 <TWI_MasterWrite+0x36>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:307
        } else if (currentSM == TWI_BUSSTATE_IDLE_gc) {
          TWI_SET_ERROR(TWI_ERR_PULLUP);
     6e4:	81 e1       	ldi	r24, 0x11	; 17
     6e6:	d0 cf       	rjmp	.-96     	; 0x688 <TWI_MasterWrite+0x36>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:294
  uint8_t dataWritten = 0;
  uint16_t timeout = 0;


  if ((module->MSTATUS & TWI_BUSSTATE_gm) == TWI_BUSSTATE_UNKNOWN_gc) {
    return TWI_ERR_UNINIT;                     // If the bus was not initialized, return
     6e8:	80 e1       	ldi	r24, 0x10	; 16
     6ea:	d0 cf       	rjmp	.-96     	; 0x68c <TWI_MasterWrite+0x3a>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:286
    uint8_t* txBuffer =   _data->_txBuffer;
  #endif

  TWI_t *module = _data->_module;     // Compiler treats the pointer to the TWI module as volatile and
                                      // creates bloat-y code, this fixes it
  TWI_INIT_ERROR;
     6ec:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:345
      }
    }
  }


  if ((send_stop != 0) || (TWI_ERR_SUCCESS != TWI_GET_ERROR)) {
     6ee:	66 23       	and	r22, r22
     6f0:	69 f2       	breq	.-102    	; 0x68c <TWI_MasterWrite+0x3a>
     6f2:	ca cf       	rjmp	.-108    	; 0x688 <TWI_MasterWrite+0x36>

000006f4 <Adafruit_SPIDevice::transfer(unsigned char)>:
_ZN18Adafruit_SPIDevice8transferEh():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:262
/*!
 *    @brief  Transfer (send/receive) one byte over hard/soft SPI
 *    @param  send The byte to send
 *    @return The byte received while transmitting
 */
uint8_t Adafruit_SPIDevice::transfer(uint8_t send) {
     6f4:	af 92       	push	r10
     6f6:	bf 92       	push	r11
     6f8:	cf 92       	push	r12
     6fa:	df 92       	push	r13
     6fc:	ef 92       	push	r14
     6fe:	ff 92       	push	r15
     700:	0f 93       	push	r16
     702:	1f 93       	push	r17
     704:	cf 93       	push	r28
     706:	df 93       	push	r29
     708:	ec 01       	movw	r28, r24
transfer():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:126
 *    @brief  Transfer (send/receive) one byte over hard/soft SPI
 *    @param  buffer The buffer to send and receive at the same time
 *    @param  len    The number of bytes to transfer
 */
void Adafruit_SPIDevice::transfer(uint8_t *buffer, size_t len) {
  if (_spi) {
     70a:	88 81       	ld	r24, Y
     70c:	99 81       	ldd	r25, Y+1	; 0x01
     70e:	89 2b       	or	r24, r25
     710:	a9 f0       	breq	.+42     	; 0x73c <Adafruit_SPIDevice::transfer(unsigned char)+0x48>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:310
    The following NOP introduces a small delay that can prevent the wait
    loop from iterating when running at the maximum speed. This gives
    about 10% more speed, even if it seems counter-intuitive. At lower
    speeds it is unnoticed.
  */
  asm volatile("nop");
     712:	00 00       	nop
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:312

  SPI0.DATA = data;
     714:	60 93 c4 08 	sts	0x08C4, r22	; 0x8008c4 <vtable for Adafruit_BMP280_Temp+0x7f54a6>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:313
  while ((SPI0.INTFLAGS & SPI_RXCIF_bm) == 0);  // wait for complete send
     718:	80 91 c3 08 	lds	r24, 0x08C3	; 0x8008c3 <vtable for Adafruit_BMP280_Temp+0x7f54a5>
     71c:	87 ff       	sbrs	r24, 7
     71e:	fc cf       	rjmp	.-8      	; 0x718 <Adafruit_SPIDevice::transfer(unsigned char)+0x24>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:314
  return SPI0.DATA;                             // read data back
     720:	b0 90 c4 08 	lds	r11, 0x08C4	; 0x8008c4 <vtable for Adafruit_BMP280_Temp+0x7f54a6>
_ZN18Adafruit_SPIDevice8transferEh():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:266
 */
uint8_t Adafruit_SPIDevice::transfer(uint8_t send) {
  uint8_t data = send;
  transfer(&data, 1);
  return data;
}
     724:	8b 2d       	mov	r24, r11
     726:	df 91       	pop	r29
     728:	cf 91       	pop	r28
     72a:	1f 91       	pop	r17
     72c:	0f 91       	pop	r16
     72e:	ff 90       	pop	r15
     730:	ef 90       	pop	r14
     732:	df 90       	pop	r13
     734:	cf 90       	pop	r12
     736:	bf 90       	pop	r11
     738:	af 90       	pop	r10
     73a:	08 95       	ret
transfer():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:142
#endif
    return;
  }

  uint8_t startbit;
  if (_dataOrder == SPI_BITORDER_LSBFIRST) {
     73c:	88 85       	ldd	r24, Y+8	; 0x08
     73e:	99 85       	ldd	r25, Y+9	; 0x09
_ZN18Adafruit_SPIDevice8transferEh():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:143
    startbit = 0x1;
     740:	11 e0       	ldi	r17, 0x01	; 1
transfer():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:142
#endif
    return;
  }

  uint8_t startbit;
  if (_dataOrder == SPI_BITORDER_LSBFIRST) {
     742:	89 2b       	or	r24, r25
     744:	09 f0       	breq	.+2      	; 0x748 <Adafruit_SPIDevice::transfer(unsigned char)+0x54>
_ZN18Adafruit_SPIDevice8transferEh():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:145
    startbit = 0x1;
  } else {
    startbit = 0x80;
     746:	10 e8       	ldi	r17, 0x80	; 128
transfer():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:148
  }

  bool towrite, lastmosi = !(buffer[0] & startbit);
     748:	aa 24       	eor	r10, r10
     74a:	a3 94       	inc	r10
     74c:	86 2f       	mov	r24, r22
     74e:	81 23       	and	r24, r17
     750:	09 f0       	breq	.+2      	; 0x754 <Adafruit_SPIDevice::transfer(unsigned char)+0x60>
     752:	a1 2c       	mov	r10, r1
     754:	06 2f       	mov	r16, r22
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:149
  uint8_t bitdelay_us = (1000000 / _freq) / 2;
     756:	2c 81       	ldd	r18, Y+4	; 0x04
     758:	3d 81       	ldd	r19, Y+5	; 0x05
     75a:	4e 81       	ldd	r20, Y+6	; 0x06
     75c:	5f 81       	ldd	r21, Y+7	; 0x07
     75e:	60 e2       	ldi	r22, 0x20	; 32
     760:	71 ea       	ldi	r23, 0xA1	; 161
     762:	87 e0       	ldi	r24, 0x07	; 7
     764:	90 e0       	ldi	r25, 0x00	; 0
     766:	0e 94 12 17 	call	0x2e24	; 0x2e24 <__udivmodsi4>
     76a:	f2 2e       	mov	r15, r18
_ZN18Adafruit_SPIDevice8transferEh():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:263
 *    @brief  Transfer (send/receive) one byte over hard/soft SPI
 *    @param  send The byte to send
 *    @return The byte received while transmitting
 */
uint8_t Adafruit_SPIDevice::transfer(uint8_t send) {
  uint8_t data = send;
     76c:	b0 2e       	mov	r11, r16
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:154
  uint8_t bitdelay_us = (1000000 / _freq) / 2;

  // for softSPI we'll do it by hand
  for (size_t i = 0; i < len; i++) {
    // software SPI
    uint8_t reply = 0;
     76e:	e1 2c       	mov	r14, r1
transfer():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:168
    // Serial.print(send, HEX);
    for (uint8_t b = startbit; b != 0;
         b = (_dataOrder == SPI_BITORDER_LSBFIRST) ? b << 1 : b >> 1) {

      if (bitdelay_us) {
        delayMicroseconds(bitdelay_us);
     770:	c2 2e       	mov	r12, r18
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:167

    // Serial.print(send, HEX);
    for (uint8_t b = startbit; b != 0;
         b = (_dataOrder == SPI_BITORDER_LSBFIRST) ? b << 1 : b >> 1) {

      if (bitdelay_us) {
     772:	d1 2c       	mov	r13, r1
     774:	ff 20       	and	r15, r15
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:753
inline __attribute__((always_inline)) void delayMicroseconds(unsigned int us) {
  // This function gets optimized away, but to what depends on whether us is constant.
  if (__builtin_constant_p(us)) {
    _delay_us(us); // Constant microseconds use the avr-libc _delay_us() which is highly accurate for all values and efficient!
  } else { // If it is not, we have to use the Arduino style implementation.
    _delayMicroseconds(us);
     776:	11 f0       	breq	.+4      	; 0x77c <Adafruit_SPIDevice::transfer(unsigned char)+0x88>
delayMicroseconds():
     778:	c6 01       	movw	r24, r12
     77a:	2c de       	rcall	.-936    	; 0x3d4 <_delayMicroseconds>
transfer():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:171
        delayMicroseconds(bitdelay_us);
      }

      if (_dataMode == SPI_MODE0 || _dataMode == SPI_MODE2) {
     77c:	8a 85       	ldd	r24, Y+10	; 0x0a
     77e:	8d 7f       	andi	r24, 0xFD	; 253
     780:	09 f0       	breq	.+2      	; 0x784 <Adafruit_SPIDevice::transfer(unsigned char)+0x90>
     782:	41 c0       	rjmp	.+130    	; 0x806 <__DATA_REGION_LENGTH__+0x6>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:173
        towrite = send & b;
        if ((_mosi != -1) && (lastmosi != towrite)) {
     784:	8d 85       	ldd	r24, Y+13	; 0x0d
     786:	8f 3f       	cpi	r24, 0xFF	; 255
     788:	89 f0       	breq	.+34     	; 0x7ac <Adafruit_SPIDevice::transfer(unsigned char)+0xb8>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:172
      if (bitdelay_us) {
        delayMicroseconds(bitdelay_us);
      }

      if (_dataMode == SPI_MODE0 || _dataMode == SPI_MODE2) {
        towrite = send & b;
     78a:	90 2f       	mov	r25, r16
     78c:	91 23       	and	r25, r17
     78e:	81 e0       	ldi	r24, 0x01	; 1
     790:	09 f4       	brne	.+2      	; 0x794 <Adafruit_SPIDevice::transfer(unsigned char)+0xa0>
     792:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:173
        if ((_mosi != -1) && (lastmosi != towrite)) {
     794:	8a 15       	cp	r24, r10
     796:	51 f0       	breq	.+20     	; 0x7ac <Adafruit_SPIDevice::transfer(unsigned char)+0xb8>
     798:	ef 85       	ldd	r30, Y+15	; 0x0f
     79a:	f8 89       	ldd	r31, Y+16	; 0x10
     79c:	8f 89       	ldd	r24, Y+23	; 0x17
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:175
#ifdef BUSIO_USE_FAST_PINIO
          if (towrite)
     79e:	99 23       	and	r25, r25
     7a0:	61 f1       	breq	.+88     	; 0x7fa <Adafruit_SPIDevice::transfer(unsigned char)+0x106>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:176
            *mosiPort |= mosiPinMask;
     7a2:	90 81       	ld	r25, Z
     7a4:	89 2b       	or	r24, r25
     7a6:	80 83       	st	Z, r24
     7a8:	aa 24       	eor	r10, r10
     7aa:	a3 94       	inc	r10
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:186
#endif
          lastmosi = towrite;
        }

#ifdef BUSIO_USE_FAST_PINIO
        *clkPort |= clkPinMask; // Clock high
     7ac:	e9 89       	ldd	r30, Y+17	; 0x11
     7ae:	fa 89       	ldd	r31, Y+18	; 0x12
     7b0:	80 81       	ld	r24, Z
     7b2:	99 8d       	ldd	r25, Y+25	; 0x19
     7b4:	89 2b       	or	r24, r25
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:191
#else
        digitalWrite(_sck, HIGH);
#endif

        if (bitdelay_us) {
     7b6:	80 83       	st	Z, r24
     7b8:	ff 20       	and	r15, r15
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:753
     7ba:	11 f0       	breq	.+4      	; 0x7c0 <Adafruit_SPIDevice::transfer(unsigned char)+0xcc>
delayMicroseconds():
     7bc:	c6 01       	movw	r24, r12
     7be:	0a de       	rcall	.-1004   	; 0x3d4 <_delayMicroseconds>
transfer():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:195
          delayMicroseconds(bitdelay_us);
        }

        if (_miso != -1) {
     7c0:	8e 85       	ldd	r24, Y+14	; 0x0e
     7c2:	8f 3f       	cpi	r24, 0xFF	; 255
     7c4:	39 f0       	breq	.+14     	; 0x7d4 <Adafruit_SPIDevice::transfer(unsigned char)+0xe0>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:197
#ifdef BUSIO_USE_FAST_PINIO
          if (*misoPort & misoPinMask) {
     7c6:	eb 89       	ldd	r30, Y+19	; 0x13
     7c8:	fc 89       	ldd	r31, Y+20	; 0x14
     7ca:	80 81       	ld	r24, Z
     7cc:	98 8d       	ldd	r25, Y+24	; 0x18
     7ce:	89 23       	and	r24, r25
     7d0:	09 f0       	breq	.+2      	; 0x7d4 <Adafruit_SPIDevice::transfer(unsigned char)+0xe0>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:201
#else
          if (digitalRead(_miso)) {
#endif
            reply |= b;
     7d2:	e1 2a       	or	r14, r17
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:206
          }
        }

#ifdef BUSIO_USE_FAST_PINIO
        *clkPort &= ~clkPinMask; // Clock low
     7d4:	e9 89       	ldd	r30, Y+17	; 0x11
     7d6:	fa 89       	ldd	r31, Y+18	; 0x12
     7d8:	90 81       	ld	r25, Z
     7da:	89 8d       	ldd	r24, Y+25	; 0x19
     7dc:	80 95       	com	r24
     7de:	89 23       	and	r24, r25
     7e0:	80 83       	st	Z, r24
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:249
#endif
            reply |= b;
          }
        }
      }
      if (_miso != -1) {
     7e2:	8e 85       	ldd	r24, Y+14	; 0x0e
     7e4:	8f 3f       	cpi	r24, 0xFF	; 255
     7e6:	09 f0       	breq	.+2      	; 0x7ea <Adafruit_SPIDevice::transfer(unsigned char)+0xf6>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:250
        buffer[i] = reply;
     7e8:	be 2c       	mov	r11, r14
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:164
    Serial.print(send, HEX);
    Serial.print(" -> 0x");
    */

    // Serial.print(send, HEX);
    for (uint8_t b = startbit; b != 0;
     7ea:	88 85       	ldd	r24, Y+8	; 0x08
     7ec:	99 85       	ldd	r25, Y+9	; 0x09
     7ee:	89 2b       	or	r24, r25
     7f0:	b1 f5       	brne	.+108    	; 0x85e <__DATA_REGION_LENGTH__+0x5e>
     7f2:	11 0f       	add	r17, r17
     7f4:	11 11       	cpse	r17, r1
     7f6:	be cf       	rjmp	.-132    	; 0x774 <Adafruit_SPIDevice::transfer(unsigned char)+0x80>
     7f8:	95 cf       	rjmp	.-214    	; 0x724 <Adafruit_SPIDevice::transfer(unsigned char)+0x30>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:178
        if ((_mosi != -1) && (lastmosi != towrite)) {
#ifdef BUSIO_USE_FAST_PINIO
          if (towrite)
            *mosiPort |= mosiPinMask;
          else
            *mosiPort &= ~mosiPinMask;
     7fa:	90 81       	ld	r25, Z
     7fc:	80 95       	com	r24
     7fe:	89 23       	and	r24, r25
     800:	80 83       	st	Z, r24
     802:	a1 2c       	mov	r10, r1
     804:	d3 cf       	rjmp	.-90     	; 0x7ac <Adafruit_SPIDevice::transfer(unsigned char)+0xb8>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:213
        digitalWrite(_sck, LOW);
#endif
      } else { // if (_dataMode == SPI_MODE1 || _dataMode == SPI_MODE3)

#ifdef BUSIO_USE_FAST_PINIO
        *clkPort |= clkPinMask; // Clock high
     806:	e9 89       	ldd	r30, Y+17	; 0x11
     808:	fa 89       	ldd	r31, Y+18	; 0x12
     80a:	80 81       	ld	r24, Z
     80c:	99 8d       	ldd	r25, Y+25	; 0x19
     80e:	89 2b       	or	r24, r25
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:218
#else
        digitalWrite(_sck, HIGH);
#endif

        if (bitdelay_us) {
     810:	80 83       	st	Z, r24
     812:	ff 20       	and	r15, r15
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:753
     814:	11 f0       	breq	.+4      	; 0x81a <__DATA_REGION_LENGTH__+0x1a>
delayMicroseconds():
     816:	c6 01       	movw	r24, r12
     818:	dd dd       	rcall	.-1094   	; 0x3d4 <_delayMicroseconds>
transfer():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:222
          delayMicroseconds(bitdelay_us);
        }

        if (_mosi != -1) {
     81a:	8d 85       	ldd	r24, Y+13	; 0x0d
     81c:	8f 3f       	cpi	r24, 0xFF	; 255
     81e:	49 f0       	breq	.+18     	; 0x832 <__DATA_REGION_LENGTH__+0x32>
     820:	ef 85       	ldd	r30, Y+15	; 0x0f
     822:	f8 89       	ldd	r31, Y+16	; 0x10
     824:	8f 89       	ldd	r24, Y+23	; 0x17
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:224
#ifdef BUSIO_USE_FAST_PINIO
          if (send & b)
     826:	90 2f       	mov	r25, r16
     828:	91 23       	and	r25, r17
     82a:	a9 f0       	breq	.+42     	; 0x856 <__DATA_REGION_LENGTH__+0x56>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:225
            *mosiPort |= mosiPinMask;
     82c:	90 81       	ld	r25, Z
     82e:	89 2b       	or	r24, r25
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:227
          else
            *mosiPort &= ~mosiPinMask;
     830:	80 83       	st	Z, r24
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:234
          digitalWrite(_mosi, send & b);
#endif
        }

#ifdef BUSIO_USE_FAST_PINIO
        *clkPort &= ~clkPinMask; // Clock low
     832:	e9 89       	ldd	r30, Y+17	; 0x11
     834:	fa 89       	ldd	r31, Y+18	; 0x12
     836:	90 81       	ld	r25, Z
     838:	89 8d       	ldd	r24, Y+25	; 0x19
     83a:	80 95       	com	r24
     83c:	89 23       	and	r24, r25
     83e:	80 83       	st	Z, r24
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:239
#else
        digitalWrite(_sck, LOW);
#endif

        if (_miso != -1) {
     840:	8e 85       	ldd	r24, Y+14	; 0x0e
     842:	8f 3f       	cpi	r24, 0xFF	; 255
     844:	71 f2       	breq	.-100    	; 0x7e2 <Adafruit_SPIDevice::transfer(unsigned char)+0xee>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:241
#ifdef BUSIO_USE_FAST_PINIO
          if (*misoPort & misoPinMask) {
     846:	eb 89       	ldd	r30, Y+19	; 0x13
     848:	fc 89       	ldd	r31, Y+20	; 0x14
     84a:	80 81       	ld	r24, Z
     84c:	98 8d       	ldd	r25, Y+24	; 0x18
     84e:	89 23       	and	r24, r25
     850:	41 f2       	breq	.-112    	; 0x7e2 <Adafruit_SPIDevice::transfer(unsigned char)+0xee>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:245
#else
          if (digitalRead(_miso)) {
#endif
            reply |= b;
     852:	e1 2a       	or	r14, r17
     854:	c6 cf       	rjmp	.-116    	; 0x7e2 <Adafruit_SPIDevice::transfer(unsigned char)+0xee>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:227
        if (_mosi != -1) {
#ifdef BUSIO_USE_FAST_PINIO
          if (send & b)
            *mosiPort |= mosiPinMask;
          else
            *mosiPort &= ~mosiPinMask;
     856:	90 81       	ld	r25, Z
     858:	80 95       	com	r24
     85a:	89 23       	and	r24, r25
     85c:	e9 cf       	rjmp	.-46     	; 0x830 <__DATA_REGION_LENGTH__+0x30>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:164
    Serial.print(send, HEX);
    Serial.print(" -> 0x");
    */

    // Serial.print(send, HEX);
    for (uint8_t b = startbit; b != 0;
     85e:	16 95       	lsr	r17
     860:	c9 cf       	rjmp	.-110    	; 0x7f4 <Adafruit_SPIDevice::transfer(unsigned char)+0x100>

00000862 <Adafruit_BMP280_Temp::~Adafruit_BMP280_Temp()>:
_ZN24Adafruit_BMP280_PressureD2Ev():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.h:105
  int _sensorID = 280;
  Adafruit_BMP280 *_theBMP280 = NULL;
};

/** Adafruit Unified Sensor interface for pressure component of BMP280 */
class Adafruit_BMP280_Pressure : public Adafruit_Sensor {
     862:	08 95       	ret

00000864 <Adafruit_Sensor::enableAutoRange(bool)>:
_ZN15Adafruit_Sensor15enableAutoRangeEb():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_Unified_Sensor/Adafruit_Sensor.h:174
  /*! @brief Whether we should automatically change the range (if possible) for
     higher precision
      @param enabled True if we will try to autorange */
  virtual void enableAutoRange(bool enabled) {
    (void)enabled; /* suppress unused warning */
  };
     864:	08 95       	ret

00000866 <SPIClass::endTransaction()>:
_ZN8SPIClass14endTransactionEv():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:275
    }
  }
  config(settings);
}

void SPIClass::endTransaction(void) {
     866:	8f 92       	push	r8
     868:	9f 92       	push	r9
     86a:	af 92       	push	r10
     86c:	bf 92       	push	r11
     86e:	cf 92       	push	r12
     870:	df 92       	push	r13
     872:	ef 92       	push	r14
     874:	ff 92       	push	r15
     876:	0f 93       	push	r16
     878:	1f 93       	push	r17
     87a:	cf 93       	push	r28
     87c:	df 93       	push	r29
     87e:	fc 01       	movw	r30, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:276
  if (interruptMode != SPI_IMODE_NONE) {
     880:	86 81       	ldd	r24, Z+6	; 0x06
     882:	88 23       	and	r24, r24
     884:	19 f0       	breq	.+6      	; 0x88c <SPIClass::endTransaction()+0x26>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:277
    if (interruptMode & SPI_IMODE_GLOBAL) {
     886:	81 ff       	sbrs	r24, 1
     888:	0e c0       	rjmp	.+28     	; 0x8a6 <SPIClass::endTransaction()+0x40>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:278
      interrupts();
     88a:	78 94       	sei
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:283
    } else if (interruptMode & SPI_IMODE_EXTINT) {
      reattachMaskedInterrupts();
    }
  }
}
     88c:	df 91       	pop	r29
     88e:	cf 91       	pop	r28
     890:	1f 91       	pop	r17
     892:	0f 91       	pop	r16
     894:	ff 90       	pop	r15
     896:	ef 90       	pop	r14
     898:	df 90       	pop	r13
     89a:	cf 90       	pop	r12
     89c:	bf 90       	pop	r11
     89e:	af 90       	pop	r10
     8a0:	9f 90       	pop	r9
     8a2:	8f 90       	pop	r8
     8a4:	08 95       	ret
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:279

void SPIClass::endTransaction(void) {
  if (interruptMode != SPI_IMODE_NONE) {
    if (interruptMode & SPI_IMODE_GLOBAL) {
      interrupts();
    } else if (interruptMode & SPI_IMODE_EXTINT) {
     8a6:	80 ff       	sbrs	r24, 0
     8a8:	f1 cf       	rjmp	.-30     	; 0x88c <SPIClass::endTransaction()+0x26>
reattachMaskedInterrupts():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:242
    shift++;
  }
}

void SPIClass::reattachMaskedInterrupts() {
  uint64_t temp = interruptMask_lo;
     8aa:	80 84       	ldd	r8, Z+8	; 0x08
     8ac:	91 84       	ldd	r9, Z+9	; 0x09
     8ae:	a2 84       	ldd	r10, Z+10	; 0x0a
     8b0:	b3 84       	ldd	r11, Z+11	; 0x0b
     8b2:	c1 2c       	mov	r12, r1
     8b4:	d1 2c       	mov	r13, r1
     8b6:	76 01       	movw	r14, r12
_ZN8SPIClass14endTransactionEv():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:243
  uint8_t shift = 0;
     8b8:	10 e0       	ldi	r17, 0x00	; 0
reattachMaskedInterrupts():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:244
  while (temp != 0) {
     8ba:	94 01       	movw	r18, r8
     8bc:	a5 01       	movw	r20, r10
     8be:	b6 01       	movw	r22, r12
     8c0:	c7 01       	movw	r24, r14
     8c2:	a0 e0       	ldi	r26, 0x00	; 0
     8c4:	0e 94 75 18 	call	0x30ea	; 0x30ea <__cmpdi2_s8>
     8c8:	99 f1       	breq	.+102    	; 0x930 <SPIClass::endTransaction()+0xca>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:245
    if (temp & 1) {
     8ca:	21 70       	andi	r18, 0x01	; 1
     8cc:	30 e0       	ldi	r19, 0x00	; 0
     8ce:	40 e0       	ldi	r20, 0x00	; 0
     8d0:	50 e0       	ldi	r21, 0x00	; 0
     8d2:	60 e0       	ldi	r22, 0x00	; 0
     8d4:	70 e0       	ldi	r23, 0x00	; 0
     8d6:	80 e0       	ldi	r24, 0x00	; 0
     8d8:	90 e0       	ldi	r25, 0x00	; 0
     8da:	0e 94 75 18 	call	0x30ea	; 0x30ea <__cmpdi2_s8>
     8de:	d9 f0       	breq	.+54     	; 0x916 <SPIClass::endTransaction()+0xb0>
_ZN8SPIClass14endTransactionEv():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:246
      volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(portToPortStruct(shift / 8), shift % 8);
     8e0:	d0 e0       	ldi	r29, 0x00	; 0
     8e2:	c0 e0       	ldi	r28, 0x00	; 0
reattachMaskedInterrupts():
     8e4:	18 33       	cpi	r17, 0x38	; 56
     8e6:	70 f4       	brcc	.+28     	; 0x904 <SPIClass::endTransaction()+0x9e>
     8e8:	c1 2f       	mov	r28, r17
     8ea:	c6 95       	lsr	r28
     8ec:	c6 95       	lsr	r28
     8ee:	c6 95       	lsr	r28
     8f0:	80 e2       	ldi	r24, 0x20	; 32
     8f2:	c8 9f       	mul	r28, r24
     8f4:	e0 01       	movw	r28, r0
     8f6:	11 24       	eor	r1, r1
     8f8:	c0 5f       	subi	r28, 0xF0	; 240
     8fa:	db 4f       	sbci	r29, 0xFB	; 251
     8fc:	81 2f       	mov	r24, r17
     8fe:	87 70       	andi	r24, 0x07	; 7
     900:	c8 0f       	add	r28, r24
     902:	d1 1d       	adc	r29, r1
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:247
      *pin_ctrl_reg |= irqMap[shift];
     904:	cf 01       	movw	r24, r30
     906:	81 0f       	add	r24, r17
     908:	91 1d       	adc	r25, r1
     90a:	dc 01       	movw	r26, r24
     90c:	50 96       	adiw	r26, 0x10	; 16
     90e:	8c 91       	ld	r24, X
     910:	98 81       	ld	r25, Y
     912:	89 2b       	or	r24, r25
     914:	88 83       	st	Y, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:249
    }
    temp = temp >> 1;
     916:	94 01       	movw	r18, r8
     918:	a5 01       	movw	r20, r10
     91a:	b6 01       	movw	r22, r12
     91c:	c7 01       	movw	r24, r14
     91e:	01 e0       	ldi	r16, 0x01	; 1
     920:	0e 94 48 18 	call	0x3090	; 0x3090 <__lshrdi3>
     924:	49 01       	movw	r8, r18
     926:	5a 01       	movw	r10, r20
     928:	6b 01       	movw	r12, r22
     92a:	7c 01       	movw	r14, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:250
    shift++;
     92c:	1f 5f       	subi	r17, 0xFF	; 255
     92e:	c5 cf       	rjmp	.-118    	; 0x8ba <SPIClass::endTransaction()+0x54>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:252
  }
  temp = interruptMask_hi;
     930:	84 84       	ldd	r8, Z+12	; 0x0c
     932:	95 84       	ldd	r9, Z+13	; 0x0d
     934:	a6 84       	ldd	r10, Z+14	; 0x0e
     936:	b7 84       	ldd	r11, Z+15	; 0x0f
     938:	c1 2c       	mov	r12, r1
     93a:	d1 2c       	mov	r13, r1
     93c:	76 01       	movw	r14, r12
_ZN8SPIClass14endTransactionEv():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:253
  shift = 32;
     93e:	10 e2       	ldi	r17, 0x20	; 32
reattachMaskedInterrupts():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:254
  while (temp != 0) {
     940:	94 01       	movw	r18, r8
     942:	a5 01       	movw	r20, r10
     944:	b6 01       	movw	r22, r12
     946:	c7 01       	movw	r24, r14
     948:	a0 e0       	ldi	r26, 0x00	; 0
     94a:	0e 94 75 18 	call	0x30ea	; 0x30ea <__cmpdi2_s8>
     94e:	09 f4       	brne	.+2      	; 0x952 <SPIClass::endTransaction()+0xec>
     950:	9d cf       	rjmp	.-198    	; 0x88c <SPIClass::endTransaction()+0x26>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:255
    if (temp & 1) {
     952:	21 70       	andi	r18, 0x01	; 1
     954:	30 e0       	ldi	r19, 0x00	; 0
     956:	40 e0       	ldi	r20, 0x00	; 0
     958:	50 e0       	ldi	r21, 0x00	; 0
     95a:	60 e0       	ldi	r22, 0x00	; 0
     95c:	70 e0       	ldi	r23, 0x00	; 0
     95e:	80 e0       	ldi	r24, 0x00	; 0
     960:	90 e0       	ldi	r25, 0x00	; 0
     962:	0e 94 75 18 	call	0x30ea	; 0x30ea <__cmpdi2_s8>
     966:	d9 f0       	breq	.+54     	; 0x99e <SPIClass::endTransaction()+0x138>
_ZN8SPIClass14endTransactionEv():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:256
      volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(portToPortStruct(shift / 8), shift % 8);
     968:	d0 e0       	ldi	r29, 0x00	; 0
     96a:	c0 e0       	ldi	r28, 0x00	; 0
reattachMaskedInterrupts():
     96c:	18 33       	cpi	r17, 0x38	; 56
     96e:	70 f4       	brcc	.+28     	; 0x98c <SPIClass::endTransaction()+0x126>
     970:	c1 2f       	mov	r28, r17
     972:	c6 95       	lsr	r28
     974:	c6 95       	lsr	r28
     976:	c6 95       	lsr	r28
     978:	b0 e2       	ldi	r27, 0x20	; 32
     97a:	cb 9f       	mul	r28, r27
     97c:	e0 01       	movw	r28, r0
     97e:	11 24       	eor	r1, r1
     980:	c0 5f       	subi	r28, 0xF0	; 240
     982:	db 4f       	sbci	r29, 0xFB	; 251
     984:	81 2f       	mov	r24, r17
     986:	87 70       	andi	r24, 0x07	; 7
     988:	c8 0f       	add	r28, r24
     98a:	d1 1d       	adc	r29, r1
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:257
      *pin_ctrl_reg |= irqMap[shift];
     98c:	cf 01       	movw	r24, r30
     98e:	81 0f       	add	r24, r17
     990:	91 1d       	adc	r25, r1
     992:	dc 01       	movw	r26, r24
     994:	50 96       	adiw	r26, 0x10	; 16
     996:	8c 91       	ld	r24, X
     998:	98 81       	ld	r25, Y
     99a:	89 2b       	or	r24, r25
     99c:	88 83       	st	Y, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:259
    }
    temp = temp >> 1;
     99e:	94 01       	movw	r18, r8
     9a0:	a5 01       	movw	r20, r10
     9a2:	b6 01       	movw	r22, r12
     9a4:	c7 01       	movw	r24, r14
     9a6:	01 e0       	ldi	r16, 0x01	; 1
     9a8:	0e 94 48 18 	call	0x3090	; 0x3090 <__lshrdi3>
     9ac:	49 01       	movw	r8, r18
     9ae:	5a 01       	movw	r10, r20
     9b0:	6b 01       	movw	r12, r22
     9b2:	7c 01       	movw	r14, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:260
    shift++;
     9b4:	1f 5f       	subi	r17, 0xFF	; 255
     9b6:	c4 cf       	rjmp	.-120    	; 0x940 <SPIClass::endTransaction()+0xda>

000009b8 <SPIClass::beginTransaction(SPISettings)>:
_ZN8SPIClass16beginTransactionE11SPISettings():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:264
  }
}

void SPIClass::beginTransaction(SPISettings settings) {
     9b8:	8f 92       	push	r8
     9ba:	9f 92       	push	r9
     9bc:	af 92       	push	r10
     9be:	bf 92       	push	r11
     9c0:	cf 92       	push	r12
     9c2:	df 92       	push	r13
     9c4:	ef 92       	push	r14
     9c6:	ff 92       	push	r15
     9c8:	0f 93       	push	r16
     9ca:	1f 93       	push	r17
     9cc:	cf 93       	push	r28
     9ce:	df 93       	push	r29
     9d0:	fc 01       	movw	r30, r24
     9d2:	c6 2f       	mov	r28, r22
     9d4:	17 2f       	mov	r17, r23
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:265
  if (interruptMode != SPI_IMODE_NONE) {
     9d6:	86 81       	ldd	r24, Z+6	; 0x06
     9d8:	88 23       	and	r24, r24
     9da:	19 f0       	breq	.+6      	; 0x9e2 <SPIClass::beginTransaction(SPISettings)+0x2a>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:266
    if (interruptMode & SPI_IMODE_GLOBAL) {
     9dc:	81 ff       	sbrs	r24, 1
     9de:	12 c0       	rjmp	.+36     	; 0xa04 <SPIClass::beginTransaction(SPISettings)+0x4c>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:267
      noInterrupts();
     9e0:	f8 94       	cli
config():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:160
  interruptMask_hi = 0;
  initialized = true;
}

void SPIClass::config(SPISettings settings) {
  SPI0.CTRLA = settings.ctrla;
     9e2:	c0 93 c0 08 	sts	0x08C0, r28	; 0x8008c0 <vtable for Adafruit_BMP280_Temp+0x7f54a2>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:161
  SPI0.CTRLB = settings.ctrlb;
     9e6:	10 93 c1 08 	sts	0x08C1, r17	; 0x8008c1 <vtable for Adafruit_BMP280_Temp+0x7f54a3>
_ZN8SPIClass16beginTransactionE11SPISettings():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:273
    } else if (interruptMode & SPI_IMODE_EXTINT) {
      detachMaskedInterrupts();
    }
  }
  config(settings);
}
     9ea:	df 91       	pop	r29
     9ec:	cf 91       	pop	r28
     9ee:	1f 91       	pop	r17
     9f0:	0f 91       	pop	r16
     9f2:	ff 90       	pop	r15
     9f4:	ef 90       	pop	r14
     9f6:	df 90       	pop	r13
     9f8:	cf 90       	pop	r12
     9fa:	bf 90       	pop	r11
     9fc:	af 90       	pop	r10
     9fe:	9f 90       	pop	r9
     a00:	8f 90       	pop	r8
     a02:	08 95       	ret
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:268

void SPIClass::beginTransaction(SPISettings settings) {
  if (interruptMode != SPI_IMODE_NONE) {
    if (interruptMode & SPI_IMODE_GLOBAL) {
      noInterrupts();
    } else if (interruptMode & SPI_IMODE_EXTINT) {
     a04:	80 ff       	sbrs	r24, 0
     a06:	ed cf       	rjmp	.-38     	; 0x9e2 <SPIClass::beginTransaction(SPISettings)+0x2a>
detachMaskedInterrupts():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:217
    #endif
  }
}

void SPIClass::detachMaskedInterrupts() {
  uint64_t temp = interruptMask_lo;
     a08:	80 84       	ldd	r8, Z+8	; 0x08
     a0a:	91 84       	ldd	r9, Z+9	; 0x09
     a0c:	a2 84       	ldd	r10, Z+10	; 0x0a
     a0e:	b3 84       	ldd	r11, Z+11	; 0x0b
     a10:	c1 2c       	mov	r12, r1
     a12:	d1 2c       	mov	r13, r1
     a14:	76 01       	movw	r14, r12
_ZN8SPIClass16beginTransactionE11SPISettings():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:218
  uint8_t shift = 0;
     a16:	d0 e0       	ldi	r29, 0x00	; 0
detachMaskedInterrupts():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:219
  while (temp != 0) {
     a18:	94 01       	movw	r18, r8
     a1a:	a5 01       	movw	r20, r10
     a1c:	b6 01       	movw	r22, r12
     a1e:	c7 01       	movw	r24, r14
     a20:	a0 e0       	ldi	r26, 0x00	; 0
     a22:	0e 94 75 18 	call	0x30ea	; 0x30ea <__cmpdi2_s8>
     a26:	b1 f1       	breq	.+108    	; 0xa94 <SPIClass::beginTransaction(SPISettings)+0xdc>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:220
    if (temp & 1) {
     a28:	21 70       	andi	r18, 0x01	; 1
     a2a:	30 e0       	ldi	r19, 0x00	; 0
     a2c:	40 e0       	ldi	r20, 0x00	; 0
     a2e:	50 e0       	ldi	r21, 0x00	; 0
     a30:	60 e0       	ldi	r22, 0x00	; 0
     a32:	70 e0       	ldi	r23, 0x00	; 0
     a34:	80 e0       	ldi	r24, 0x00	; 0
     a36:	90 e0       	ldi	r25, 0x00	; 0
     a38:	0e 94 75 18 	call	0x30ea	; 0x30ea <__cmpdi2_s8>
     a3c:	f1 f0       	breq	.+60     	; 0xa7a <SPIClass::beginTransaction(SPISettings)+0xc2>
_ZN8SPIClass16beginTransactionE11SPISettings():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:221
      volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(portToPortStruct(shift / 8), shift % 8);
     a3e:	90 e0       	ldi	r25, 0x00	; 0
     a40:	80 e0       	ldi	r24, 0x00	; 0
detachMaskedInterrupts():
     a42:	d8 33       	cpi	r29, 0x38	; 56
     a44:	70 f4       	brcc	.+28     	; 0xa62 <SPIClass::beginTransaction(SPISettings)+0xaa>
     a46:	8d 2f       	mov	r24, r29
     a48:	86 95       	lsr	r24
     a4a:	86 95       	lsr	r24
     a4c:	86 95       	lsr	r24
     a4e:	20 e2       	ldi	r18, 0x20	; 32
     a50:	82 9f       	mul	r24, r18
     a52:	c0 01       	movw	r24, r0
     a54:	11 24       	eor	r1, r1
     a56:	80 5f       	subi	r24, 0xF0	; 240
     a58:	9b 4f       	sbci	r25, 0xFB	; 251
     a5a:	2d 2f       	mov	r18, r29
     a5c:	27 70       	andi	r18, 0x07	; 7
     a5e:	82 0f       	add	r24, r18
     a60:	91 1d       	adc	r25, r1
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:222
      irqMap[shift] = *pin_ctrl_reg;
     a62:	dc 01       	movw	r26, r24
     a64:	4c 91       	ld	r20, X
     a66:	9f 01       	movw	r18, r30
     a68:	2d 0f       	add	r18, r29
     a6a:	31 1d       	adc	r19, r1
     a6c:	d9 01       	movw	r26, r18
     a6e:	50 96       	adiw	r26, 0x10	; 16
     a70:	4c 93       	st	X, r20
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:223
      *pin_ctrl_reg &= ~(PORT_ISC_gm);
     a72:	dc 01       	movw	r26, r24
     a74:	2c 91       	ld	r18, X
     a76:	28 7f       	andi	r18, 0xF8	; 248
     a78:	2c 93       	st	X, r18
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:225
    }
    temp = temp >> 1;
     a7a:	94 01       	movw	r18, r8
     a7c:	a5 01       	movw	r20, r10
     a7e:	b6 01       	movw	r22, r12
     a80:	c7 01       	movw	r24, r14
     a82:	01 e0       	ldi	r16, 0x01	; 1
     a84:	0e 94 48 18 	call	0x3090	; 0x3090 <__lshrdi3>
     a88:	49 01       	movw	r8, r18
     a8a:	5a 01       	movw	r10, r20
     a8c:	6b 01       	movw	r12, r22
     a8e:	7c 01       	movw	r14, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:226
    shift++;
     a90:	df 5f       	subi	r29, 0xFF	; 255
     a92:	c2 cf       	rjmp	.-124    	; 0xa18 <SPIClass::beginTransaction(SPISettings)+0x60>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:228
  }
  temp = interruptMask_hi;
     a94:	84 84       	ldd	r8, Z+12	; 0x0c
     a96:	95 84       	ldd	r9, Z+13	; 0x0d
     a98:	a6 84       	ldd	r10, Z+14	; 0x0e
     a9a:	b7 84       	ldd	r11, Z+15	; 0x0f
     a9c:	c1 2c       	mov	r12, r1
     a9e:	d1 2c       	mov	r13, r1
     aa0:	76 01       	movw	r14, r12
_ZN8SPIClass16beginTransactionE11SPISettings():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:229
  shift = 32;
     aa2:	d0 e2       	ldi	r29, 0x20	; 32
detachMaskedInterrupts():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:230
  while (temp != 0) {
     aa4:	94 01       	movw	r18, r8
     aa6:	a5 01       	movw	r20, r10
     aa8:	b6 01       	movw	r22, r12
     aaa:	c7 01       	movw	r24, r14
     aac:	a0 e0       	ldi	r26, 0x00	; 0
     aae:	0e 94 75 18 	call	0x30ea	; 0x30ea <__cmpdi2_s8>
     ab2:	09 f4       	brne	.+2      	; 0xab6 <SPIClass::beginTransaction(SPISettings)+0xfe>
     ab4:	96 cf       	rjmp	.-212    	; 0x9e2 <SPIClass::beginTransaction(SPISettings)+0x2a>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:231
    if (temp & 1) {
     ab6:	21 70       	andi	r18, 0x01	; 1
     ab8:	30 e0       	ldi	r19, 0x00	; 0
     aba:	40 e0       	ldi	r20, 0x00	; 0
     abc:	50 e0       	ldi	r21, 0x00	; 0
     abe:	60 e0       	ldi	r22, 0x00	; 0
     ac0:	70 e0       	ldi	r23, 0x00	; 0
     ac2:	80 e0       	ldi	r24, 0x00	; 0
     ac4:	90 e0       	ldi	r25, 0x00	; 0
     ac6:	0e 94 75 18 	call	0x30ea	; 0x30ea <__cmpdi2_s8>
     aca:	f1 f0       	breq	.+60     	; 0xb08 <SPIClass::beginTransaction(SPISettings)+0x150>
_ZN8SPIClass16beginTransactionE11SPISettings():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:232
      volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(portToPortStruct(shift / 8), shift % 8);
     acc:	90 e0       	ldi	r25, 0x00	; 0
     ace:	80 e0       	ldi	r24, 0x00	; 0
detachMaskedInterrupts():
     ad0:	d8 33       	cpi	r29, 0x38	; 56
     ad2:	70 f4       	brcc	.+28     	; 0xaf0 <SPIClass::beginTransaction(SPISettings)+0x138>
     ad4:	8d 2f       	mov	r24, r29
     ad6:	86 95       	lsr	r24
     ad8:	86 95       	lsr	r24
     ada:	86 95       	lsr	r24
     adc:	b0 e2       	ldi	r27, 0x20	; 32
     ade:	8b 9f       	mul	r24, r27
     ae0:	c0 01       	movw	r24, r0
     ae2:	11 24       	eor	r1, r1
     ae4:	80 5f       	subi	r24, 0xF0	; 240
     ae6:	9b 4f       	sbci	r25, 0xFB	; 251
     ae8:	2d 2f       	mov	r18, r29
     aea:	27 70       	andi	r18, 0x07	; 7
     aec:	82 0f       	add	r24, r18
     aee:	91 1d       	adc	r25, r1
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:233
      irqMap[shift] = *pin_ctrl_reg;
     af0:	dc 01       	movw	r26, r24
     af2:	4c 91       	ld	r20, X
     af4:	9f 01       	movw	r18, r30
     af6:	2d 0f       	add	r18, r29
     af8:	31 1d       	adc	r19, r1
     afa:	d9 01       	movw	r26, r18
     afc:	50 96       	adiw	r26, 0x10	; 16
     afe:	4c 93       	st	X, r20
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:234
      *pin_ctrl_reg &= ~(PORT_ISC_gm);
     b00:	dc 01       	movw	r26, r24
     b02:	2c 91       	ld	r18, X
     b04:	28 7f       	andi	r18, 0xF8	; 248
     b06:	2c 93       	st	X, r18
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:236
    }
    temp = temp >> 1;
     b08:	94 01       	movw	r18, r8
     b0a:	a5 01       	movw	r20, r10
     b0c:	b6 01       	movw	r22, r12
     b0e:	c7 01       	movw	r24, r14
     b10:	01 e0       	ldi	r16, 0x01	; 1
     b12:	0e 94 48 18 	call	0x3090	; 0x3090 <__lshrdi3>
     b16:	49 01       	movw	r8, r18
     b18:	5a 01       	movw	r10, r20
     b1a:	6b 01       	movw	r12, r22
     b1c:	7c 01       	movw	r14, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:237
    shift++;
     b1e:	df 5f       	subi	r29, 0xFF	; 255
     b20:	c1 cf       	rjmp	.-126    	; 0xaa4 <SPIClass::beginTransaction(SPISettings)+0xec>

00000b22 <UartClass::begin(unsigned long)>:
_ZN9UartClass5beginEm():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.h:257

  public:
    inline             UartClass(volatile USART_t *hwserial_module, uint8_t module_number, uint8_t default_pinset);
    bool                    pins(uint8_t tx, uint8_t rx);
    bool                    swap(uint8_t mux_level = 1);
    void                   begin(uint32_t baud) {begin(baud, SERIAL_8N1);}
     b22:	dc 01       	movw	r26, r24
     b24:	ed 91       	ld	r30, X+
     b26:	fc 91       	ld	r31, X
     b28:	00 88       	ldd	r0, Z+16	; 0x10
     b2a:	f1 89       	ldd	r31, Z+17	; 0x11
     b2c:	e0 2d       	mov	r30, r0
     b2e:	23 e0       	ldi	r18, 0x03	; 3
     b30:	30 e0       	ldi	r19, 0x00	; 0
     b32:	09 94       	ijmp

00000b34 <Adafruit_I2CDevice::begin(bool) [clone .constprop.16]>:
_ZN18Adafruit_I2CDevice5beginEb.constprop.16():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:29
 *    @param  addr_detect Whether we should attempt to detect the I2C address
 * with a scan. 99% of sensors/devices don't mind but once in a while, they spaz
 * on a scan!
 *    @return True if I2C initialized and a device with the addr found
 */
bool Adafruit_I2CDevice::begin(bool addr_detect) {
     b34:	cf 93       	push	r28
     b36:	df 93       	push	r29
     b38:	ec 01       	movw	r28, r24
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:30
  _wire->begin();
     b3a:	a9 81       	ldd	r26, Y+1	; 0x01
     b3c:	ba 81       	ldd	r27, Y+2	; 0x02
TWI_MasterInit():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:58
  #if defined(TWI_MANDS)                            // Check if the user wants to use Master AND Slave
    if (_data->_bools._hostEnabled == 1) {          // Slave is allowed to be enabled, don't re-enable the host though
      return;
    }
  #else                                             // Master OR Slave
    if (_data->_bools._hostEnabled    == 1 ||       // If Master was enabled
     b3e:	1e 96       	adiw	r26, 0x0e	; 14
     b40:	8c 91       	ld	r24, X
     b42:	1e 97       	sbiw	r26, 0x0e	; 14
     b44:	80 76       	andi	r24, 0x60	; 96
     b46:	11 f5       	brne	.+68     	; 0xb8c <Adafruit_I2CDevice::begin(bool) [clone .constprop.16]+0x58>
TWI0_ClearPins():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi_pins.c:110
        PORTB.OUTCLR = 0x03;  // else PB0, PB1
      }
    #elif defined(__AVR_ATtinyxy2__)
      PORTA.OUTCLR = 0x06;  // 8-pin parts always have it on PA1/2
    #else
      PORTB.OUTCLR = 0x03;  // else, zero series, no remapping, it's on PB0, PB1
     b48:	83 e0       	ldi	r24, 0x03	; 3
     b4a:	80 93 26 04 	sts	0x0426, r24	; 0x800426 <vtable for Adafruit_BMP280_Temp+0x7f5008>
TWI_MasterInit():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:75
    }
  #else                                             // Only one TWI is used
    TWI0_ClearPins();                               // Only one option is possible
  #endif

  _data->_bools._hostEnabled    = 1;
     b4e:	1e 96       	adiw	r26, 0x0e	; 14
     b50:	8c 91       	ld	r24, X
     b52:	1e 97       	sbiw	r26, 0x0e	; 14
     b54:	80 62       	ori	r24, 0x20	; 32
     b56:	1e 96       	adiw	r26, 0x0e	; 14
     b58:	8c 93       	st	X, r24
     b5a:	1e 97       	sbiw	r26, 0x0e	; 14
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:76
  _data->_module->MCTRLA        = TWI_ENABLE_bm;  // Master Interrupt flags stay disabled
     b5c:	1c 96       	adiw	r26, 0x0c	; 12
     b5e:	ed 91       	ld	r30, X+
     b60:	fc 91       	ld	r31, X
     b62:	1d 97       	sbiw	r26, 0x0d	; 13
     b64:	81 e0       	ldi	r24, 0x01	; 1
     b66:	83 83       	std	Z+3, r24	; 0x03
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:77
  _data->_module->MSTATUS       = TWI_BUSSTATE_IDLE_gc;
     b68:	85 83       	std	Z+5, r24	; 0x05
TWI_MasterSetBaud():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:235
 *              _module
 *
 *@return     void
 */
void TWI_MasterSetBaud(struct twiData *_data, uint32_t frequency) {
  if (_data->_bools._hostEnabled == 1) {                  // Do something only if the host is enabled.
     b6a:	1e 96       	adiw	r26, 0x0e	; 14
     b6c:	9c 91       	ld	r25, X
     b6e:	1e 97       	sbiw	r26, 0x0e	; 14
     b70:	95 ff       	sbrs	r25, 5
     b72:	0c c0       	rjmp	.+24     	; 0xb8c <Adafruit_I2CDevice::begin(bool) [clone .constprop.16]+0x58>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:237
    uint8_t newBaud = TWI_MasterCalcBaud(frequency);      // get the new Baud value
    uint8_t oldBaud = _data->_module->MBAUD;              // load the old Baud value
     b74:	96 81       	ldd	r25, Z+6	; 0x06
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:238
    if (newBaud != oldBaud) {                             // compare both, in case the code is issuing this before every transmission.
     b76:	9b 35       	cpi	r25, 0x5B	; 91
     b78:	49 f0       	breq	.+18     	; 0xb8c <Adafruit_I2CDevice::begin(bool) [clone .constprop.16]+0x58>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:239
      uint8_t restore = _data->_module->MCTRLA;           // Save the old Master state
     b7a:	23 81       	ldd	r18, Z+3	; 0x03
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:240
      _data->_module->MCTRLA    = 0;                      // Disable Master
     b7c:	13 82       	std	Z+3, r1	; 0x03
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:241
      _data->_module->MBAUD     = newBaud;                // update Baud register
     b7e:	9b e5       	ldi	r25, 0x5B	; 91
     b80:	96 83       	std	Z+6, r25	; 0x06
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:245
      if (frequency >= 600000) {
        _data->_module->CTRLA  |=  TWI_FMPEN_bm;          // Enable FastMode+
      } else {
        _data->_module->CTRLA  &= ~TWI_FMPEN_bm;          // Disable FastMode+
     b82:	90 81       	ld	r25, Z
     b84:	9d 7f       	andi	r25, 0xFD	; 253
     b86:	90 83       	st	Z, r25
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:247
      }
      _data->_module->MCTRLA    = restore;                // restore the old register, thus enabling it again
     b88:	23 83       	std	Z+3, r18	; 0x03
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:248
      _data->_module->MSTATUS   = TWI_BUSSTATE_IDLE_gc;   // Force the state machine into Idle according to the data sheet
     b8a:	85 83       	std	Z+5, r24	; 0x05
_ZN18Adafruit_I2CDevice5beginEb.constprop.16():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:31
  _begun = true;
     b8c:	81 e0       	ldi	r24, 0x01	; 1
     b8e:	8b 83       	std	Y+3, r24	; 0x03
beginTransmission():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:307
  if (__builtin_constant_p(address) > 0x7F) {     // Compile-time check if address is actually 7 bit long
    badArg("Supplied address seems to be 8 bit. Only 7-bit-addresses are supported");
    return;
  }
  // set address of targeted client
  vars._clientAddress = address << 1;
     b90:	88 81       	ld	r24, Y
     b92:	88 0f       	add	r24, r24
     b94:	1f 96       	adiw	r26, 0x0f	; 15
     b96:	8c 93       	st	X, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:308
  (*txHead) = 0;  // fill buffer from 0
     b98:	1f 97       	sbiw	r26, 0x0f	; 15
     b9a:	50 96       	adiw	r26, 0x10	; 16
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:338
 *           17 for lines held low or pullups absent.
 *          255 (-1) for TWI not initialized (begin not called) or bus somehow in "unknown" state.
 */
uint8_t TwoWire::endTransmission(bool sendStop) {
  // transmit (blocking)
  return TWI_MasterWrite(&vars, sendStop);
     b9c:	1c 92       	st	X, r1
endTransmission():
     b9e:	89 81       	ldd	r24, Y+1	; 0x01
     ba0:	9a 81       	ldd	r25, Y+2	; 0x02
     ba2:	61 e0       	ldi	r22, 0x01	; 1
     ba4:	0c 96       	adiw	r24, 0x0c	; 12
     ba6:	55 dd       	rcall	.-1366   	; 0x652 <TWI_MasterWrite>
detected():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:52
    return false;
  }

  // A basic scanner, see if it ACK's
  _wire->beginTransmission(_addr);
  if (_wire->endTransmission() == 0) {
     ba8:	91 e0       	ldi	r25, 0x01	; 1
     baa:	81 11       	cpse	r24, r1
     bac:	90 e0       	ldi	r25, 0x00	; 0
_ZN18Adafruit_I2CDevice5beginEb.constprop.16():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:37

  if (addr_detect) {
    return detected();
  }
  return true;
}
     bae:	89 2f       	mov	r24, r25
     bb0:	df 91       	pop	r29
     bb2:	cf 91       	pop	r28
     bb4:	08 95       	ret

00000bb6 <digitalWrite>:
digitalWrite():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:257
    default:
      break;
  }
}

void digitalWrite(uint8_t pin, uint8_t val) {
     bb6:	cf 93       	push	r28
     bb8:	df 93       	push	r29
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:260
  check_valid_digital_pin(pin);
  /* Get bit mask for pin */
  uint8_t bit_mask = digitalPinToBitMask(pin);
     bba:	8c 30       	cpi	r24, 0x0C	; 12
     bbc:	d8 f5       	brcc	.+118    	; 0xc34 <digitalWrite+0x7e>
check_valid_digital_pin():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:32
#define ARDUINO_MAIN
#include "wiring_private.h"
#include "pins_arduino.h"

inline __attribute__((always_inline)) void check_valid_digital_pin(pin_size_t pin) {
  if (__builtin_constant_p(pin))
     bbe:	90 e0       	ldi	r25, 0x00	; 0
digitalWrite():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:260
}

void digitalWrite(uint8_t pin, uint8_t val) {
  check_valid_digital_pin(pin);
  /* Get bit mask for pin */
  uint8_t bit_mask = digitalPinToBitMask(pin);
     bc0:	dc 01       	movw	r26, r24
     bc2:	a8 50       	subi	r26, 0x08	; 8
     bc4:	bc 44       	sbci	r27, 0x4C	; 76
     bc6:	2c 91       	ld	r18, X
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:261
  if (bit_mask == NOT_A_PIN) {
     bc8:	2f 3f       	cpi	r18, 0xFF	; 255
     bca:	a1 f1       	breq	.+104    	; 0xc34 <digitalWrite+0x7e>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:266
    return;
  }

  /* Get port */
  PORT_t *port = digitalPinToPortStruct(pin);
     bcc:	fc 01       	movw	r30, r24
     bce:	ec 5f       	subi	r30, 0xFC	; 252
     bd0:	fb 44       	sbci	r31, 0x4B	; 75
     bd2:	e0 81       	ld	r30, Z
     bd4:	30 e2       	ldi	r19, 0x20	; 32
     bd6:	e3 9f       	mul	r30, r19
     bd8:	f0 01       	movw	r30, r0
     bda:	11 24       	eor	r1, r1
     bdc:	fc 5f       	subi	r31, 0xFC	; 252
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:278
  you could digitalWrite() a pin while it's an input, to ensure
  that the value of the port was set correctly when it was
  changed to an output. Code in the wild relies on this behavior.
  */

  if (val == LOW) { /* If LOW */
     bde:	61 11       	cpse	r22, r1
     be0:	2c c0       	rjmp	.+88     	; 0xc3a <digitalWrite+0x84>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:279
    port->OUTCLR = bit_mask;
     be2:	26 83       	std	Z+6, r18	; 0x06
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:296
  } else {
    port->OUTSET = bit_mask;
  }

  /* Input direction */
  if (!(port->DIR & bit_mask)) {
     be4:	30 81       	ld	r19, Z
     be6:	23 23       	and	r18, r19
     be8:	99 f4       	brne	.+38     	; 0xc10 <digitalWrite+0x5a>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:303
      pull up is enabled if this function is called.
      Should we purposely implement this side effect?
    */

    /* Get bit position for getting pin ctrl reg */
    uint8_t bit_pos = digitalPinToBitPosition(pin);
     bea:	ec 01       	movw	r28, r24
     bec:	c8 54       	subi	r28, 0x48	; 72
     bee:	dc 44       	sbci	r29, 0x4C	; 76
     bf0:	28 81       	ld	r18, Y
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:306

    /* Calculate where pin control register is */
    volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(port, bit_pos);
     bf2:	30 97       	sbiw	r30, 0x00	; 0
     bf4:	21 f1       	breq	.+72     	; 0xc3e <digitalWrite+0x88>
     bf6:	2f 3f       	cpi	r18, 0xFF	; 255
     bf8:	11 f1       	breq	.+68     	; 0xc3e <digitalWrite+0x88>
     bfa:	70 96       	adiw	r30, 0x10	; 16
     bfc:	e2 0f       	add	r30, r18
     bfe:	f1 1d       	adc	r31, r1
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:309

    /* Save system status and disable interrupts */
    uint8_t status = SREG;
     c00:	3f b7       	in	r19, 0x3f	; 63
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:310
    cli();
     c02:	f8 94       	cli
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:314

    if (val == LOW) {
      /* Disable pullup */
      *pin_ctrl_reg &= ~PORT_PULLUPEN_bm;
     c04:	20 81       	ld	r18, Z
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:312

    /* Save system status and disable interrupts */
    uint8_t status = SREG;
    cli();

    if (val == LOW) {
     c06:	61 11       	cpse	r22, r1
     c08:	1d c0       	rjmp	.+58     	; 0xc44 <digitalWrite+0x8e>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:314
      /* Disable pullup */
      *pin_ctrl_reg &= ~PORT_PULLUPEN_bm;
     c0a:	27 7f       	andi	r18, 0xF7	; 247
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:317
    } else {
      /* Enable pull-up */
      *pin_ctrl_reg |= PORT_PULLUPEN_bm;
     c0c:	20 83       	st	Z, r18
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:321
    }

    /* Restore system status */
    SREG = status;
     c0e:	3f bf       	out	0x3f, r19	; 63
turnOffPWM():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:176
   * any timers with minimum overhead - critical on these parts
   * Since nothing that will show up here can have more than one
   * one bit set, binary and will give 0x00 if that bit is cleared
   * which is NOT_ON_TIMER.
   */
  uint8_t digital_pin_timer =  digitalPinToTimer(pin) & PeripheralControl;
     c10:	84 55       	subi	r24, 0x54	; 84
     c12:	9c 44       	sbci	r25, 0x4C	; 76
     c14:	fc 01       	movw	r30, r24
     c16:	80 81       	ld	r24, Z
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:178
  /* end megaTinyCore-specific section */
  if (digital_pin_timer== NOT_ON_TIMER) {
     c18:	88 23       	and	r24, r24
     c1a:	61 f0       	breq	.+24     	; 0xc34 <digitalWrite+0x7e>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:185
  }

  uint8_t bit_mask = digitalPinToBitMask(pin);
  // TCB_t *timerB;

  switch (digital_pin_timer) {
     c1c:	80 31       	cpi	r24, 0x10	; 16
     c1e:	51 f4       	brne	.+20     	; 0xc34 <digitalWrite+0x7e>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:182
  /* end megaTinyCore-specific section */
  if (digital_pin_timer== NOT_ON_TIMER) {
    return;
  }

  uint8_t bit_mask = digitalPinToBitMask(pin);
     c20:	8c 91       	ld	r24, X
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:197
      #ifdef __AVR_ATtinyxy2__
        if (bit_mask == 0x80) {
          bit_mask = 1;  // on the xy2, WO0 is on PA7
        }
      #endif
      if (bit_mask > 0x04) { // -> bit_pos > 2 -> output channel controlled by HCMP
     c22:	85 30       	cpi	r24, 0x05	; 5
     c24:	08 f0       	brcs	.+2      	; 0xc28 <digitalWrite+0x72>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:198
        bit_mask <<= 1;      // mind the gap (between LCMP and HCMP)
     c26:	88 0f       	add	r24, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:201
      }
      // since we're turning it off, we don't need to change the CMP register
      TCA0.SPLIT.CTRLB &= ~bit_mask;
     c28:	90 91 01 0a 	lds	r25, 0x0A01	; 0x800a01 <vtable for Adafruit_BMP280_Temp+0x7f55e3>
     c2c:	80 95       	com	r24
     c2e:	89 23       	and	r24, r25
     c30:	80 93 01 0a 	sts	0x0A01, r24	; 0x800a01 <vtable for Adafruit_BMP280_Temp+0x7f55e3>
digitalWrite():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:334
   * analogWritten() 255, then digitallyWritten() to HIGH, which
   * would turn it off for the time between turnOffPWM() and
   * PORT->OUTCLR)
   * Since there's no penalty, why make a glitch we don't have to? */
  turnOffPWM(pin);
}
     c34:	df 91       	pop	r29
     c36:	cf 91       	pop	r28
     c38:	08 95       	ret
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:292
    // val will now be 0 (LOW) if the toggling made it LOW
    // or bit_mask if not. And further down, we only need to
    // know if it's
  /* If HIGH OR  > TOGGLE  */
  } else {
    port->OUTSET = bit_mask;
     c3a:	25 83       	std	Z+5, r18	; 0x05
     c3c:	d3 cf       	rjmp	.-90     	; 0xbe4 <digitalWrite+0x2e>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:306

    /* Get bit position for getting pin ctrl reg */
    uint8_t bit_pos = digitalPinToBitPosition(pin);

    /* Calculate where pin control register is */
    volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(port, bit_pos);
     c3e:	f0 e0       	ldi	r31, 0x00	; 0
     c40:	e0 e0       	ldi	r30, 0x00	; 0
     c42:	de cf       	rjmp	.-68     	; 0xc00 <digitalWrite+0x4a>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:317
    if (val == LOW) {
      /* Disable pullup */
      *pin_ctrl_reg &= ~PORT_PULLUPEN_bm;
    } else {
      /* Enable pull-up */
      *pin_ctrl_reg |= PORT_PULLUPEN_bm;
     c44:	28 60       	ori	r18, 0x08	; 8
     c46:	e2 cf       	rjmp	.-60     	; 0xc0c <digitalWrite+0x56>

00000c48 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char) [clone .constprop.36]>:
_ZN18Adafruit_SPIDevice15write_then_readEPhjS0_jh.constprop.36():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:391
 *    @param  sendvalue The 8-bits of data to write when doing the data read,
 * defaults to 0xFF
 *    @return Always returns true because there's no way to test success of SPI
 * writes
 */
bool Adafruit_SPIDevice::write_then_read(uint8_t *write_buffer,
     c48:	cf 92       	push	r12
     c4a:	df 92       	push	r13
     c4c:	ef 92       	push	r14
     c4e:	ff 92       	push	r15
     c50:	0f 93       	push	r16
     c52:	1f 93       	push	r17
     c54:	cf 93       	push	r28
     c56:	df 93       	push	r29
     c58:	ec 01       	movw	r28, r24
     c5a:	8b 01       	movw	r16, r22
     c5c:	6a 01       	movw	r12, r20
     c5e:	79 01       	movw	r14, r18
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:394
                                         size_t write_len, uint8_t *read_buffer,
                                         size_t read_len, uint8_t sendvalue) {
  if (_spi) {
     c60:	88 81       	ld	r24, Y
     c62:	99 81       	ldd	r25, Y+1	; 0x01
     c64:	00 97       	sbiw	r24, 0x00	; 0
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:395
    _spi->beginTransaction(*_spiSetting);
     c66:	29 f0       	breq	.+10     	; 0xc72 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char) [clone .constprop.36]+0x2a>
     c68:	ea 81       	ldd	r30, Y+2	; 0x02
     c6a:	fb 81       	ldd	r31, Y+3	; 0x03
     c6c:	60 81       	ld	r22, Z
     c6e:	71 81       	ldd	r23, Z+1	; 0x01
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:398
  }

  digitalWrite(_cs, LOW);
     c70:	a3 de       	rcall	.-698    	; 0x9b8 <SPIClass::beginTransaction(SPISettings)>
     c72:	60 e0       	ldi	r22, 0x00	; 0
     c74:	8b 85       	ldd	r24, Y+11	; 0x0b
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:401
  // do the writing
  for (size_t i = 0; i < write_len; i++) {
    transfer(write_buffer[i]);
     c76:	9f df       	rcall	.-194    	; 0xbb6 <digitalWrite>
     c78:	f8 01       	movw	r30, r16
     c7a:	60 81       	ld	r22, Z
     c7c:	ce 01       	movw	r24, r28
     c7e:	3a dd       	rcall	.-1420   	; 0x6f4 <Adafruit_SPIDevice::transfer(unsigned char)>
     c80:	86 01       	movw	r16, r12
     c82:	ec 0c       	add	r14, r12
     c84:	fd 1c       	adc	r15, r13
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:419
  DEBUG_SERIAL.println();
#endif

  // do the reading
  for (size_t i = 0; i < read_len; i++) {
    read_buffer[i] = transfer(sendvalue);
     c86:	6f ef       	ldi	r22, 0xFF	; 255
     c88:	ce 01       	movw	r24, r28
     c8a:	34 dd       	rcall	.-1432   	; 0x6f4 <Adafruit_SPIDevice::transfer(unsigned char)>
     c8c:	f8 01       	movw	r30, r16
     c8e:	81 93       	st	Z+, r24
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:418
  }
  DEBUG_SERIAL.println();
#endif

  // do the reading
  for (size_t i = 0; i < read_len; i++) {
     c90:	8f 01       	movw	r16, r30
     c92:	ee 15       	cp	r30, r14
     c94:	ff 05       	cpc	r31, r15
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:435
    }
  }
  DEBUG_SERIAL.println();
#endif

  digitalWrite(_cs, HIGH);
     c96:	b9 f7       	brne	.-18     	; 0xc86 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char) [clone .constprop.36]+0x3e>
     c98:	61 e0       	ldi	r22, 0x01	; 1
     c9a:	8b 85       	ldd	r24, Y+11	; 0x0b
     c9c:	8c df       	rcall	.-232    	; 0xbb6 <digitalWrite>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:437

  if (_spi) {
     c9e:	88 81       	ld	r24, Y
     ca0:	99 81       	ldd	r25, Y+1	; 0x01
     ca2:	00 97       	sbiw	r24, 0x00	; 0
     ca4:	09 f0       	breq	.+2      	; 0xca8 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char) [clone .constprop.36]+0x60>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:438
    _spi->endTransaction();
     ca6:	df dd       	rcall	.-1090   	; 0x866 <SPIClass::endTransaction()>
     ca8:	81 e0       	ldi	r24, 0x01	; 1
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:442
  }

  return true;
}
     caa:	df 91       	pop	r29
     cac:	cf 91       	pop	r28
     cae:	1f 91       	pop	r17
     cb0:	0f 91       	pop	r16
     cb2:	ff 90       	pop	r15
     cb4:	ef 90       	pop	r14
     cb6:	df 90       	pop	r13
     cb8:	cf 90       	pop	r12
     cba:	08 95       	ret

00000cbc <pinMode>:
pinMode():
     cbc:	8c 30       	cpi	r24, 0x0C	; 12
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:136
  return port << 1;
}
void pinMode(uint8_t pin, uint8_t mode) {
  check_valid_digital_pin(pin);         /* generate compile error if a constant that is not a valid pin is used as the pin */
  check_valid_pin_mode(mode);           /* generate compile error if a constant that is not a valid pin mode is used as the mode */
  uint8_t bit_mask = digitalPinToBitMask(pin);
     cbe:	f0 f4       	brcc	.+60     	; 0xcfc <pinMode+0x40>
check_valid_digital_pin():
     cc0:	90 e0       	ldi	r25, 0x00	; 0
pinMode():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:32
#define ARDUINO_MAIN
#include "wiring_private.h"
#include "pins_arduino.h"

inline __attribute__((always_inline)) void check_valid_digital_pin(pin_size_t pin) {
  if (__builtin_constant_p(pin))
     cc2:	fc 01       	movw	r30, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:136
  return port << 1;
}
void pinMode(uint8_t pin, uint8_t mode) {
  check_valid_digital_pin(pin);         /* generate compile error if a constant that is not a valid pin is used as the pin */
  check_valid_pin_mode(mode);           /* generate compile error if a constant that is not a valid pin mode is used as the mode */
  uint8_t bit_mask = digitalPinToBitMask(pin);
     cc4:	e8 50       	subi	r30, 0x08	; 8
     cc6:	fc 44       	sbci	r31, 0x4C	; 76
     cc8:	20 81       	ld	r18, Z
     cca:	2f 3f       	cpi	r18, 0xFF	; 255
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:137
  if ((bit_mask == NOT_A_PIN) || (mode > 3)) {
     ccc:	b9 f0       	breq	.+46     	; 0xcfc <pinMode+0x40>
     cce:	fc 01       	movw	r30, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:140
    return;                             /* ignore invalid pins passed at runtime */
  }
  volatile uint8_t * port_base = ((volatile uint8_t *) (uint16_t)(0x0400 | portToPortBaseOffset(digitalPinToPort(pin))));
     cd0:	ec 5f       	subi	r30, 0xFC	; 252
     cd2:	fb 44       	sbci	r31, 0x4B	; 75
portToPortBaseOffset():
     cd4:	e0 81       	ld	r30, Z
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:130
  SREG = oldSREG; // re-enable interrupts
}

static inline uint8_t portToPortBaseOffset(uint8_t port);
static inline uint8_t portToPortBaseOffset(uint8_t port) {
  _SWAP(port);
     cd6:	e2 95       	swap	r30
     cd8:	ee 0f       	add	r30, r30
pinMode():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:131
  return port << 1;
     cda:	f0 e0       	ldi	r31, 0x00	; 0
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:140
  check_valid_pin_mode(mode);           /* generate compile error if a constant that is not a valid pin mode is used as the mode */
  uint8_t bit_mask = digitalPinToBitMask(pin);
  if ((bit_mask == NOT_A_PIN) || (mode > 3)) {
    return;                             /* ignore invalid pins passed at runtime */
  }
  volatile uint8_t * port_base = ((volatile uint8_t *) (uint16_t)(0x0400 | portToPortBaseOffset(digitalPinToPort(pin))));
     cdc:	f4 60       	ori	r31, 0x04	; 4
     cde:	60 ff       	sbrs	r22, 0
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:141
  if (mode & 0x01) {
     ce0:	0e c0       	rjmp	.+28     	; 0xcfe <pinMode+0x42>
     ce2:	21 83       	std	Z+1, r18	; 0x01
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:143
    // OUTPUT mode, so write DIRSET with the mask.
    *(port_base + 1) = bit_mask;
     ce4:	88 54       	subi	r24, 0x48	; 72
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:152
      *(port_base + 5) = bit_mask;
    } else if (mode == 0) {
      *(port_base + 6) = bit_mask;
    }
  }
  port_base +=(uint8_t) digitalPinToBitPosition(pin) | (uint8_t) 0x10;
     ce6:	9c 44       	sbci	r25, 0x4C	; 76
     ce8:	dc 01       	movw	r26, r24
     cea:	8c 91       	ld	r24, X
     cec:	80 61       	ori	r24, 0x10	; 16
     cee:	e8 0f       	add	r30, r24
     cf0:	f1 1d       	adc	r31, r1
     cf2:	80 81       	ld	r24, Z
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:153
  bit_mask = *port_base;
     cf4:	61 ff       	sbrs	r22, 1
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:154
  if (mode & 2) {
     cf6:	0c c0       	rjmp	.+24     	; 0xd10 <pinMode+0x54>
     cf8:	88 60       	ori	r24, 0x08	; 8
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:155
    bit_mask |= 0x08;
     cfa:	80 83       	st	Z, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:159
  } else {
    bit_mask &= 0xF7;
  }
  *port_base = bit_mask;
     cfc:	08 95       	ret
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:160
}
     cfe:	22 83       	std	Z+2, r18	; 0x02
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:145
  volatile uint8_t * port_base = ((volatile uint8_t *) (uint16_t)(0x0400 | portToPortBaseOffset(digitalPinToPort(pin))));
  if (mode & 0x01) {
    // OUTPUT mode, so write DIRSET with the mask.
    *(port_base + 1) = bit_mask;
  } else {
    *(port_base + 2) = bit_mask;
     d00:	62 30       	cpi	r22, 0x02	; 2
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:146
    if (mode == 2) {
     d02:	11 f4       	brne	.+4      	; 0xd08 <pinMode+0x4c>
     d04:	25 83       	std	Z+5, r18	; 0x05
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:147
      *(port_base + 5) = bit_mask;
     d06:	ee cf       	rjmp	.-36     	; 0xce4 <pinMode+0x28>
     d08:	61 11       	cpse	r22, r1
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:148
    } else if (mode == 0) {
     d0a:	ec cf       	rjmp	.-40     	; 0xce4 <pinMode+0x28>
     d0c:	26 83       	std	Z+6, r18	; 0x06
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:149
      *(port_base + 6) = bit_mask;
     d0e:	ea cf       	rjmp	.-44     	; 0xce4 <pinMode+0x28>
     d10:	87 7f       	andi	r24, 0xF7	; 247
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:157
  port_base +=(uint8_t) digitalPinToBitPosition(pin) | (uint8_t) 0x10;
  bit_mask = *port_base;
  if (mode & 2) {
    bit_mask |= 0x08;
  } else {
    bit_mask &= 0xF7;
     d12:	f3 cf       	rjmp	.-26     	; 0xcfa <pinMode+0x3e>

00000d14 <UartClass::begin(unsigned long, unsigned int)>:
_ZN9UartClass5beginEmj():
     d14:	8f 92       	push	r8
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:470
    _pin_set = 0;
  }
  return false;
}

void UartClass::begin(unsigned long baud, uint16_t options) {
     d16:	9f 92       	push	r9
     d18:	af 92       	push	r10
     d1a:	bf 92       	push	r11
     d1c:	ef 92       	push	r14
     d1e:	ff 92       	push	r15
     d20:	0f 93       	push	r16
     d22:	1f 93       	push	r17
     d24:	cf 93       	push	r28
     d26:	df 93       	push	r29
     d28:	8c 01       	movw	r16, r24
     d2a:	4a 01       	movw	r8, r20
     d2c:	5b 01       	movw	r10, r22
     d2e:	e9 01       	movw	r28, r18
     d30:	dc 01       	movw	r26, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:473
  // Make sure no transmissions are ongoing and USART is disabled in case begin() is called by accident
  // without first calling end()
  if (_state & 1) {
     d32:	50 96       	adiw	r26, 0x10	; 16
     d34:	8c 91       	ld	r24, X
     d36:	50 97       	sbiw	r26, 0x10	; 16
     d38:	80 ff       	sbrs	r24, 0
     d3a:	07 c0       	rjmp	.+14     	; 0xd4a <UartClass::begin(unsigned long, unsigned int)+0x36>
     d3c:	ed 91       	ld	r30, X+
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:474
    this->end();
     d3e:	fc 91       	ld	r31, X
     d40:	02 88       	ldd	r0, Z+18	; 0x12
     d42:	f3 89       	ldd	r31, Z+19	; 0x13
     d44:	e0 2d       	mov	r30, r0
     d46:	c8 01       	movw	r24, r16
     d48:	09 95       	icall
     d4a:	c1 11       	cpse	r28, r1
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:478
  }

  uint8_t ctrlc = (uint8_t) options;
  if (ctrlc == 0) {                         // see if they passed anything in low byte or SERIAL_CONFIG_VALID.
     d4c:	01 c0       	rjmp	.+2      	; 0xd50 <UartClass::begin(unsigned long, unsigned int)+0x3c>
     d4e:	c3 e0       	ldi	r28, 0x03	; 3
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:479
    ctrlc = (uint8_t)SERIAL_8N1;            // low byte of 0 could mean they want SERIAL_5N1. Or that they thought they'd
     d50:	ec 2e       	mov	r14, r28
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:481
  }
  ctrlc &= ~0x04; // Now unset that 0x04 bit if it's set, because none of the values with it set are supported. We use that to smuggle in a "this constant was specified" for 5N1
     d52:	e8 94       	clt
     d54:	e2 f8       	bld	r14, 2
     d56:	fd 2e       	mov	r15, r29
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:482
  uint8_t ctrla = (uint8_t) (options >> 8);// CTRLA will get the remains of the options high byte.
     d58:	cd 2f       	mov	r28, r29
     d5a:	d0 95       	com	r29
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:484
  uint16_t baud_setting = 0;                // at this point it should be able to reuse those 2 registers that it received options in!
  uint8_t   ctrlb = (~ctrla & 0xC0);        // Top two bits (TXEN RXEN), inverted so they match he sense in the registers.
     d5c:	d0 7c       	andi	r29, 0xC0	; 192
     d5e:	b1 ed       	ldi	r27, 0xD1	; 209
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:485
  if (baud   > F_CPU / 16) {            // if this baud is too fast for non-U2X
     d60:	8b 16       	cp	r8, r27
     d62:	b2 e1       	ldi	r27, 0x12	; 18
     d64:	9b 06       	cpc	r9, r27
     d66:	b3 e1       	ldi	r27, 0x13	; 19
     d68:	ab 06       	cpc	r10, r27
     d6a:	b1 04       	cpc	r11, r1
     d6c:	28 f0       	brcs	.+10     	; 0xd78 <UartClass::begin(unsigned long, unsigned int)+0x64>
     d6e:	d2 60       	ori	r29, 0x02	; 2
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:486
        ctrlb   |= USART_RXMODE0_bm;        // set the U2X bit in what will become CTRLB
     d70:	b6 94       	lsr	r11
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:487
        baud   >>= 1;                       // And lower the baud rate by haldf
     d72:	a7 94       	ror	r10
     d74:	97 94       	ror	r9
     d76:	87 94       	ror	r8
     d78:	60 e0       	ldi	r22, 0x00	; 0
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:489
  }
  baud_setting = (((4 * F_CPU) / baud));  // And now the registers that baud was passed in are done.
     d7a:	74 eb       	ldi	r23, 0xB4	; 180
     d7c:	84 ec       	ldi	r24, 0xC4	; 196
     d7e:	94 e0       	ldi	r25, 0x04	; 4
     d80:	a5 01       	movw	r20, r10
     d82:	94 01       	movw	r18, r8
     d84:	0e 94 12 17 	call	0x2e24	; 0x2e24 <__udivmodsi4>
     d88:	20 34       	cpi	r18, 0x40	; 64
     d8a:	31 05       	cpc	r19, r1
     d8c:	10 f4       	brcc	.+4      	; 0xd92 <UartClass::begin(unsigned long, unsigned int)+0x7e>
     d8e:	20 e4       	ldi	r18, 0x40	; 64
     d90:	30 e0       	ldi	r19, 0x00	; 0
     d92:	f2 fc       	sbrc	r15, 2
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:495
  if (baud_setting < 64)                      // so set to the maximum baud rate setting.
    baud_setting= 64;       // set the U2X bit in what will become CTRLB
  //} else if (baud < (F_CPU / 16800)) {      // Baud rate is too low
  //  baud_setting = 65535;                   // minimum baud rate.'
                                            // Baud setting done now we do the other options not in CTRLC;
  if (ctrla & 0x04) {                       // is ODME option set?
     d94:	d8 60       	ori	r29, 0x08	; 8
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:496
    ctrlb |= USART_ODME_bm;                 // set the bit in what will become CTRLB
     d96:	8c 2f       	mov	r24, r28
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:498
  }
  ctrla &= 0x2B;                            // Only LBME and RS485 (both of them); will get written to CTRLA, but we leave the event bit.
     d98:	8b 72       	andi	r24, 0x2B	; 43
     d9a:	d7 fd       	sbrc	r29, 7
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:499
  if (ctrlb & USART_RXEN_bm) {              // if RX is to be enabled
     d9c:	80 68       	ori	r24, 0x80	; 128
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:500
    ctrla  |= USART_RXCIE_bm;               // we will want to enable the ISR.
     d9e:	cd 2f       	mov	r28, r29
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:502
  }
  uint8_t setpinmask = ctrlb & 0xC8;        // ODME in bit 3, TX and RX enabled in bit 6, 7
     da0:	c8 7c       	andi	r28, 0xC8	; 200
     da2:	83 ff       	sbrs	r24, 3
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:503
  if ((ctrla & USART_LBME_bm) && (setpinmask == 0xC8)) { // if it's open-drain and loopback, need to set state bit 2.
     da4:	07 c0       	rjmp	.+14     	; 0xdb4 <UartClass::begin(unsigned long, unsigned int)+0xa0>
     da6:	c8 3c       	cpi	r28, 0xC8	; 200
     da8:	29 f4       	brne	.+10     	; 0xdb4 <UartClass::begin(unsigned long, unsigned int)+0xa0>
     daa:	f8 01       	movw	r30, r16
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:504
    _state                 |= 2;            // since that changes some behavior (RXC disabled while sending) // Now we should be able to ST _state.
     dac:	90 89       	ldd	r25, Z+16	; 0x10
     dae:	92 60       	ori	r25, 0x02	; 2
     db0:	90 8b       	std	Z+16, r25	; 0x10
     db2:	c8 ed       	ldi	r28, 0xD8	; 216
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:505
    setpinmask             |= 0x10;         // this tells _set_pins not to disturb the configuration on the RX pin.
     db4:	80 fd       	sbrc	r24, 0
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:507
  }
  if (ctrla & USART_RS485_bm) {             // RS485 mode recorded here too... because we need to set
     db6:	c1 60       	ori	r28, 0x01	; 1
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:508
    setpinmask             |= 0x01;         // set pin output if we need to do that. Datasheet isn't clear
     db8:	ff b6       	in	r15, 0x3f	; 63
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:510
  }
  uint8_t oldSREG = SREG;
     dba:	f8 94       	cli
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:511
  cli();
     dbc:	d8 01       	movw	r26, r16
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:512
  volatile USART_t* MyUSART = _hwserial_module;
     dbe:	1c 96       	adiw	r26, 0x0c	; 12
     dc0:	ed 91       	ld	r30, X+
     dc2:	fc 91       	ld	r31, X
     dc4:	16 82       	std	Z+6, r1	; 0x06
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:513
  (*MyUSART).CTRLB          = 0;            // gotta disable first - some things are enable-locked.
     dc6:	e7 82       	std	Z+7, r14	; 0x07
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:514
  (*MyUSART).CTRLC          = ctrlc;        // No reason not to set first.
     dc8:	20 87       	std	Z+8, r18	; 0x08
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:515
  (*MyUSART).BAUD           = baud_setting; // Wish I could have set it long ago
     dca:	31 87       	std	Z+9, r19	; 0x09
     dcc:	85 ff       	sbrs	r24, 5
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:516
  if (ctrla & 0x20) {                       // Now we have to do a bit of work
     dce:	4d c0       	rjmp	.+154    	; 0xe6a <UartClass::begin(unsigned long, unsigned int)+0x156>
     dd0:	cf 77       	andi	r28, 0x7F	; 127
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:517
    setpinmask             &= 0x7F;         // Remove the RX pin in this case because we get the input from elsewhere.
     dd2:	91 e0       	ldi	r25, 0x01	; 1
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:518
    (*MyUSART).EVCTRL       = 1;            // enable event input - not clear from datasheet what's needed to
     dd4:	94 87       	std	Z+12, r25	; 0x0c
     dd6:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:519
    (*MyUSART).TXPLCTRL     = 0xFF;         // Disable pulse length encoding.
     dd8:	95 87       	std	Z+13, r25	; 0x0d
     dda:	8f 7d       	andi	r24, 0xDF	; 223
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:523
  } else {
    (*MyUSART).EVCTRL       = 0;            // This needs to be turned off when not in use.
  }                                         // finally strip out the SERIAL_EVENT_RX bit which is in the DREIE
  (*MyUSART).CTRLA          = ctrla & 0xDF; // position, which we never set in begin.
     ddc:	85 83       	std	Z+5, r24	; 0x05
     dde:	d6 83       	std	Z+6, r29	; 0x06
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:524
  (*MyUSART).CTRLB          = ctrlb;        // Set the all important CTRLB...
     de0:	f8 01       	movw	r30, r16
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:525
  _set_pins(_module_number, _pin_set, setpinmask); // set up the pin(s)
     de2:	47 85       	ldd	r20, Z+15	; 0x0f
     de4:	86 85       	ldd	r24, Z+14	; 0x0e
_set_pins():
     de6:	90 91 e2 05 	lds	r25, 0x05E2	; 0x8005e2 <vtable for Adafruit_BMP280_Temp+0x7f51c4>
_ZN9UartClass5beginEmj():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:532
}

void UartClass::_set_pins(uint8_t mod_nbr, uint8_t mux_set, uint8_t enmask) {
  // Set the mux register
  #if defined(PORTMUX_USARTROUTEA)
    uint8_t muxregval    = PORTMUX.USARTROUTEA;
     dea:	2c ef       	ldi	r18, 0xFC	; 252
_set_pins():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:533
    muxregval           &= ~(mod_nbr ? 0x0C : 0x03);
     dec:	81 11       	cpse	r24, r1
_ZN9UartClass5beginEmj():
     dee:	23 ef       	ldi	r18, 0xF3	; 243
_set_pins():
     df0:	92 23       	and	r25, r18
     df2:	24 2f       	mov	r18, r20
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:534
    PORTMUX.USARTROUTEA  = (muxregval) | (mux_set << (mod_nbr ? 2 : 0)); // shift muxset left if needed.
     df4:	30 e0       	ldi	r19, 0x00	; 0
_ZN9UartClass5beginEmj():
     df6:	50 e0       	ldi	r21, 0x00	; 0
_set_pins():
     df8:	81 11       	cpse	r24, r1
_ZN9UartClass5beginEmj():
     dfa:	52 e0       	ldi	r21, 0x02	; 2
_set_pins():
     dfc:	b9 01       	movw	r22, r18
     dfe:	01 c0       	rjmp	.+2      	; 0xe02 <UartClass::begin(unsigned long, unsigned int)+0xee>
     e00:	66 0f       	add	r22, r22
     e02:	5a 95       	dec	r21
     e04:	ea f7       	brpl	.-6      	; 0xe00 <UartClass::begin(unsigned long, unsigned int)+0xec>
     e06:	96 2b       	or	r25, r22
     e08:	90 93 e2 05 	sts	0x05E2, r25	; 0x8005e2 <vtable for Adafruit_BMP280_Temp+0x7f51c4>
     e0c:	43 30       	cpi	r20, 0x03	; 3
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:544
    } else {
      PORTMUX.CTRLB       &= 0xFE;
    }
  #endif
  #if MEGATINYCORE_SERIES == 2
    if (mux_set == 3) { // not connected to pins...
     e0e:	09 f1       	breq	.+66     	; 0xe52 <UartClass::begin(unsigned long, unsigned int)+0x13e>
     e10:	82 0f       	add	r24, r18
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:548
      return;           // so we are done!
    }
  #endif
  const uint8_t* muxrow = &(_usart_pins[mod_nbr + mux_set][0]);
     e12:	93 2f       	mov	r25, r19
     e14:	91 1d       	adc	r25, r1
     e16:	88 0f       	add	r24, r24
     e18:	99 1f       	adc	r25, r25
     e1a:	88 0f       	add	r24, r24
     e1c:	99 1f       	adc	r25, r25
     e1e:	8c 01       	movw	r16, r24
     e20:	0c 53       	subi	r16, 0x3C	; 60
     e22:	1c 44       	sbci	r17, 0x4C	; 76
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:549
  if ((enmask & 0x40 && !(enmask & 0x08))) {
     e24:	c6 ff       	sbrs	r28, 6
     e26:	23 c0       	rjmp	.+70     	; 0xe6e <UartClass::begin(unsigned long, unsigned int)+0x15a>
     e28:	c3 fd       	sbrc	r28, 3
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:550
    pinMode(muxrow[0], OUTPUT); // If and only if TX is enabled and open drain isn't should the TX pin be output.
     e2a:	21 c0       	rjmp	.+66     	; 0xe6e <UartClass::begin(unsigned long, unsigned int)+0x15a>
     e2c:	61 e0       	ldi	r22, 0x01	; 1
     e2e:	d8 01       	movw	r26, r16
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:553
  } else if (enmask & 0x50) { // if it is enabled but is in open drain mode, or is disabled, but loopback is enabled
    // TX should be INPUT_PULLUP.
    pinMode(muxrow[0], INPUT_PULLUP);
     e30:	8c 91       	ld	r24, X
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:555
  }
  if (enmask & 0x80 && !(enmask & 0x10)) {
     e32:	44 df       	rcall	.-376    	; 0xcbc <pinMode>
     e34:	c7 ff       	sbrs	r28, 7
     e36:	07 c0       	rjmp	.+14     	; 0xe46 <UartClass::begin(unsigned long, unsigned int)+0x132>
     e38:	c4 fd       	sbrc	r28, 4
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:557
    // Likewise if RX is enabled, unless loopback mode is too (in which case we caught it above, it should be pulled up
    pinMode(muxrow[1], INPUT_PULLUP);
     e3a:	05 c0       	rjmp	.+10     	; 0xe46 <UartClass::begin(unsigned long, unsigned int)+0x132>
     e3c:	62 e0       	ldi	r22, 0x02	; 2
     e3e:	d8 01       	movw	r26, r16
     e40:	11 96       	adiw	r26, 0x01	; 1
     e42:	8c 91       	ld	r24, X
     e44:	3b df       	rcall	.-394    	; 0xcbc <pinMode>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:559
  }
  if (enmask & 0x01) { // finally if RS485 mode is enabled, we make XDIR output, otherwise it can't drive the pin.
     e46:	c0 ff       	sbrs	r28, 0
     e48:	04 c0       	rjmp	.+8      	; 0xe52 <UartClass::begin(unsigned long, unsigned int)+0x13e>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:560
    pinMode(muxrow[3], OUTPUT); // make XDIR output.
     e4a:	61 e0       	ldi	r22, 0x01	; 1
     e4c:	f8 01       	movw	r30, r16
     e4e:	83 81       	ldd	r24, Z+3	; 0x03
     e50:	35 df       	rcall	.-406    	; 0xcbc <pinMode>
_ZN9UartClass5beginEmj():
     e52:	ff be       	out	0x3f, r15	; 63
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:526
    (*MyUSART).EVCTRL       = 0;            // This needs to be turned off when not in use.
  }                                         // finally strip out the SERIAL_EVENT_RX bit which is in the DREIE
  (*MyUSART).CTRLA          = ctrla & 0xDF; // position, which we never set in begin.
  (*MyUSART).CTRLB          = ctrlb;        // Set the all important CTRLB...
  _set_pins(_module_number, _pin_set, setpinmask); // set up the pin(s)
  SREG = oldSREG;                             // re-enable interrupts, and we're done.
     e54:	df 91       	pop	r29
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:527
}
     e56:	cf 91       	pop	r28
     e58:	1f 91       	pop	r17
     e5a:	0f 91       	pop	r16
     e5c:	ff 90       	pop	r15
     e5e:	ef 90       	pop	r14
     e60:	bf 90       	pop	r11
     e62:	af 90       	pop	r10
     e64:	9f 90       	pop	r9
     e66:	8f 90       	pop	r8
     e68:	08 95       	ret
     e6a:	14 86       	std	Z+12, r1	; 0x0c
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:521
  if (ctrla & 0x20) {                       // Now we have to do a bit of work
    setpinmask             &= 0x7F;         // Remove the RX pin in this case because we get the input from elsewhere.
    (*MyUSART).EVCTRL       = 1;            // enable event input - not clear from datasheet what's needed to
    (*MyUSART).TXPLCTRL     = 0xFF;         // Disable pulse length encoding.
  } else {
    (*MyUSART).EVCTRL       = 0;            // This needs to be turned off when not in use.
     e6c:	b6 cf       	rjmp	.-148    	; 0xdda <UartClass::begin(unsigned long, unsigned int)+0xc6>
_set_pins():
     e6e:	2c 2f       	mov	r18, r28
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:551
    }
  #endif
  const uint8_t* muxrow = &(_usart_pins[mod_nbr + mux_set][0]);
  if ((enmask & 0x40 && !(enmask & 0x08))) {
    pinMode(muxrow[0], OUTPUT); // If and only if TX is enabled and open drain isn't should the TX pin be output.
  } else if (enmask & 0x50) { // if it is enabled but is in open drain mode, or is disabled, but loopback is enabled
     e70:	20 75       	andi	r18, 0x50	; 80
     e72:	01 f3       	breq	.-64     	; 0xe34 <UartClass::begin(unsigned long, unsigned int)+0x120>
     e74:	8c 53       	subi	r24, 0x3C	; 60
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:553
    // TX should be INPUT_PULLUP.
    pinMode(muxrow[0], INPUT_PULLUP);
     e76:	9c 44       	sbci	r25, 0x4C	; 76
     e78:	62 e0       	ldi	r22, 0x02	; 2
     e7a:	fc 01       	movw	r30, r24
     e7c:	80 81       	ld	r24, Z
     e7e:	d9 cf       	rjmp	.-78     	; 0xe32 <UartClass::begin(unsigned long, unsigned int)+0x11e>

00000e80 <Print::write(char const*) [clone .part.2] [clone .constprop.52]>:
_ZN5Print5writeEPKc.part.2.constprop.52():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.h:56
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) {
        return 0;
      }
      return write((const uint8_t *)str, strlen(str));
     e80:	fc 01       	movw	r30, r24
     e82:	01 90       	ld	r0, Z+
     e84:	00 20       	and	r0, r0
     e86:	e9 f7       	brne	.-6      	; 0xe82 <Print::write(char const*) [clone .part.2] [clone .constprop.52]+0x2>
     e88:	31 97       	sbiw	r30, 0x01	; 1
     e8a:	af 01       	movw	r20, r30
     e8c:	48 1b       	sub	r20, r24
     e8e:	59 0b       	sbc	r21, r25
     e90:	bc 01       	movw	r22, r24
     e92:	8a e1       	ldi	r24, 0x1A	; 26
     e94:	98 e3       	ldi	r25, 0x38	; 56
     e96:	9d c9       	rjmp	.-3270   	; 0x1d2 <Print::write(unsigned char const*, unsigned int)>

00000e98 <Print::printNumber(unsigned long, unsigned char) [clone .constprop.48]>:
_ZN5Print11printNumberEmh.constprop.48():
     e98:	8f 92       	push	r8
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:215
  return vfprintf_P(&f, (const char *)format, ap);
}

// Private Methods /////////////////////////////////////////////////////////////

size_t Print::printNumber(unsigned long n, uint8_t base) {
     e9a:	9f 92       	push	r9
     e9c:	af 92       	push	r10
     e9e:	bf 92       	push	r11
     ea0:	0f 93       	push	r16
     ea2:	1f 93       	push	r17
     ea4:	cf 93       	push	r28
     ea6:	df 93       	push	r29
     ea8:	cd b7       	in	r28, 0x3d	; 61
     eaa:	de b7       	in	r29, 0x3e	; 62
     eac:	a1 97       	sbiw	r28, 0x21	; 33
     eae:	cd bf       	out	0x3d, r28	; 61
     eb0:	de bf       	out	0x3e, r29	; 62
     eb2:	19 a2       	std	Y+33, r1	; 0x21
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:219
  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
     eb4:	42 30       	cpi	r20, 0x02	; 2
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:222

  // prevent crash if called with base == 1
  if (base < 2) {
     eb6:	08 f4       	brcc	.+2      	; 0xeba <Print::printNumber(unsigned long, unsigned char) [clone .constprop.48]+0x22>
     eb8:	4a e0       	ldi	r20, 0x0A	; 10
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:223
    base = 10;
     eba:	8e 01       	movw	r16, r28
     ebc:	0f 5d       	subi	r16, 0xDF	; 223
     ebe:	1f 4f       	sbci	r17, 0xFF	; 255
     ec0:	84 2e       	mov	r8, r20
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:227
  }

  do {
    char c = n % base;
     ec2:	91 2c       	mov	r9, r1
     ec4:	b1 2c       	mov	r11, r1
     ec6:	a1 2c       	mov	r10, r1
     ec8:	a5 01       	movw	r20, r10
     eca:	94 01       	movw	r18, r8
     ecc:	0e 94 12 17 	call	0x2e24	; 0x2e24 <__udivmodsi4>
     ed0:	e6 2f       	mov	r30, r22
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:228
    n /= base;
     ed2:	b9 01       	movw	r22, r18
     ed4:	ca 01       	movw	r24, r20
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:230

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
     ed6:	ea 30       	cpi	r30, 0x0A	; 10
     ed8:	d4 f4       	brge	.+52     	; 0xf0e <Print::printNumber(unsigned long, unsigned char) [clone .constprop.48]+0x76>
     eda:	e0 5d       	subi	r30, 0xD0	; 208
     edc:	d8 01       	movw	r26, r16
     ede:	ee 93       	st	-X, r30
     ee0:	8d 01       	movw	r16, r26
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:231
  } while (n);
     ee2:	23 2b       	or	r18, r19
     ee4:	24 2b       	or	r18, r20
     ee6:	25 2b       	or	r18, r21
     ee8:	79 f7       	brne	.-34     	; 0xec8 <Print::printNumber(unsigned long, unsigned char) [clone .constprop.48]+0x30>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.h:54
    }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) {
        return 0;
     eea:	90 e0       	ldi	r25, 0x00	; 0
     eec:	80 e0       	ldi	r24, 0x00	; 0
write():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.h:53
      setWriteError(0);
    }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) {
     eee:	10 97       	sbiw	r26, 0x00	; 0
     ef0:	11 f0       	breq	.+4      	; 0xef6 <Print::printNumber(unsigned long, unsigned char) [clone .constprop.48]+0x5e>
     ef2:	cd 01       	movw	r24, r26
     ef4:	c5 df       	rcall	.-118    	; 0xe80 <Print::write(char const*) [clone .part.2] [clone .constprop.52]>
_ZN5Print11printNumberEmh.constprop.48():
     ef6:	a1 96       	adiw	r28, 0x21	; 33
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:234

  return write(str);
}
     ef8:	cd bf       	out	0x3d, r28	; 61
     efa:	de bf       	out	0x3e, r29	; 62
     efc:	df 91       	pop	r29
     efe:	cf 91       	pop	r28
     f00:	1f 91       	pop	r17
     f02:	0f 91       	pop	r16
     f04:	bf 90       	pop	r11
     f06:	af 90       	pop	r10
     f08:	9f 90       	pop	r9
     f0a:	8f 90       	pop	r8
     f0c:	08 95       	ret
     f0e:	e9 5c       	subi	r30, 0xC9	; 201
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:230

  do {
    char c = n % base;
    n /= base;

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
     f10:	e5 cf       	rjmp	.-54     	; 0xedc <Print::printNumber(unsigned long, unsigned char) [clone .constprop.48]+0x44>

00000f12 <Print::println(double, int) [clone .constprop.42]>:
_ZN5Print7printlnEdi.constprop.42():
     f12:	4f 92       	push	r4
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:175
  size_t n = print(num, base);
  n += println();
  return n;
}

size_t Print::println(double num, int digits) {
     f14:	5f 92       	push	r5
     f16:	6f 92       	push	r6
     f18:	7f 92       	push	r7
     f1a:	8f 92       	push	r8
     f1c:	9f 92       	push	r9
     f1e:	af 92       	push	r10
     f20:	bf 92       	push	r11
     f22:	cf 92       	push	r12
     f24:	df 92       	push	r13
     f26:	ef 92       	push	r14
     f28:	ff 92       	push	r15
     f2a:	6b 01       	movw	r12, r22
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:239
}

size_t Print::printFloat(double number, uint8_t digits) {
  size_t n = 0;

  if (isnan(number)) {
     f2c:	7c 01       	movw	r14, r24
printFloat():
     f2e:	ac 01       	movw	r20, r24
     f30:	9b 01       	movw	r18, r22
     f32:	0e 94 e6 15 	call	0x2bcc	; 0x2bcc <__unordsf2>
     f36:	88 23       	and	r24, r24
     f38:	b1 f0       	breq	.+44     	; 0xf66 <Print::println(double, int) [clone .constprop.42]+0x54>
write():
     f3a:	8c e2       	ldi	r24, 0x2C	; 44
     f3c:	94 eb       	ldi	r25, 0xB4	; 180
     f3e:	a0 df       	rcall	.-192    	; 0xe80 <Print::write(char const*) [clone .part.2] [clone .constprop.52]>
     f40:	7c 01       	movw	r14, r24
     f42:	8a e3       	ldi	r24, 0x3A	; 58
     f44:	94 eb       	ldi	r25, 0xB4	; 180
     f46:	9c df       	rcall	.-200    	; 0xe80 <Print::write(char const*) [clone .part.2] [clone .constprop.52]>
_ZN5Print7printlnEdi.constprop.42():
     f48:	8e 0d       	add	r24, r14
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:179

size_t Print::println(double num, int digits) {
  size_t n = print(num, digits);
  n += println();
  return n;
}
     f4a:	9f 1d       	adc	r25, r15
     f4c:	ff 90       	pop	r15
     f4e:	ef 90       	pop	r14
     f50:	df 90       	pop	r13
     f52:	cf 90       	pop	r12
     f54:	bf 90       	pop	r11
     f56:	af 90       	pop	r10
     f58:	9f 90       	pop	r9
     f5a:	8f 90       	pop	r8
     f5c:	7f 90       	pop	r7
     f5e:	6f 90       	pop	r6
     f60:	5f 90       	pop	r5
     f62:	4f 90       	pop	r4
     f64:	08 95       	ret
printFloat():
     f66:	46 01       	movw	r8, r12
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:242
  size_t n = 0;

  if (isnan(number)) {
    return print("nan");
  }
  if (isinf(number)) {
     f68:	57 01       	movw	r10, r14
     f6a:	e8 94       	clt
     f6c:	b7 f8       	bld	r11, 7
     f6e:	2f ef       	ldi	r18, 0xFF	; 255
     f70:	3f ef       	ldi	r19, 0xFF	; 255
     f72:	4f e7       	ldi	r20, 0x7F	; 127
     f74:	5f e7       	ldi	r21, 0x7F	; 127
     f76:	c5 01       	movw	r24, r10
     f78:	b4 01       	movw	r22, r8
     f7a:	0e 94 e6 15 	call	0x2bcc	; 0x2bcc <__unordsf2>
     f7e:	81 11       	cpse	r24, r1
     f80:	0d c0       	rjmp	.+26     	; 0xf9c <Print::println(double, int) [clone .constprop.42]+0x8a>
     f82:	2f ef       	ldi	r18, 0xFF	; 255
     f84:	3f ef       	ldi	r19, 0xFF	; 255
     f86:	4f e7       	ldi	r20, 0x7F	; 127
     f88:	5f e7       	ldi	r21, 0x7F	; 127
     f8a:	c5 01       	movw	r24, r10
     f8c:	b4 01       	movw	r22, r8
     f8e:	0e 94 97 13 	call	0x272e	; 0x272e <__cmpsf2>
     f92:	18 16       	cp	r1, r24
     f94:	1c f4       	brge	.+6      	; 0xf9c <Print::println(double, int) [clone .constprop.42]+0x8a>
write():
     f96:	80 e3       	ldi	r24, 0x30	; 48
     f98:	94 eb       	ldi	r25, 0xB4	; 180
     f9a:	d1 cf       	rjmp	.-94     	; 0xf3e <Print::println(double, int) [clone .constprop.42]+0x2c>
printFloat():
     f9c:	2f ef       	ldi	r18, 0xFF	; 255
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:245
    return print("inf");
  }
  if (number > 4294967040.0) {
     f9e:	3f ef       	ldi	r19, 0xFF	; 255
     fa0:	4f e7       	ldi	r20, 0x7F	; 127
     fa2:	5f e4       	ldi	r21, 0x4F	; 79
     fa4:	c7 01       	movw	r24, r14
     fa6:	b6 01       	movw	r22, r12
     fa8:	0e 94 33 15 	call	0x2a66	; 0x2a66 <__gesf2>
     fac:	18 16       	cp	r1, r24
     fae:	1c f4       	brge	.+6      	; 0xfb6 <Print::println(double, int) [clone .constprop.42]+0xa4>
write():
     fb0:	84 e3       	ldi	r24, 0x34	; 52
     fb2:	94 eb       	ldi	r25, 0xB4	; 180
     fb4:	c4 cf       	rjmp	.-120    	; 0xf3e <Print::println(double, int) [clone .constprop.42]+0x2c>
printFloat():
     fb6:	2f ef       	ldi	r18, 0xFF	; 255
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:248
    return print("ovf");  // constant determined empirically
  }
  if (number < -4294967040.0) {
     fb8:	3f ef       	ldi	r19, 0xFF	; 255
     fba:	4f e7       	ldi	r20, 0x7F	; 127
     fbc:	5f ec       	ldi	r21, 0xCF	; 207
     fbe:	c7 01       	movw	r24, r14
     fc0:	b6 01       	movw	r22, r12
     fc2:	0e 94 97 13 	call	0x272e	; 0x272e <__cmpsf2>
     fc6:	87 fd       	sbrc	r24, 7
     fc8:	f3 cf       	rjmp	.-26     	; 0xfb0 <Print::println(double, int) [clone .constprop.42]+0x9e>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:253
    return print("ovf");  // constant determined empirically
  }

  // Handle negative numbers
  if (number < 0.0) {
     fca:	20 e0       	ldi	r18, 0x00	; 0
     fcc:	30 e0       	ldi	r19, 0x00	; 0
     fce:	a9 01       	movw	r20, r18
     fd0:	c7 01       	movw	r24, r14
     fd2:	b6 01       	movw	r22, r12
     fd4:	0e 94 97 13 	call	0x272e	; 0x272e <__cmpsf2>
_ZN5Print7printlnEdi.constprop.42():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:237

  return write(str);
}

size_t Print::printFloat(double number, uint8_t digits) {
  size_t n = 0;
     fd8:	b1 2c       	mov	r11, r1
     fda:	a1 2c       	mov	r10, r1
printFloat():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:253
  if (number < -4294967040.0) {
    return print("ovf");  // constant determined empirically
  }

  // Handle negative numbers
  if (number < 0.0) {
     fdc:	87 ff       	sbrs	r24, 7
     fde:	09 c0       	rjmp	.+18     	; 0xff2 <Print::println(double, int) [clone .constprop.42]+0xe0>
print():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:71
size_t Print::print(const char str[]) {
  return write(str);
}

size_t Print::print(char c) {
  return write(c);
     fe0:	6d e2       	ldi	r22, 0x2D	; 45
     fe2:	8a e1       	ldi	r24, 0x1A	; 26
     fe4:	98 e3       	ldi	r25, 0x38	; 56
     fe6:	94 d9       	rcall	.-3288   	; 0x310 <UartClass::write(unsigned char)>
     fe8:	5c 01       	movw	r10, r24
printFloat():
     fea:	f7 fa       	bst	r15, 7
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:255
  }

  // Handle negative numbers
  if (number < 0.0) {
    n += print('-');
    number = -number;
     fec:	f0 94       	com	r15
     fee:	f7 f8       	bld	r15, 7
     ff0:	f0 94       	com	r15
     ff2:	2a e0       	ldi	r18, 0x0A	; 10
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:264
  double rounding = 0.5;
  for (uint8_t i = 0; i < digits; ++i) {
    rounding /= 10.0;
  }

  number += rounding;
     ff4:	37 ed       	ldi	r19, 0xD7	; 215
     ff6:	43 ea       	ldi	r20, 0xA3	; 163
     ff8:	5b e3       	ldi	r21, 0x3B	; 59
     ffa:	c7 01       	movw	r24, r14
     ffc:	b6 01       	movw	r22, r12
     ffe:	0e 94 33 13 	call	0x2666	; 0x2666 <__addsf3>
    1002:	2b 01       	movw	r4, r22
    1004:	3c 01       	movw	r6, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:267

  // Extract the integer part of the number and print it
  unsigned long int_part = (unsigned long)number;
    1006:	0e 94 03 14 	call	0x2806	; 0x2806 <__fixunssfsi>
    100a:	6b 01       	movw	r12, r22
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:268
  double remainder = number - (double)int_part;
    100c:	7c 01       	movw	r14, r24
    100e:	0e 94 33 14 	call	0x2866	; 0x2866 <__floatunsisf>
    1012:	9b 01       	movw	r18, r22
    1014:	ac 01       	movw	r20, r24
    1016:	c3 01       	movw	r24, r6
    1018:	b2 01       	movw	r22, r4
    101a:	0e 94 32 13 	call	0x2664	; 0x2664 <__subsf3>
    101e:	2b 01       	movw	r4, r22
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:105

size_t Print::print(unsigned long n, int base) {
  if (base == 0) {
    return write(n);
  } else {
    return printNumber(n, base);
    1020:	3c 01       	movw	r6, r24
print():
    1022:	4a e0       	ldi	r20, 0x0A	; 10
    1024:	c7 01       	movw	r24, r14
    1026:	b6 01       	movw	r22, r12
    1028:	37 df       	rcall	.-402    	; 0xe98 <Print::printNumber(unsigned long, unsigned char) [clone .constprop.48]>
printFloat():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:269
  number += rounding;

  // Extract the integer part of the number and print it
  unsigned long int_part = (unsigned long)number;
  double remainder = number - (double)int_part;
  n += print(int_part);
    102a:	7c 01       	movw	r14, r24
    102c:	ea 0c       	add	r14, r10
    102e:	fb 1c       	adc	r15, r11
write():
    1030:	88 e3       	ldi	r24, 0x38	; 56
    1032:	94 eb       	ldi	r25, 0xB4	; 180
    1034:	25 df       	rcall	.-438    	; 0xe80 <Print::write(char const*) [clone .part.2] [clone .constprop.52]>
printFloat():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:273

  // Print the decimal point, but only if there are digits beyond
  if (digits > 0) {
    n += print(".");
    1036:	e8 0e       	add	r14, r24
    1038:	f9 1e       	adc	r15, r25
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:278
  }

  // Extract digits from the remainder one at a time
  while (digits-- > 0) {
    remainder *= 10.0;
    103a:	20 e0       	ldi	r18, 0x00	; 0
    103c:	30 e0       	ldi	r19, 0x00	; 0
    103e:	40 e2       	ldi	r20, 0x20	; 32
    1040:	51 e4       	ldi	r21, 0x41	; 65
    1042:	c3 01       	movw	r24, r6
    1044:	b2 01       	movw	r22, r4
    1046:	0e 94 37 15 	call	0x2a6e	; 0x2a6e <__mulsf3>
    104a:	2b 01       	movw	r4, r22
    104c:	3c 01       	movw	r6, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:279
    unsigned int toPrint = (unsigned int)remainder;
    104e:	0e 94 03 14 	call	0x2806	; 0x2806 <__fixunssfsi>
print():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:83
size_t Print::print(int n, int base) {
  return print((long) n, base);
}

size_t Print::print(unsigned int n, int base) {
  return print((unsigned long) n, base);
    1052:	4b 01       	movw	r8, r22
    1054:	b1 2c       	mov	r11, r1
    1056:	a1 2c       	mov	r10, r1
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:105

size_t Print::print(unsigned long n, int base) {
  if (base == 0) {
    return write(n);
  } else {
    return printNumber(n, base);
    1058:	4a e0       	ldi	r20, 0x0A	; 10
    105a:	c5 01       	movw	r24, r10
    105c:	b4 01       	movw	r22, r8
    105e:	1c df       	rcall	.-456    	; 0xe98 <Print::printNumber(unsigned long, unsigned char) [clone .constprop.48]>
printFloat():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:280

  // Extract digits from the remainder one at a time
  while (digits-- > 0) {
    remainder *= 10.0;
    unsigned int toPrint = (unsigned int)remainder;
    n += print(toPrint);
    1060:	e8 0e       	add	r14, r24
    1062:	f9 1e       	adc	r15, r25
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:281
    remainder -= toPrint;
    1064:	c5 01       	movw	r24, r10
    1066:	b4 01       	movw	r22, r8
    1068:	0e 94 33 14 	call	0x2866	; 0x2866 <__floatunsisf>
    106c:	9b 01       	movw	r18, r22
    106e:	ac 01       	movw	r20, r24
    1070:	c3 01       	movw	r24, r6
    1072:	b2 01       	movw	r22, r4
    1074:	0e 94 32 13 	call	0x2664	; 0x2664 <__subsf3>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:278
    n += print(".");
  }

  // Extract digits from the remainder one at a time
  while (digits-- > 0) {
    remainder *= 10.0;
    1078:	20 e0       	ldi	r18, 0x00	; 0
    107a:	30 e0       	ldi	r19, 0x00	; 0
    107c:	40 e2       	ldi	r20, 0x20	; 32
    107e:	51 e4       	ldi	r21, 0x41	; 65
    1080:	0e 94 37 15 	call	0x2a6e	; 0x2a6e <__mulsf3>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:279
    unsigned int toPrint = (unsigned int)remainder;
    1084:	0e 94 03 14 	call	0x2806	; 0x2806 <__fixunssfsi>
print():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:83
size_t Print::print(int n, int base) {
  return print((long) n, base);
}

size_t Print::print(unsigned int n, int base) {
  return print((unsigned long) n, base);
    1088:	90 e0       	ldi	r25, 0x00	; 0
    108a:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:105

size_t Print::print(unsigned long n, int base) {
  if (base == 0) {
    return write(n);
  } else {
    return printNumber(n, base);
    108c:	4a e0       	ldi	r20, 0x0A	; 10
    108e:	04 df       	rcall	.-504    	; 0xe98 <Print::printNumber(unsigned long, unsigned char) [clone .constprop.48]>
printFloat():
    1090:	e8 0e       	add	r14, r24
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:280

  // Extract digits from the remainder one at a time
  while (digits-- > 0) {
    remainder *= 10.0;
    unsigned int toPrint = (unsigned int)remainder;
    n += print(toPrint);
    1092:	f9 1e       	adc	r15, r25
    1094:	56 cf       	rjmp	.-340    	; 0xf42 <Print::println(double, int) [clone .constprop.42]+0x30>

00001096 <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int) [clone .constprop.34]>:
_ZN18Adafruit_I2CDevice5writeEPKhjbS1_j.constprop.34():
    1096:	2f 92       	push	r2
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:77
 *            ensure the content of this buffer doesn't change.
 *    @param  prefix_len Number of bytes from prefix buffer to write
 *    @param  stop Whether to send an I2C STOP signal on write
 *    @return True if write was successful, otherwise false.
 */
bool Adafruit_I2CDevice::write(const uint8_t *buffer, size_t len, bool stop,
    1098:	3f 92       	push	r3
    109a:	4f 92       	push	r4
    109c:	5f 92       	push	r5
    109e:	6f 92       	push	r6
    10a0:	7f 92       	push	r7
    10a2:	8f 92       	push	r8
    10a4:	9f 92       	push	r9
    10a6:	af 92       	push	r10
    10a8:	bf 92       	push	r11
    10aa:	cf 92       	push	r12
    10ac:	df 92       	push	r13
    10ae:	ef 92       	push	r14
    10b0:	ff 92       	push	r15
    10b2:	0f 93       	push	r16
    10b4:	1f 93       	push	r17
    10b6:	cf 93       	push	r28
    10b8:	df 93       	push	r29
    10ba:	00 d0       	rcall	.+0      	; 0x10bc <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int) [clone .constprop.34]+0x26>
    10bc:	1f 92       	push	r1
    10be:	cd b7       	in	r28, 0x3d	; 61
    10c0:	de b7       	in	r29, 0x3e	; 62
    10c2:	8c 01       	movw	r16, r24
    10c4:	4b 01       	movw	r8, r22
    10c6:	6a 01       	movw	r12, r20
    10c8:	2b 83       	std	Y+3, r18	; 0x03
    10ca:	2d b6       	in	r2, 0x3d	; 61
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:158
#ifdef DEBUG_SERIAL
    DEBUG_SERIAL.println("Failed to send!");
#endif
    return false;
  }
}
    10cc:	3e b6       	in	r3, 0x3e	; 62
    10ce:	dc 01       	movw	r26, r24
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:80
 *    @return True if write was successful, otherwise false.
 */
bool Adafruit_I2CDevice::write(const uint8_t *buffer, size_t len, bool stop,
                               const uint8_t *prefix_buffer,
                               size_t prefix_len) {
  _wire->beginTransmission(_addr);
    10d0:	11 96       	adiw	r26, 0x01	; 1
    10d2:	ed 91       	ld	r30, X+
    10d4:	fc 91       	ld	r31, X
    10d6:	12 97       	sbiw	r26, 0x02	; 2
beginTransmission():
    10d8:	8c 91       	ld	r24, X
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:307
  if (__builtin_constant_p(address) > 0x7F) {     // Compile-time check if address is actually 7 bit long
    badArg("Supplied address seems to be 8 bit. Only 7-bit-addresses are supported");
    return;
  }
  // set address of targeted client
  vars._clientAddress = address << 1;
    10da:	88 0f       	add	r24, r24
    10dc:	87 87       	std	Z+15, r24	; 0x0f
    10de:	10 8a       	std	Z+16, r1	; 0x10
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:308
  (*txHead) = 0;  // fill buffer from 0
    10e0:	14 96       	adiw	r26, 0x04	; 4
    10e2:	6d 90       	ld	r6, X+
    10e4:	7c 90       	ld	r7, X
    10e6:	15 97       	sbiw	r26, 0x05	; 5
_ZN18Adafruit_I2CDevice5writeEPKhjbS1_j.constprop.34():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:95
    }
  }

  // Write the data itself, chunkify if needed
  size_t bufferSize = maxBufferSize();
  if (bufferSize >= len) {
    10e8:	64 16       	cp	r6, r20
    10ea:	75 06       	cpc	r7, r21
    10ec:	80 f1       	brcs	.+96     	; 0x114e <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int) [clone .constprop.34]+0xb8>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:97
    // can just write
    if (_wire->write(buffer, len) != len) {
    10ee:	11 96       	adiw	r26, 0x01	; 1
    10f0:	8d 91       	ld	r24, X+
    10f2:	9c 91       	ld	r25, X
    10f4:	dc 01       	movw	r26, r24
    10f6:	ed 91       	ld	r30, X+
    10f8:	fc 91       	ld	r31, X
    10fa:	02 80       	ldd	r0, Z+2	; 0x02
    10fc:	f3 81       	ldd	r31, Z+3	; 0x03
    10fe:	e0 2d       	mov	r30, r0
    1100:	09 95       	icall
    1102:	c8 16       	cp	r12, r24
    1104:	d9 06       	cpc	r13, r25
    1106:	09 f0       	breq	.+2      	; 0x110a <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int) [clone .constprop.34]+0x74>
    1108:	62 c0       	rjmp	.+196    	; 0x11ce <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int) [clone .constprop.34]+0x138>
endTransmission():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:338
 *           17 for lines held low or pullups absent.
 *          255 (-1) for TWI not initialized (begin not called) or bus somehow in "unknown" state.
 */
uint8_t TwoWire::endTransmission(bool sendStop) {
  // transmit (blocking)
  return TWI_MasterWrite(&vars, sendStop);
    110a:	f8 01       	movw	r30, r16
    110c:	81 81       	ldd	r24, Z+1	; 0x01
    110e:	92 81       	ldd	r25, Z+2	; 0x02
    1110:	6b 81       	ldd	r22, Y+3	; 0x03
    1112:	0c 96       	adiw	r24, 0x0c	; 12
    1114:	9e da       	rcall	.-2756   	; 0x652 <TWI_MasterWrite>
_ZN18Adafruit_I2CDevice5writeEPKhjbS1_j.constprop.34():
    1116:	91 e0       	ldi	r25, 0x01	; 1
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:147
#ifdef DEBUG_SERIAL
  DEBUG_SERIAL.print("Stop: ");
  DEBUG_SERIAL.println(stop);
#endif

  if (_wire->endTransmission(stop) == 0) {
    1118:	81 11       	cpse	r24, r1
    111a:	59 c0       	rjmp	.+178    	; 0x11ce <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int) [clone .constprop.34]+0x138>
    111c:	89 2f       	mov	r24, r25
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:158
#ifdef DEBUG_SERIAL
    DEBUG_SERIAL.println("Failed to send!");
#endif
    return false;
  }
}
    111e:	2d be       	out	0x3d, r2	; 61
    1120:	3e be       	out	0x3e, r3	; 62
    1122:	23 96       	adiw	r28, 0x03	; 3
    1124:	cd bf       	out	0x3d, r28	; 61
    1126:	de bf       	out	0x3e, r29	; 62
    1128:	df 91       	pop	r29
    112a:	cf 91       	pop	r28
    112c:	1f 91       	pop	r17
    112e:	0f 91       	pop	r16
    1130:	ff 90       	pop	r15
    1132:	ef 90       	pop	r14
    1134:	df 90       	pop	r13
    1136:	cf 90       	pop	r12
    1138:	bf 90       	pop	r11
    113a:	af 90       	pop	r10
    113c:	9f 90       	pop	r9
    113e:	8f 90       	pop	r8
    1140:	7f 90       	pop	r7
    1142:	6f 90       	pop	r6
    1144:	5f 90       	pop	r5
    1146:	4f 90       	pop	r4
    1148:	3f 90       	pop	r3
    114a:	2f 90       	pop	r2
    114c:	08 95       	ret
    114e:	4d b6       	in	r4, 0x3d	; 61
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:117
#ifdef DEBUG_SERIAL
        DEBUG_SERIAL.println(F("\tI2CDevice failed to write"));
#endif
        return false;
      }
    }
    1150:	5e b6       	in	r5, 0x3e	; 62
    1152:	ed b7       	in	r30, 0x3d	; 61
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:106
      return false;
    }
  } else {
    // must chunkify
    size_t pos = 0;
    uint8_t write_buffer[bufferSize];
    1154:	fe b7       	in	r31, 0x3e	; 62
    1156:	e6 19       	sub	r30, r6
    1158:	f7 09       	sbc	r31, r7
    115a:	ed bf       	out	0x3d, r30	; 61
    115c:	fe bf       	out	0x3e, r31	; 62
    115e:	8d b7       	in	r24, 0x3d	; 61
    1160:	9e b7       	in	r25, 0x3e	; 62
    1162:	01 96       	adiw	r24, 0x01	; 1
    1164:	89 83       	std	Y+1, r24	; 0x01
    1166:	9a 83       	std	Y+2, r25	; 0x02
    1168:	b1 2c       	mov	r11, r1
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:105
#endif
      return false;
    }
  } else {
    // must chunkify
    size_t pos = 0;
    116a:	a1 2c       	mov	r10, r1
    116c:	76 01       	movw	r14, r12
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:108
    uint8_t write_buffer[bufferSize];
    while (pos < len) {
      size_t write_len = len - pos > bufferSize ? bufferSize : len - pos;
    116e:	ea 18       	sub	r14, r10
    1170:	fb 08       	sbc	r15, r11
    1172:	6e 14       	cp	r6, r14
    1174:	7f 04       	cpc	r7, r15
    1176:	08 f4       	brcc	.+2      	; 0x117a <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int) [clone .constprop.34]+0xe4>
    1178:	73 01       	movw	r14, r6
    117a:	f4 01       	movw	r30, r8
    117c:	ea 0d       	add	r30, r10
    117e:	fb 1d       	adc	r31, r11
    1180:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:109
      for (size_t i = 0; i < write_len; i++)
    1182:	80 e0       	ldi	r24, 0x00	; 0
    1184:	5f 01       	movw	r10, r30
    1186:	a8 18       	sub	r10, r8
    1188:	b9 08       	sbc	r11, r9
    118a:	8e 15       	cp	r24, r14
    118c:	9f 05       	cpc	r25, r15
    118e:	68 f4       	brcc	.+26     	; 0x11aa <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int) [clone .constprop.34]+0x114>
    1190:	81 91       	ld	r24, Z+
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:110
        write_buffer[i] = buffer[pos++];
    1192:	a9 81       	ldd	r26, Y+1	; 0x01
    1194:	ba 81       	ldd	r27, Y+2	; 0x02
    1196:	8c 93       	st	X, r24
    1198:	81 e0       	ldi	r24, 0x01	; 1
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:109
    // must chunkify
    size_t pos = 0;
    uint8_t write_buffer[bufferSize];
    while (pos < len) {
      size_t write_len = len - pos > bufferSize ? bufferSize : len - pos;
      for (size_t i = 0; i < write_len; i++)
    119a:	90 e0       	ldi	r25, 0x00	; 0
    119c:	f3 cf       	rjmp	.-26     	; 0x1184 <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int) [clone .constprop.34]+0xee>
    119e:	ac 14       	cp	r10, r12
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:107
    }
  } else {
    // must chunkify
    size_t pos = 0;
    uint8_t write_buffer[bufferSize];
    while (pos < len) {
    11a0:	bd 04       	cpc	r11, r13
    11a2:	20 f3       	brcs	.-56     	; 0x116c <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int) [clone .constprop.34]+0xd6>
    11a4:	4d be       	out	0x3d, r4	; 61
    11a6:	5e be       	out	0x3e, r5	; 62
    11a8:	b0 cf       	rjmp	.-160    	; 0x110a <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int) [clone .constprop.34]+0x74>
    11aa:	f8 01       	movw	r30, r16
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:111
      size_t write_len = len - pos > bufferSize ? bufferSize : len - pos;
      for (size_t i = 0; i < write_len; i++)
        write_buffer[i] = buffer[pos++];
      if (_wire->write(write_buffer, write_len) != write_len) {
    11ac:	81 81       	ldd	r24, Z+1	; 0x01
    11ae:	92 81       	ldd	r25, Z+2	; 0x02
    11b0:	dc 01       	movw	r26, r24
    11b2:	ed 91       	ld	r30, X+
    11b4:	fc 91       	ld	r31, X
    11b6:	02 80       	ldd	r0, Z+2	; 0x02
    11b8:	f3 81       	ldd	r31, Z+3	; 0x03
    11ba:	e0 2d       	mov	r30, r0
    11bc:	a7 01       	movw	r20, r14
    11be:	69 81       	ldd	r22, Y+1	; 0x01
    11c0:	7a 81       	ldd	r23, Y+2	; 0x02
    11c2:	09 95       	icall
    11c4:	e8 16       	cp	r14, r24
    11c6:	f9 06       	cpc	r15, r25
    11c8:	51 f3       	breq	.-44     	; 0x119e <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int) [clone .constprop.34]+0x108>
    11ca:	4d be       	out	0x3d, r4	; 61
    11cc:	5e be       	out	0x3e, r5	; 62
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:101
    // can just write
    if (_wire->write(buffer, len) != len) {
#ifdef DEBUG_SERIAL
      DEBUG_SERIAL.println(F("\tI2CDevice failed to write"));
#endif
      return false;
    11ce:	90 e0       	ldi	r25, 0x00	; 0
    11d0:	a5 cf       	rjmp	.-182    	; 0x111c <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int) [clone .constprop.34]+0x86>

000011d2 <Adafruit_BMP280::write8(unsigned char, unsigned char) [clone .constprop.30]>:
_ZN15Adafruit_BMP2806write8Ehh.constprop.30():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:143
/**************************************************************************/
/*!
    @brief  Writes an 8 bit value over I2C/SPI
*/
/**************************************************************************/
void Adafruit_BMP280::write8(byte reg, byte value) {
    11d2:	0f 93       	push	r16
    11d4:	1f 93       	push	r17
    11d6:	cf 93       	push	r28
    11d8:	df 93       	push	r29
    11da:	00 d0       	rcall	.+0      	; 0x11dc <Adafruit_BMP280::write8(unsigned char, unsigned char) [clone .constprop.30]+0xa>
    11dc:	cd b7       	in	r28, 0x3d	; 61
    11de:	de b7       	in	r29, 0x3e	; 62
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:145
  byte buffer[2];
  buffer[1] = value;
    11e0:	6a 83       	std	Y+2, r22	; 0x02
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:146
  if (i2c_dev) {
    11e2:	e0 91 0b 39 	lds	r30, 0x390B	; 0x80390b <bmp+0x2>
    11e6:	f0 91 0c 39 	lds	r31, 0x390C	; 0x80390c <bmp+0x3>
    11ea:	30 97       	sbiw	r30, 0x00	; 0
    11ec:	81 f0       	breq	.+32     	; 0x120e <Adafruit_BMP280::write8(unsigned char, unsigned char) [clone .constprop.30]+0x3c>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:147
    buffer[0] = reg;
    11ee:	89 83       	std	Y+1, r24	; 0x01
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:148
    i2c_dev->write(buffer, 2);
    11f0:	21 e0       	ldi	r18, 0x01	; 1
    11f2:	42 e0       	ldi	r20, 0x02	; 2
    11f4:	50 e0       	ldi	r21, 0x00	; 0
    11f6:	be 01       	movw	r22, r28
    11f8:	6f 5f       	subi	r22, 0xFF	; 255
    11fa:	7f 4f       	sbci	r23, 0xFF	; 255
    11fc:	cf 01       	movw	r24, r30
    11fe:	4b df       	rcall	.-362    	; 0x1096 <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int) [clone .constprop.34]>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:153
  } else {
    buffer[0] = reg & ~0x80;
    spi_dev->write(buffer, 2);
  }
}
    1200:	0f 90       	pop	r0
    1202:	0f 90       	pop	r0
    1204:	df 91       	pop	r29
    1206:	cf 91       	pop	r28
    1208:	1f 91       	pop	r17
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:150
  buffer[1] = value;
  if (i2c_dev) {
    buffer[0] = reg;
    i2c_dev->write(buffer, 2);
  } else {
    buffer[0] = reg & ~0x80;
    120a:	0f 91       	pop	r16
    120c:	08 95       	ret
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:151
    spi_dev->write(buffer, 2);
    120e:	8f 77       	andi	r24, 0x7F	; 127
    1210:	89 83       	std	Y+1, r24	; 0x01
    1212:	00 91 0d 39 	lds	r16, 0x390D	; 0x80390d <bmp+0x4>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:299
 *    @return Always returns true because there's no way to test success of SPI
 * writes
 */
bool Adafruit_SPIDevice::write(uint8_t *buffer, size_t len,
                               uint8_t *prefix_buffer, size_t prefix_len) {
  if (_spi) {
    1216:	10 91 0e 39 	lds	r17, 0x390E	; 0x80390e <bmp+0x5>
write():
    121a:	d8 01       	movw	r26, r16
    121c:	8d 91       	ld	r24, X+
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:300
    _spi->beginTransaction(*_spiSetting);
    121e:	9c 91       	ld	r25, X
    1220:	11 97       	sbiw	r26, 0x01	; 1
    1222:	00 97       	sbiw	r24, 0x00	; 0
    1224:	31 f0       	breq	.+12     	; 0x1232 <Adafruit_BMP280::write8(unsigned char, unsigned char) [clone .constprop.30]+0x60>
    1226:	12 96       	adiw	r26, 0x02	; 2
    1228:	ed 91       	ld	r30, X+
    122a:	fc 91       	ld	r31, X
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:303
  }

  digitalWrite(_cs, LOW);
    122c:	60 81       	ld	r22, Z
    122e:	71 81       	ldd	r23, Z+1	; 0x01
    1230:	c3 db       	rcall	.-2170   	; 0x9b8 <SPIClass::beginTransaction(SPISettings)>
    1232:	60 e0       	ldi	r22, 0x00	; 0
    1234:	f8 01       	movw	r30, r16
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:309
  // do the writing
  for (size_t i = 0; i < prefix_len; i++) {
    transfer(prefix_buffer[i]);
  }
  for (size_t i = 0; i < len; i++) {
    transfer(buffer[i]);
    1236:	83 85       	ldd	r24, Z+11	; 0x0b
    1238:	be dc       	rcall	.-1668   	; 0xbb6 <digitalWrite>
    123a:	69 81       	ldd	r22, Y+1	; 0x01
    123c:	c8 01       	movw	r24, r16
    123e:	5a da       	rcall	.-2892   	; 0x6f4 <Adafruit_SPIDevice::transfer(unsigned char)>
    1240:	6a 81       	ldd	r22, Y+2	; 0x02
    1242:	c8 01       	movw	r24, r16
    1244:	57 da       	rcall	.-2898   	; 0x6f4 <Adafruit_SPIDevice::transfer(unsigned char)>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:311
  }
  digitalWrite(_cs, HIGH);
    1246:	61 e0       	ldi	r22, 0x01	; 1
    1248:	d8 01       	movw	r26, r16
    124a:	1b 96       	adiw	r26, 0x0b	; 11
    124c:	8c 91       	ld	r24, X
    124e:	b3 dc       	rcall	.-1690   	; 0xbb6 <digitalWrite>
    1250:	f8 01       	movw	r30, r16
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:313

  if (_spi) {
    1252:	80 81       	ld	r24, Z
    1254:	91 81       	ldd	r25, Z+1	; 0x01
    1256:	00 97       	sbiw	r24, 0x00	; 0
    1258:	99 f2       	breq	.-90     	; 0x1200 <Adafruit_BMP280::write8(unsigned char, unsigned char) [clone .constprop.30]+0x2e>
    125a:	05 db       	rcall	.-2550   	; 0x866 <SPIClass::endTransaction()>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:314
    _spi->endTransaction();
    125c:	d1 cf       	rjmp	.-94     	; 0x1200 <Adafruit_BMP280::write8(unsigned char, unsigned char) [clone .constprop.30]+0x2e>

0000125e <Adafruit_BMP280::setSampling(Adafruit_BMP280::sensor_mode, Adafruit_BMP280::sensor_sampling, Adafruit_BMP280::sensor_sampling, Adafruit_BMP280::sensor_filter, Adafruit_BMP280::standby_duration) [clone .constprop.27]>:
_ZN15Adafruit_BMP28011setSamplingENS_11sensor_modeENS_15sensor_samplingES1_NS_13sensor_filterENS_16standby_durationE.constprop.27():
    125e:	cf 93       	push	r28
    1260:	df 93       	push	r29
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:122
 * @param filter
 *        The filtering mode to apply (if any).
 * @param duration
 *        The sampling duration.
 */
void Adafruit_BMP280::setSampling(sensor_mode mode,
    1262:	cd e1       	ldi	r28, 0x1D	; 29
    1264:	d9 e3       	ldi	r29, 0x39	; 57
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:127
                                  sensor_sampling tempSampling,
                                  sensor_sampling pressSampling,
                                  sensor_filter filter,
                                  standby_duration duration) {
  _measReg.mode = mode;
    1266:	87 70       	andi	r24, 0x07	; 7
    1268:	67 70       	andi	r22, 0x07	; 7
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:128
  _measReg.osrs_t = tempSampling;
    126a:	66 0f       	add	r22, r22
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:129
  _measReg.osrs_p = pressSampling;
    126c:	66 0f       	add	r22, r22
    126e:	66 0f       	add	r22, r22
    1270:	80 6c       	ori	r24, 0xC0	; 192
    1272:	86 2b       	or	r24, r22
    1274:	88 83       	st	Y, r24
    1276:	ec e1       	ldi	r30, 0x1C	; 28
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:131

  _configReg.filter = filter;
    1278:	f9 e3       	ldi	r31, 0x39	; 57
    127a:	94 2f       	mov	r25, r20
    127c:	97 70       	andi	r25, 0x07	; 7
    127e:	99 0f       	add	r25, r25
    1280:	99 0f       	add	r25, r25
    1282:	99 0f       	add	r25, r25
    1284:	80 81       	ld	r24, Z
    1286:	80 7c       	andi	r24, 0xC0	; 192
    1288:	62 2f       	mov	r22, r18
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:132
  _configReg.t_sb = duration;
    128a:	67 70       	andi	r22, 0x07	; 7
    128c:	89 2b       	or	r24, r25
    128e:	86 2b       	or	r24, r22
    1290:	80 83       	st	Z, r24
get():
    1292:	b9 01       	movw	r22, r18
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.h:232
    /** Unused - don't set */
    unsigned int none : 1;
    /** Enables 3-wire SPI */
    unsigned int spi3w_en : 1;
    /** Used to retrieve the assembled config register's byte value. */
    unsigned int get() { return (t_sb << 5) | (filter << 2) | spi3w_en; }
    1294:	95 e0       	ldi	r25, 0x05	; 5
    1296:	66 0f       	add	r22, r22
    1298:	77 1f       	adc	r23, r23
    129a:	9a 95       	dec	r25
    129c:	e1 f7       	brne	.-8      	; 0x1296 <Adafruit_BMP280::setSampling(Adafruit_BMP280::sensor_mode, Adafruit_BMP280::sensor_sampling, Adafruit_BMP280::sensor_sampling, Adafruit_BMP280::sensor_filter, Adafruit_BMP280::standby_duration) [clone .constprop.27]+0x38>
    129e:	87 fb       	bst	r24, 7
    12a0:	88 27       	eor	r24, r24
    12a2:	80 f9       	bld	r24, 0
    12a4:	68 2b       	or	r22, r24
    12a6:	44 0f       	add	r20, r20
    12a8:	55 1f       	adc	r21, r21
    12aa:	44 0f       	add	r20, r20
    12ac:	55 1f       	adc	r21, r21
    12ae:	64 2b       	or	r22, r20
_ZN15Adafruit_BMP28011setSamplingENS_11sensor_modeENS_15sensor_samplingES1_NS_13sensor_filterENS_16standby_durationE.constprop.27():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:134

  write8(BMP280_REGISTER_CONFIG, _configReg.get());
    12b0:	85 ef       	ldi	r24, 0xF5	; 245
    12b2:	8f df       	rcall	.-226    	; 0x11d2 <Adafruit_BMP280::write8(unsigned char, unsigned char) [clone .constprop.30]>
get():
    12b4:	88 81       	ld	r24, Y
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.h:244
    /** Pressure oversampling. */
    unsigned int osrs_p : 3;
    /** Device mode */
    unsigned int mode : 2;
    /** Used to retrieve the assembled ctrl_meas register's byte value. */
    unsigned int get() { return (osrs_t << 5) | (osrs_p << 2) | mode; }
    12b6:	68 2f       	mov	r22, r24
    12b8:	67 70       	andi	r22, 0x07	; 7
    12ba:	90 e2       	ldi	r25, 0x20	; 32
    12bc:	69 9f       	mul	r22, r25
    12be:	b0 01       	movw	r22, r0
    12c0:	11 24       	eor	r1, r1
    12c2:	28 2f       	mov	r18, r24
    12c4:	26 95       	lsr	r18
    12c6:	26 95       	lsr	r18
    12c8:	26 95       	lsr	r18
    12ca:	27 70       	andi	r18, 0x07	; 7
    12cc:	94 e0       	ldi	r25, 0x04	; 4
    12ce:	29 9f       	mul	r18, r25
    12d0:	90 01       	movw	r18, r0
    12d2:	11 24       	eor	r1, r1
    12d4:	62 2b       	or	r22, r18
    12d6:	82 95       	swap	r24
    12d8:	86 95       	lsr	r24
    12da:	86 95       	lsr	r24
    12dc:	83 70       	andi	r24, 0x03	; 3
    12de:	68 2b       	or	r22, r24
_ZN15Adafruit_BMP28011setSamplingENS_11sensor_modeENS_15sensor_samplingES1_NS_13sensor_filterENS_16standby_durationE.constprop.27():
    12e0:	84 ef       	ldi	r24, 0xF4	; 244
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:135
  write8(BMP280_REGISTER_CONTROL, _measReg.get());
    12e2:	df 91       	pop	r29
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:136
}
    12e4:	cf 91       	pop	r28
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:135

  _configReg.filter = filter;
  _configReg.t_sb = duration;

  write8(BMP280_REGISTER_CONFIG, _configReg.get());
  write8(BMP280_REGISTER_CONTROL, _measReg.get());
    12e6:	75 cf       	rjmp	.-278    	; 0x11d2 <Adafruit_BMP280::write8(unsigned char, unsigned char) [clone .constprop.30]>

000012e8 <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool) [clone .constprop.33]>:
_ZN18Adafruit_I2CDevice15write_then_readEPKhjPhjb.constprop.33():
    12e8:	2f 92       	push	r2
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:238
 *    @param  read_buffer Pointer to buffer of data to read into.
 *    @param  read_len Number of bytes from buffer to read.
 *    @param  stop Whether to send an I2C STOP signal between the write and read
 *    @return True if write & read was successful, otherwise false.
 */
bool Adafruit_I2CDevice::write_then_read(const uint8_t *write_buffer,
    12ea:	3f 92       	push	r3
    12ec:	4f 92       	push	r4
    12ee:	5f 92       	push	r5
    12f0:	6f 92       	push	r6
    12f2:	7f 92       	push	r7
    12f4:	8f 92       	push	r8
    12f6:	9f 92       	push	r9
    12f8:	af 92       	push	r10
    12fa:	bf 92       	push	r11
    12fc:	cf 92       	push	r12
    12fe:	df 92       	push	r13
    1300:	ef 92       	push	r14
    1302:	ff 92       	push	r15
    1304:	0f 93       	push	r16
    1306:	1f 93       	push	r17
    1308:	cf 93       	push	r28
    130a:	df 93       	push	r29
    130c:	cd b7       	in	r28, 0x3d	; 61
    130e:	de b7       	in	r29, 0x3e	; 62
    1310:	29 97       	sbiw	r28, 0x09	; 9
    1312:	cd bf       	out	0x3d, r28	; 61
    1314:	de bf       	out	0x3e, r29	; 62
    1316:	8c 01       	movw	r16, r24
    1318:	6a 01       	movw	r12, r20
    131a:	79 01       	movw	r14, r18
    131c:	2d b7       	in	r18, 0x3d	; 61
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:246
  if (!write(write_buffer, write_len, stop)) {
    return false;
  }

  return read(read_buffer, read_len);
}
    131e:	3e b7       	in	r19, 0x3e	; 62
    1320:	28 87       	std	Y+8, r18	; 0x08
    1322:	39 87       	std	Y+9, r19	; 0x09
    1324:	20 e0       	ldi	r18, 0x00	; 0
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:241
 *    @return True if write & read was successful, otherwise false.
 */
bool Adafruit_I2CDevice::write_then_read(const uint8_t *write_buffer,
                                         size_t write_len, uint8_t *read_buffer,
                                         size_t read_len, bool stop) {
  if (!write(write_buffer, write_len, stop)) {
    1326:	41 e0       	ldi	r20, 0x01	; 1
    1328:	50 e0       	ldi	r21, 0x00	; 0
    132a:	b5 de       	rcall	.-662    	; 0x1096 <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int) [clone .constprop.34]>
    132c:	89 83       	std	Y+1, r24	; 0x01
    132e:	81 11       	cpse	r24, r1
    1330:	1c c0       	rjmp	.+56     	; 0x136a <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool) [clone .constprop.33]+0x82>
    1332:	19 82       	std	Y+1, r1	; 0x01
    1334:	89 81       	ldd	r24, Y+1	; 0x01
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:242
    return false;
    1336:	28 85       	ldd	r18, Y+8	; 0x08
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:246
  }

  return read(read_buffer, read_len);
}
    1338:	39 85       	ldd	r19, Y+9	; 0x09
    133a:	2d bf       	out	0x3d, r18	; 61
    133c:	3e bf       	out	0x3e, r19	; 62
    133e:	29 96       	adiw	r28, 0x09	; 9
    1340:	cd bf       	out	0x3d, r28	; 61
    1342:	de bf       	out	0x3e, r29	; 62
    1344:	df 91       	pop	r29
    1346:	cf 91       	pop	r28
    1348:	1f 91       	pop	r17
    134a:	0f 91       	pop	r16
    134c:	ff 90       	pop	r15
    134e:	ef 90       	pop	r14
    1350:	df 90       	pop	r13
    1352:	cf 90       	pop	r12
    1354:	bf 90       	pop	r11
    1356:	af 90       	pop	r10
    1358:	9f 90       	pop	r9
    135a:	8f 90       	pop	r8
    135c:	7f 90       	pop	r7
    135e:	6f 90       	pop	r6
    1360:	5f 90       	pop	r5
    1362:	4f 90       	pop	r4
    1364:	3f 90       	pop	r3
    1366:	2f 90       	pop	r2
    1368:	08 95       	ret
    136a:	d8 01       	movw	r26, r16
    136c:	14 96       	adiw	r26, 0x04	; 4
    136e:	4d 90       	ld	r4, X+
    1370:	5c 90       	ld	r5, X
    1372:	15 97       	sbiw	r26, 0x05	; 5
read():
    1374:	4e 14       	cp	r4, r14
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:170
 *    @param  stop Whether to send an I2C STOP signal on read
 *    @return True if read was successful, otherwise false.
 */
bool Adafruit_I2CDevice::read(uint8_t *buffer, size_t len, bool stop) {
  size_t bufferSize = maxBufferSize();
  if (bufferSize >= len) {
    1376:	5f 04       	cpc	r5, r15
    1378:	10 f1       	brcs	.+68     	; 0x13be <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool) [clone .constprop.33]+0xd6>
    137a:	11 96       	adiw	r26, 0x01	; 1
    137c:	ed 91       	ld	r30, X+
    137e:	fc 91       	ld	r31, X
    1380:	12 97       	sbiw	r26, 0x02	; 2
requestFrom():
    1382:	9c 91       	ld	r25, X
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:279
}
uint8_t TwoWire::requestFrom(uint8_t  address,  uint8_t  quantity,  uint8_t sendStop) {
  if (quantity > BUFFER_LENGTH) {
    quantity = BUFFER_LENGTH;
  }
  vars._clientAddress = address << 1;
    1384:	99 0f       	add	r25, r25
    1386:	97 87       	std	Z+15, r25	; 0x0f
    1388:	41 e0       	ldi	r20, 0x01	; 1
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:280
  return TWI_MasterRead(&vars, quantity, sendStop);
    138a:	6e 2d       	mov	r22, r14
    138c:	cf 01       	movw	r24, r30
    138e:	0c 96       	adiw	r24, 0x0c	; 12
    1390:	0f d9       	rcall	.-3554   	; 0x5b0 <TWI_MasterRead>
_read():
    1392:	8e 15       	cp	r24, r14
    1394:	1f 04       	cpc	r1, r15
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:196
  size_t recv = _wire->requestFrom((uint8_t)_addr, (uint8_t)len);
#else
  size_t recv = _wire->requestFrom((uint8_t)_addr, (uint8_t)len, (uint8_t)stop);
#endif

  if (recv != len) {
    1396:	69 f6       	brne	.-102    	; 0x1332 <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool) [clone .constprop.33]+0x4a>
    1398:	ec 0c       	add	r14, r12
    139a:	fd 1c       	adc	r15, r13
    139c:	f8 01       	movw	r30, r16
    139e:	81 81       	ldd	r24, Z+1	; 0x01
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:206
#endif
    return false;
  }

  for (uint16_t i = 0; i < len; i++) {
    buffer[i] = _wire->read();
    13a0:	92 81       	ldd	r25, Z+2	; 0x02
    13a2:	dc 01       	movw	r26, r24
    13a4:	ed 91       	ld	r30, X+
    13a6:	fc 91       	ld	r31, X
    13a8:	02 84       	ldd	r0, Z+10	; 0x0a
    13aa:	f3 85       	ldd	r31, Z+11	; 0x0b
    13ac:	e0 2d       	mov	r30, r0
    13ae:	09 95       	icall
    13b0:	f6 01       	movw	r30, r12
    13b2:	81 93       	st	Z+, r24
    13b4:	6f 01       	movw	r12, r30
    13b6:	ee 16       	cp	r14, r30
    13b8:	ff 06       	cpc	r15, r31
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:205
    DEBUG_SERIAL.println(recv);
#endif
    return false;
  }

  for (uint16_t i = 0; i < len; i++) {
    13ba:	81 f7       	brne	.-32     	; 0x139c <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool) [clone .constprop.33]+0xb4>
    13bc:	bb cf       	rjmp	.-138    	; 0x1334 <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool) [clone .constprop.33]+0x4c>
read():
    13be:	2d b7       	in	r18, 0x3d	; 61
    13c0:	3e b7       	in	r19, 0x3e	; 62
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:185
        return false;
      }
      for (size_t i = 0; i < read_len; i++)
        buffer[pos++] = read_buffer[i];
    }
    return true;
    13c2:	2c 83       	std	Y+4, r18	; 0x04
    13c4:	3d 83       	std	Y+5, r19	; 0x05
    13c6:	8d b7       	in	r24, 0x3d	; 61
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:176
    // can just read
    return _read(buffer, len, stop);
  } else {
    // must chunkify
    size_t pos = 0;
    uint8_t read_buffer[bufferSize];
    13c8:	9e b7       	in	r25, 0x3e	; 62
    13ca:	84 19       	sub	r24, r4
    13cc:	95 09       	sbc	r25, r5
    13ce:	8d bf       	out	0x3d, r24	; 61
    13d0:	9e bf       	out	0x3e, r25	; 62
    13d2:	ad b7       	in	r26, 0x3d	; 61
    13d4:	be b7       	in	r27, 0x3e	; 62
    13d6:	11 96       	adiw	r26, 0x01	; 1
    13d8:	aa 83       	std	Y+2, r26	; 0x02
    13da:	bb 83       	std	Y+3, r27	; 0x03
_ZN18Adafruit_I2CDevice15write_then_readEPKhjPhjb.constprop.33():
    13dc:	91 2c       	mov	r9, r1
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:175
  if (bufferSize >= len) {
    // can just read
    return _read(buffer, len, stop);
  } else {
    // must chunkify
    size_t pos = 0;
    13de:	81 2c       	mov	r8, r1
read():
    13e0:	57 01       	movw	r10, r14
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:178
    uint8_t read_buffer[bufferSize];
    while (pos < len) {
      size_t read_len = len - pos > bufferSize ? bufferSize : len - pos;
    13e2:	a8 18       	sub	r10, r8
    13e4:	b9 08       	sbc	r11, r9
    13e6:	4a 14       	cp	r4, r10
    13e8:	5b 04       	cpc	r5, r11
    13ea:	08 f4       	brcc	.+2      	; 0x13ee <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool) [clone .constprop.33]+0x106>
    13ec:	52 01       	movw	r10, r4
_read():
    13ee:	d8 01       	movw	r26, r16
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:193

bool Adafruit_I2CDevice::_read(uint8_t *buffer, size_t len, bool stop) {
#if defined(TinyWireM_h)
  size_t recv = _wire->requestFrom((uint8_t)_addr, (uint8_t)len);
#else
  size_t recv = _wire->requestFrom((uint8_t)_addr, (uint8_t)len, (uint8_t)stop);
    13f0:	11 96       	adiw	r26, 0x01	; 1
    13f2:	ed 91       	ld	r30, X+
    13f4:	fc 91       	ld	r31, X
    13f6:	12 97       	sbiw	r26, 0x02	; 2
requestFrom():
    13f8:	9c 91       	ld	r25, X
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:279
}
uint8_t TwoWire::requestFrom(uint8_t  address,  uint8_t  quantity,  uint8_t sendStop) {
  if (quantity > BUFFER_LENGTH) {
    quantity = BUFFER_LENGTH;
  }
  vars._clientAddress = address << 1;
    13fa:	99 0f       	add	r25, r25
    13fc:	97 87       	std	Z+15, r25	; 0x0f
_read():
    13fe:	6a 2d       	mov	r22, r10
requestFrom():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:193
    1400:	61 32       	cpi	r22, 0x21	; 33
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:280
  return TWI_MasterRead(&vars, quantity, sendStop);
    1402:	08 f0       	brcs	.+2      	; 0x1406 <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool) [clone .constprop.33]+0x11e>
    1404:	60 e2       	ldi	r22, 0x20	; 32
    1406:	40 e0       	ldi	r20, 0x00	; 0
    1408:	cf 01       	movw	r24, r30
    140a:	0c 96       	adiw	r24, 0x0c	; 12
    140c:	d1 d8       	rcall	.-3678   	; 0x5b0 <TWI_MasterRead>
_read():
    140e:	8a 15       	cp	r24, r10
    1410:	1b 04       	cpc	r1, r11
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:196
#endif

  if (recv != len) {
    1412:	89 f5       	brne	.+98     	; 0x1476 <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool) [clone .constprop.33]+0x18e>
    1414:	2a 80       	ldd	r2, Y+2	; 0x02
    1416:	3b 80       	ldd	r3, Y+3	; 0x03
    1418:	f1 01       	movw	r30, r2
    141a:	ea 0d       	add	r30, r10
    141c:	fb 1d       	adc	r31, r11
    141e:	ee 83       	std	Y+6, r30	; 0x06
    1420:	ff 83       	std	Y+7, r31	; 0x07
    1422:	31 01       	movw	r6, r2
    1424:	2e 81       	ldd	r18, Y+6	; 0x06
    1426:	3f 81       	ldd	r19, Y+7	; 0x07
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:205
    DEBUG_SERIAL.println(recv);
#endif
    return false;
  }

  for (uint16_t i = 0; i < len; i++) {
    1428:	26 15       	cp	r18, r6
    142a:	37 05       	cpc	r19, r7
    142c:	81 f4       	brne	.+32     	; 0x144e <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool) [clone .constprop.33]+0x166>
    142e:	f6 01       	movw	r30, r12
    1430:	e8 0d       	add	r30, r8
    1432:	f9 1d       	adc	r31, r9
read():
    1434:	26 14       	cp	r2, r6
    1436:	37 04       	cpc	r3, r7
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:182
    while (pos < len) {
      size_t read_len = len - pos > bufferSize ? bufferSize : len - pos;
      if (!_read(read_buffer, read_len, false)) {
        return false;
      }
      for (size_t i = 0; i < read_len; i++)
    1438:	c9 f4       	brne	.+50     	; 0x146c <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool) [clone .constprop.33]+0x184>
    143a:	8a 0c       	add	r8, r10
    143c:	9b 1c       	adc	r9, r11
    143e:	8e 14       	cp	r8, r14
    1440:	9f 04       	cpc	r9, r15
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:177
    return _read(buffer, len, stop);
  } else {
    // must chunkify
    size_t pos = 0;
    uint8_t read_buffer[bufferSize];
    while (pos < len) {
    1442:	70 f2       	brcs	.-100    	; 0x13e0 <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool) [clone .constprop.33]+0xf8>
    1444:	ec 81       	ldd	r30, Y+4	; 0x04
    1446:	fd 81       	ldd	r31, Y+5	; 0x05
    1448:	ed bf       	out	0x3d, r30	; 61
    144a:	fe bf       	out	0x3e, r31	; 62
    144c:	73 cf       	rjmp	.-282    	; 0x1334 <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool) [clone .constprop.33]+0x4c>
_read():
    144e:	d8 01       	movw	r26, r16
    1450:	11 96       	adiw	r26, 0x01	; 1
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:206
#endif
    return false;
  }

  for (uint16_t i = 0; i < len; i++) {
    buffer[i] = _wire->read();
    1452:	8d 91       	ld	r24, X+
    1454:	9c 91       	ld	r25, X
    1456:	dc 01       	movw	r26, r24
    1458:	ed 91       	ld	r30, X+
    145a:	fc 91       	ld	r31, X
    145c:	02 84       	ldd	r0, Z+10	; 0x0a
    145e:	f3 85       	ldd	r31, Z+11	; 0x0b
    1460:	e0 2d       	mov	r30, r0
    1462:	09 95       	icall
    1464:	f3 01       	movw	r30, r6
    1466:	81 93       	st	Z+, r24
    1468:	3f 01       	movw	r6, r30
    146a:	dc cf       	rjmp	.-72     	; 0x1424 <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool) [clone .constprop.33]+0x13c>
read():
    146c:	d1 01       	movw	r26, r2
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:183
      size_t read_len = len - pos > bufferSize ? bufferSize : len - pos;
      if (!_read(read_buffer, read_len, false)) {
        return false;
      }
      for (size_t i = 0; i < read_len; i++)
        buffer[pos++] = read_buffer[i];
    146e:	8d 91       	ld	r24, X+
    1470:	1d 01       	movw	r2, r26
    1472:	81 93       	st	Z+, r24
    1474:	df cf       	rjmp	.-66     	; 0x1434 <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool) [clone .constprop.33]+0x14c>
_ZN18Adafruit_I2CDevice15write_then_readEPKhjPhjb.constprop.33():
    1476:	19 82       	std	Y+1, r1	; 0x01
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:180
    size_t pos = 0;
    uint8_t read_buffer[bufferSize];
    while (pos < len) {
      size_t read_len = len - pos > bufferSize ? bufferSize : len - pos;
      if (!_read(read_buffer, read_len, false)) {
        return false;
    1478:	e5 cf       	rjmp	.-54     	; 0x1444 <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool) [clone .constprop.33]+0x15c>

0000147a <Adafruit_BMP280::read16_LE(unsigned char) [clone .constprop.23]>:
_ZN15Adafruit_BMP2809read16_LEEh.constprop.23():
    147a:	cf 93       	push	r28
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:189
    spi_dev->write_then_read(buffer, 1, buffer, 2);
  }
  return uint16_t(buffer[0]) << 8 | uint16_t(buffer[1]);
}

uint16_t Adafruit_BMP280::read16_LE(byte reg) {
    147c:	df 93       	push	r29
    147e:	00 d0       	rcall	.+0      	; 0x1480 <Adafruit_BMP280::read16_LE(unsigned char) [clone .constprop.23]+0x6>
    1480:	cd b7       	in	r28, 0x3d	; 61
    1482:	de b7       	in	r29, 0x3e	; 62
read16():
    1484:	e0 91 0b 39 	lds	r30, 0x390B	; 0x80390b <bmp+0x2>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:179
 *  @brief  Reads a 16 bit value over I2C/SPI
 */
uint16_t Adafruit_BMP280::read16(byte reg) {
  uint8_t buffer[2];

  if (i2c_dev) {
    1488:	f0 91 0c 39 	lds	r31, 0x390C	; 0x80390c <bmp+0x3>
    148c:	89 83       	std	Y+1, r24	; 0x01
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:180
    buffer[0] = uint8_t(reg);
    148e:	22 e0       	ldi	r18, 0x02	; 2
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:181
    i2c_dev->write_then_read(buffer, 1, buffer, 2);
    1490:	30 e0       	ldi	r19, 0x00	; 0
    1492:	ae 01       	movw	r20, r28
    1494:	4f 5f       	subi	r20, 0xFF	; 255
    1496:	5f 4f       	sbci	r21, 0xFF	; 255
    1498:	ba 01       	movw	r22, r20
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:179
 *  @brief  Reads a 16 bit value over I2C/SPI
 */
uint16_t Adafruit_BMP280::read16(byte reg) {
  uint8_t buffer[2];

  if (i2c_dev) {
    149a:	30 97       	sbiw	r30, 0x00	; 0
    149c:	49 f0       	breq	.+18     	; 0x14b0 <Adafruit_BMP280::read16_LE(unsigned char) [clone .constprop.23]+0x36>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:181
    buffer[0] = uint8_t(reg);
    i2c_dev->write_then_read(buffer, 1, buffer, 2);
    149e:	cf 01       	movw	r24, r30
    14a0:	23 df       	rcall	.-442    	; 0x12e8 <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool) [clone .constprop.33]>
_ZN15Adafruit_BMP2809read16_LEEh.constprop.23():
    14a2:	89 81       	ldd	r24, Y+1	; 0x01
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:192
}

uint16_t Adafruit_BMP280::read16_LE(byte reg) {
  uint16_t temp = read16(reg);
  return (temp >> 8) | (temp << 8);
}
    14a4:	9a 81       	ldd	r25, Y+2	; 0x02
    14a6:	0f 90       	pop	r0
    14a8:	0f 90       	pop	r0
    14aa:	df 91       	pop	r29
    14ac:	cf 91       	pop	r28
    14ae:	08 95       	ret
read16():
    14b0:	80 91 0d 39 	lds	r24, 0x390D	; 0x80390d <bmp+0x4>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:184
  if (i2c_dev) {
    buffer[0] = uint8_t(reg);
    i2c_dev->write_then_read(buffer, 1, buffer, 2);
  } else {
    buffer[0] = uint8_t(reg | 0x80);
    spi_dev->write_then_read(buffer, 1, buffer, 2);
    14b4:	90 91 0e 39 	lds	r25, 0x390E	; 0x80390e <bmp+0x5>
    14b8:	c7 db       	rcall	.-2162   	; 0xc48 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char) [clone .constprop.36]>
    14ba:	f3 cf       	rjmp	.-26     	; 0x14a2 <Adafruit_BMP280::read16_LE(unsigned char) [clone .constprop.23]+0x28>

000014bc <Adafruit_BMP280::read24(unsigned char)>:
_ZN15Adafruit_BMP2806read24Eh():
    14bc:	cf 93       	push	r28
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:206
}

/*!
 *  @brief  Reads a 24 bit value over I2C/SPI
 */
uint32_t Adafruit_BMP280::read24(byte reg) {
    14be:	df 93       	push	r29
    14c0:	00 d0       	rcall	.+0      	; 0x14c2 <Adafruit_BMP280::read24(unsigned char)+0x6>
    14c2:	1f 92       	push	r1
    14c4:	cd b7       	in	r28, 0x3d	; 61
    14c6:	de b7       	in	r29, 0x3e	; 62
    14c8:	fc 01       	movw	r30, r24
    14ca:	82 81       	ldd	r24, Z+2	; 0x02
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:209
  uint8_t buffer[3];

  if (i2c_dev) {
    14cc:	93 81       	ldd	r25, Z+3	; 0x03
    14ce:	69 83       	std	Y+1, r22	; 0x01
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:210
    buffer[0] = uint8_t(reg);
    14d0:	23 e0       	ldi	r18, 0x03	; 3
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:211
    i2c_dev->write_then_read(buffer, 1, buffer, 3);
    14d2:	30 e0       	ldi	r19, 0x00	; 0
    14d4:	ae 01       	movw	r20, r28
    14d6:	4f 5f       	subi	r20, 0xFF	; 255
    14d8:	5f 4f       	sbci	r21, 0xFF	; 255
    14da:	ba 01       	movw	r22, r20
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:209
 *  @brief  Reads a 24 bit value over I2C/SPI
 */
uint32_t Adafruit_BMP280::read24(byte reg) {
  uint8_t buffer[3];

  if (i2c_dev) {
    14dc:	00 97       	sbiw	r24, 0x00	; 0
    14de:	99 f0       	breq	.+38     	; 0x1506 <Adafruit_BMP280::read24(unsigned char)+0x4a>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:211
    buffer[0] = uint8_t(reg);
    i2c_dev->write_then_read(buffer, 1, buffer, 3);
    14e0:	03 df       	rcall	.-506    	; 0x12e8 <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool) [clone .constprop.33]>
    14e2:	29 81       	ldd	r18, Y+1	; 0x01
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:216
  } else {
    buffer[0] = uint8_t(reg | 0x80);
    spi_dev->write_then_read(buffer, 1, buffer, 3);
  }
  return uint32_t(buffer[0]) << 16 | uint32_t(buffer[1]) << 8 |
    14e4:	6a 81       	ldd	r22, Y+2	; 0x02
    14e6:	70 e0       	ldi	r23, 0x00	; 0
    14e8:	90 e0       	ldi	r25, 0x00	; 0
    14ea:	80 e0       	ldi	r24, 0x00	; 0
    14ec:	98 2f       	mov	r25, r24
    14ee:	87 2f       	mov	r24, r23
    14f0:	76 2f       	mov	r23, r22
    14f2:	66 27       	eor	r22, r22
    14f4:	82 2b       	or	r24, r18
    14f6:	2b 81       	ldd	r18, Y+3	; 0x03
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:217
         uint32_t(buffer[2]);
    14f8:	62 2b       	or	r22, r18
    14fa:	23 96       	adiw	r28, 0x03	; 3
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:218
}
    14fc:	cd bf       	out	0x3d, r28	; 61
    14fe:	de bf       	out	0x3e, r29	; 62
    1500:	df 91       	pop	r29
    1502:	cf 91       	pop	r28
    1504:	08 95       	ret
    1506:	84 81       	ldd	r24, Z+4	; 0x04
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:214
  if (i2c_dev) {
    buffer[0] = uint8_t(reg);
    i2c_dev->write_then_read(buffer, 1, buffer, 3);
  } else {
    buffer[0] = uint8_t(reg | 0x80);
    spi_dev->write_then_read(buffer, 1, buffer, 3);
    1508:	95 81       	ldd	r25, Z+5	; 0x05
    150a:	9e db       	rcall	.-2244   	; 0xc48 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char) [clone .constprop.36]>
    150c:	ea cf       	rjmp	.-44     	; 0x14e2 <Adafruit_BMP280::read24(unsigned char)+0x26>

0000150e <Adafruit_BMP280::readTemperature()>:
_ZN15Adafruit_BMP28015readTemperatureEv():
    150e:	8f 92       	push	r8
    1510:	9f 92       	push	r9
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:243

/*!
 * Reads the temperature from the device.
 * @return The temperature in degress celcius.
 */
float Adafruit_BMP280::readTemperature() {
    1512:	af 92       	push	r10
    1514:	bf 92       	push	r11
    1516:	cf 92       	push	r12
    1518:	df 92       	push	r13
    151a:	ef 92       	push	r14
    151c:	ff 92       	push	r15
    151e:	0f 93       	push	r16
    1520:	1f 93       	push	r17
    1522:	cf 93       	push	r28
    1524:	df 93       	push	r29
    1526:	ec 01       	movw	r28, r24
    1528:	6a ef       	ldi	r22, 0xFA	; 250
    152a:	c8 df       	rcall	.-112    	; 0x14bc <Adafruit_BMP280::read24(unsigned char)>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:246
  int32_t var1, var2;

  int32_t adc_T = read24(BMP280_REGISTER_TEMPDATA);
    152c:	0d 89       	ldd	r16, Y+21	; 0x15
    152e:	1e 89       	ldd	r17, Y+22	; 0x16
    1530:	30 e0       	ldi	r19, 0x00	; 0
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:249
  adc_T >>= 4;

  var1 = ((((adc_T >> 3) - ((int32_t)_bmp280_calib.dig_T1 << 1))) *
    1532:	20 e0       	ldi	r18, 0x00	; 0
    1534:	c7 2e       	mov	r12, r23
    1536:	d8 2e       	mov	r13, r24
    1538:	e9 2e       	mov	r14, r25
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:253
          ((int32_t)_bmp280_calib.dig_T2)) >>
         11;

  var2 = (((((adc_T >> 4) - ((int32_t)_bmp280_calib.dig_T1)) *
    153a:	ff 24       	eor	r15, r15
    153c:	e7 fc       	sbrc	r14, 7
    153e:	fa 94       	dec	r15
    1540:	c0 1a       	sub	r12, r16
    1542:	d1 0a       	sbc	r13, r17
    1544:	e2 0a       	sbc	r14, r18
    1546:	f3 0a       	sbc	r15, r19
    1548:	57 e0       	ldi	r21, 0x07	; 7
    154a:	95 95       	asr	r25
    154c:	87 95       	ror	r24
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:249
  int32_t var1, var2;

  int32_t adc_T = read24(BMP280_REGISTER_TEMPDATA);
  adc_T >>= 4;

  var1 = ((((adc_T >> 3) - ((int32_t)_bmp280_calib.dig_T1 << 1))) *
    154e:	77 95       	ror	r23
    1550:	67 95       	ror	r22
    1552:	5a 95       	dec	r21
    1554:	d1 f7       	brne	.-12     	; 0x154a <Adafruit_BMP280::readTemperature()+0x3c>
    1556:	00 0f       	add	r16, r16
    1558:	11 1f       	adc	r17, r17
    155a:	22 1f       	adc	r18, r18
    155c:	33 1f       	adc	r19, r19
    155e:	4b 01       	movw	r8, r22
    1560:	5c 01       	movw	r10, r24
    1562:	80 1a       	sub	r8, r16
    1564:	91 0a       	sbc	r9, r17
    1566:	a2 0a       	sbc	r10, r18
    1568:	b3 0a       	sbc	r11, r19
    156a:	a5 01       	movw	r20, r10
    156c:	94 01       	movw	r18, r8
    156e:	af 89       	ldd	r26, Y+23	; 0x17
    1570:	b8 8d       	ldd	r27, Y+24	; 0x18
    1572:	0e 94 3e 17 	call	0x2e7c	; 0x2e7c <__mulshisi3>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:250
          ((int32_t)_bmp280_calib.dig_T2)) >>
    1576:	4b 01       	movw	r8, r22
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:249
  int32_t var1, var2;

  int32_t adc_T = read24(BMP280_REGISTER_TEMPDATA);
  adc_T >>= 4;

  var1 = ((((adc_T >> 3) - ((int32_t)_bmp280_calib.dig_T1 << 1))) *
    1578:	5c 01       	movw	r10, r24
    157a:	fb e0       	ldi	r31, 0x0B	; 11
    157c:	b5 94       	asr	r11
    157e:	a7 94       	ror	r10
    1580:	97 94       	ror	r9
    1582:	87 94       	ror	r8
    1584:	fa 95       	dec	r31
    1586:	d1 f7       	brne	.-12     	; 0x157c <Adafruit_BMP280::readTemperature()+0x6e>
    1588:	a7 01       	movw	r20, r14
    158a:	96 01       	movw	r18, r12
    158c:	c7 01       	movw	r24, r14
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:253
          ((int32_t)_bmp280_calib.dig_T2)) >>
         11;

  var2 = (((((adc_T >> 4) - ((int32_t)_bmp280_calib.dig_T1)) *
    158e:	b6 01       	movw	r22, r12
    1590:	0e 94 03 17 	call	0x2e06	; 0x2e06 <__mulsi3>
    1594:	9b 01       	movw	r18, r22
    1596:	ac 01       	movw	r20, r24
    1598:	ac e0       	ldi	r26, 0x0C	; 12
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:254
            ((adc_T >> 4) - ((int32_t)_bmp280_calib.dig_T1))) >>
    159a:	55 95       	asr	r21
    159c:	47 95       	ror	r20
    159e:	37 95       	ror	r19
    15a0:	27 95       	ror	r18
    15a2:	aa 95       	dec	r26
    15a4:	d1 f7       	brne	.-12     	; 0x159a <Adafruit_BMP280::readTemperature()+0x8c>
    15a6:	a9 8d       	ldd	r26, Y+25	; 0x19
    15a8:	ba 8d       	ldd	r27, Y+26	; 0x1a
    15aa:	0e 94 3e 17 	call	0x2e7c	; 0x2e7c <__mulshisi3>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:256
           12) *
          ((int32_t)_bmp280_calib.dig_T3)) >>
    15ae:	9b 01       	movw	r18, r22
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:255
          ((int32_t)_bmp280_calib.dig_T2)) >>
         11;

  var2 = (((((adc_T >> 4) - ((int32_t)_bmp280_calib.dig_T1)) *
            ((adc_T >> 4) - ((int32_t)_bmp280_calib.dig_T1))) >>
           12) *
    15b0:	ac 01       	movw	r20, r24
    15b2:	be e0       	ldi	r27, 0x0E	; 14
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:253

  var1 = ((((adc_T >> 3) - ((int32_t)_bmp280_calib.dig_T1 << 1))) *
          ((int32_t)_bmp280_calib.dig_T2)) >>
         11;

  var2 = (((((adc_T >> 4) - ((int32_t)_bmp280_calib.dig_T1)) *
    15b4:	55 95       	asr	r21
    15b6:	47 95       	ror	r20
    15b8:	37 95       	ror	r19
    15ba:	27 95       	ror	r18
    15bc:	ba 95       	dec	r27
    15be:	d1 f7       	brne	.-12     	; 0x15b4 <Adafruit_BMP280::readTemperature()+0xa6>
    15c0:	28 0d       	add	r18, r8
    15c2:	39 1d       	adc	r19, r9
    15c4:	4a 1d       	adc	r20, r10
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:259
            ((adc_T >> 4) - ((int32_t)_bmp280_calib.dig_T1))) >>
           12) *
          ((int32_t)_bmp280_calib.dig_T3)) >>
         14;

  t_fine = var1 + var2;
    15c6:	5b 1d       	adc	r21, r11
    15c8:	2f 87       	std	Y+15, r18	; 0x0f
    15ca:	38 8b       	std	Y+16, r19	; 0x10
    15cc:	49 8b       	std	Y+17, r20	; 0x11
    15ce:	5a 8b       	std	Y+18, r21	; 0x12
    15d0:	a5 e0       	ldi	r26, 0x05	; 5
    15d2:	b0 e0       	ldi	r27, 0x00	; 0
    15d4:	0e 94 34 17 	call	0x2e68	; 0x2e68 <__muluhisi3>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:261

  float T = (t_fine * 5 + 128) >> 8;
    15d8:	60 58       	subi	r22, 0x80	; 128
    15da:	7f 4f       	sbci	r23, 0xFF	; 255
    15dc:	8f 4f       	sbci	r24, 0xFF	; 255
    15de:	9f 4f       	sbci	r25, 0xFF	; 255
    15e0:	67 2f       	mov	r22, r23
    15e2:	78 2f       	mov	r23, r24
    15e4:	89 2f       	mov	r24, r25
    15e6:	99 27       	eor	r25, r25
    15e8:	87 fd       	sbrc	r24, 7
    15ea:	9a 95       	dec	r25
    15ec:	0e 94 35 14 	call	0x286a	; 0x286a <__floatsisf>
    15f0:	20 e0       	ldi	r18, 0x00	; 0
    15f2:	30 e0       	ldi	r19, 0x00	; 0
    15f4:	48 ec       	ldi	r20, 0xC8	; 200
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:262
  return T / 100;
    15f6:	52 e4       	ldi	r21, 0x42	; 66
    15f8:	0e 94 9b 13 	call	0x2736	; 0x2736 <__divsf3>
    15fc:	df 91       	pop	r29
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:263
}
    15fe:	cf 91       	pop	r28
    1600:	1f 91       	pop	r17
    1602:	0f 91       	pop	r16
    1604:	ff 90       	pop	r15
    1606:	ef 90       	pop	r14
    1608:	df 90       	pop	r13
    160a:	cf 90       	pop	r12
    160c:	bf 90       	pop	r11
    160e:	af 90       	pop	r10
    1610:	9f 90       	pop	r9
    1612:	8f 90       	pop	r8
    1614:	08 95       	ret

00001616 <Adafruit_BMP280::readPressure()>:
_ZN15Adafruit_BMP28012readPressureEv():
    1616:	2f 92       	push	r2
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:269

/*!
 * Reads the barometric pressure from the device.
 * @return Barometric pressure in Pa.
 */
float Adafruit_BMP280::readPressure() {
    1618:	3f 92       	push	r3
    161a:	4f 92       	push	r4
    161c:	5f 92       	push	r5
    161e:	6f 92       	push	r6
    1620:	7f 92       	push	r7
    1622:	8f 92       	push	r8
    1624:	9f 92       	push	r9
    1626:	af 92       	push	r10
    1628:	bf 92       	push	r11
    162a:	cf 92       	push	r12
    162c:	df 92       	push	r13
    162e:	ef 92       	push	r14
    1630:	ff 92       	push	r15
    1632:	0f 93       	push	r16
    1634:	1f 93       	push	r17
    1636:	cf 93       	push	r28
    1638:	df 93       	push	r29
    163a:	cd b7       	in	r28, 0x3d	; 61
    163c:	de b7       	in	r29, 0x3e	; 62
    163e:	6d 97       	sbiw	r28, 0x1d	; 29
    1640:	cd bf       	out	0x3d, r28	; 61
    1642:	de bf       	out	0x3e, r29	; 62
    1644:	8c 8f       	std	Y+28, r24	; 0x1c
    1646:	9d 8f       	std	Y+29, r25	; 0x1d
    1648:	62 df       	rcall	.-316    	; 0x150e <Adafruit_BMP280::readTemperature()>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:273
  int64_t var1, var2, p;

  // Must be done first to get the t_fine variable set up
  readTemperature();
    164a:	67 ef       	ldi	r22, 0xF7	; 247
    164c:	8c 8d       	ldd	r24, Y+28	; 0x1c
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:275

  int32_t adc_P = read24(BMP280_REGISTER_PRESSUREDATA);
    164e:	9d 8d       	ldd	r25, Y+29	; 0x1d
    1650:	35 df       	rcall	.-406    	; 0x14bc <Adafruit_BMP280::read24(unsigned char)>
    1652:	68 8f       	std	Y+24, r22	; 0x18
    1654:	79 8f       	std	Y+25, r23	; 0x19
    1656:	8a 8f       	std	Y+26, r24	; 0x1a
    1658:	9b 8f       	std	Y+27, r25	; 0x1b
    165a:	ec 8d       	ldd	r30, Y+28	; 0x1c
    165c:	fd 8d       	ldd	r31, Y+29	; 0x1d
    165e:	87 85       	ldd	r24, Z+15	; 0x0f
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:278
  adc_P >>= 4;

  var1 = ((int64_t)t_fine) - 128000;
    1660:	90 89       	ldd	r25, Z+16	; 0x10
    1662:	a1 89       	ldd	r26, Z+17	; 0x11
    1664:	b2 89       	ldd	r27, Z+18	; 0x12
    1666:	6c 01       	movw	r12, r24
    1668:	7d 01       	movw	r14, r26
    166a:	ff 0c       	add	r15, r15
    166c:	cc 08       	sbc	r12, r12
    166e:	dc 2c       	mov	r13, r12
    1670:	76 01       	movw	r14, r12
    1672:	9c 01       	movw	r18, r24
    1674:	ad 01       	movw	r20, r26
    1676:	6c 2d       	mov	r22, r12
    1678:	7c 2d       	mov	r23, r12
    167a:	8c 2d       	mov	r24, r12
    167c:	9c 2d       	mov	r25, r12
    167e:	34 5f       	subi	r19, 0xF4	; 244
    1680:	41 40       	sbci	r20, 0x01	; 1
    1682:	51 09       	sbc	r21, r1
    1684:	61 09       	sbc	r22, r1
    1686:	71 09       	sbc	r23, r1
    1688:	81 09       	sbc	r24, r1
    168a:	91 09       	sbc	r25, r1
    168c:	29 87       	std	Y+9, r18	; 0x09
    168e:	3a 87       	std	Y+10, r19	; 0x0a
    1690:	4b 87       	std	Y+11, r20	; 0x0b
    1692:	5c 87       	std	Y+12, r21	; 0x0c
    1694:	3b 01       	movw	r6, r22
    1696:	4c 01       	movw	r8, r24
    1698:	59 01       	movw	r10, r18
    169a:	6a 01       	movw	r12, r20
    169c:	7b 01       	movw	r14, r22
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:279
  var2 = var1 * var1 * (int64_t)_bmp280_calib.dig_P6;
    169e:	8c 01       	movw	r16, r24
    16a0:	0e 94 44 17 	call	0x2e88	; 0x2e88 <__muldi3>
    16a4:	32 2e       	mov	r3, r18
    16a6:	23 2e       	mov	r2, r19
    16a8:	4a 8b       	std	Y+18, r20	; 0x12
    16aa:	5b 8b       	std	Y+19, r21	; 0x13
    16ac:	6c 8b       	std	Y+20, r22	; 0x14
    16ae:	7d 8b       	std	Y+21, r23	; 0x15
    16b0:	8e 8b       	std	Y+22, r24	; 0x16
    16b2:	9f 8b       	std	Y+23, r25	; 0x17
    16b4:	ac 8d       	ldd	r26, Y+28	; 0x1c
    16b6:	bd 8d       	ldd	r27, Y+29	; 0x1d
    16b8:	5e 96       	adiw	r26, 0x1e	; 30
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:283
  var2 = var2 + ((var1 * (int64_t)_bmp280_calib.dig_P5) << 17);
  var2 = var2 + (((int64_t)_bmp280_calib.dig_P4) << 35);
  var1 = ((var1 * var1 * (int64_t)_bmp280_calib.dig_P3) >> 8) +
         ((var1 * (int64_t)_bmp280_calib.dig_P2) << 12);
    16ba:	3c 91       	ld	r19, X
    16bc:	5e 97       	sbiw	r26, 0x1e	; 30
    16be:	5d 96       	adiw	r26, 0x1d	; 29
    16c0:	2c 91       	ld	r18, X
    16c2:	93 2f       	mov	r25, r19
    16c4:	99 0f       	add	r25, r25
    16c6:	99 0b       	sbc	r25, r25
    16c8:	49 2f       	mov	r20, r25
    16ca:	59 2f       	mov	r21, r25
    16cc:	69 2f       	mov	r22, r25
    16ce:	79 2f       	mov	r23, r25
    16d0:	89 2f       	mov	r24, r25
    16d2:	0e 94 44 17 	call	0x2e88	; 0x2e88 <__muldi3>
    16d6:	0c e0       	ldi	r16, 0x0C	; 12
    16d8:	0e 94 2d 18 	call	0x305a	; 0x305a <__ashldi3>
    16dc:	52 2e       	mov	r5, r18
    16de:	39 83       	std	Y+1, r19	; 0x01
    16e0:	4d 87       	std	Y+13, r20	; 0x0d
    16e2:	5e 87       	std	Y+14, r21	; 0x0e
    16e4:	6f 87       	std	Y+15, r22	; 0x0f
    16e6:	78 8b       	std	Y+16, r23	; 0x10
    16e8:	89 8b       	std	Y+17, r24	; 0x11
    16ea:	49 2e       	mov	r4, r25
    16ec:	ec 8d       	ldd	r30, Y+28	; 0x1c
    16ee:	fd 8d       	ldd	r31, Y+29	; 0x1d
    16f0:	30 a1       	ldd	r19, Z+32	; 0x20
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:282

  var1 = ((int64_t)t_fine) - 128000;
  var2 = var1 * var1 * (int64_t)_bmp280_calib.dig_P6;
  var2 = var2 + ((var1 * (int64_t)_bmp280_calib.dig_P5) << 17);
  var2 = var2 + (((int64_t)_bmp280_calib.dig_P4) << 35);
  var1 = ((var1 * var1 * (int64_t)_bmp280_calib.dig_P3) >> 8) +
    16f2:	27 8d       	ldd	r18, Z+31	; 0x1f
    16f4:	93 2f       	mov	r25, r19
    16f6:	99 0f       	add	r25, r25
    16f8:	99 0b       	sbc	r25, r25
    16fa:	a3 2c       	mov	r10, r3
    16fc:	b2 2c       	mov	r11, r2
    16fe:	ca 88       	ldd	r12, Y+18	; 0x12
    1700:	db 88       	ldd	r13, Y+19	; 0x13
    1702:	ec 88       	ldd	r14, Y+20	; 0x14
    1704:	fd 88       	ldd	r15, Y+21	; 0x15
    1706:	0e 89       	ldd	r16, Y+22	; 0x16
    1708:	1f 89       	ldd	r17, Y+23	; 0x17
    170a:	49 2f       	mov	r20, r25
    170c:	59 2f       	mov	r21, r25
    170e:	69 2f       	mov	r22, r25
    1710:	79 2f       	mov	r23, r25
    1712:	89 2f       	mov	r24, r25
    1714:	0e 94 44 17 	call	0x2e88	; 0x2e88 <__muldi3>
    1718:	08 e0       	ldi	r16, 0x08	; 8
    171a:	0e 94 46 18 	call	0x308c	; 0x308c <__ashrdi3>
    171e:	a5 2c       	mov	r10, r5
    1720:	b9 80       	ldd	r11, Y+1	; 0x01
    1722:	cd 84       	ldd	r12, Y+13	; 0x0d
    1724:	de 84       	ldd	r13, Y+14	; 0x0e
    1726:	ef 84       	ldd	r14, Y+15	; 0x0f
    1728:	f8 88       	ldd	r15, Y+16	; 0x10
    172a:	09 89       	ldd	r16, Y+17	; 0x11
    172c:	14 2d       	mov	r17, r4
    172e:	0e 94 63 18 	call	0x30c6	; 0x30c6 <__adddi3>
    1732:	70 58       	subi	r23, 0x80	; 128
    1734:	8f 4f       	sbci	r24, 0xFF	; 255
    1736:	9f 4f       	sbci	r25, 0xFF	; 255
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:285
         ((var1 * (int64_t)_bmp280_calib.dig_P2) << 12);
  var1 =
      (((((int64_t)1) << 47) + var1)) * ((int64_t)_bmp280_calib.dig_P1) >> 33;
    1738:	ac 8d       	ldd	r26, Y+28	; 0x1c
    173a:	bd 8d       	ldd	r27, Y+29	; 0x1d
    173c:	5b 96       	adiw	r26, 0x1b	; 27
    173e:	ed 91       	ld	r30, X+
    1740:	fc 91       	ld	r31, X
    1742:	5f 01       	movw	r10, r30
    1744:	d1 2c       	mov	r13, r1
    1746:	c1 2c       	mov	r12, r1
    1748:	e1 2c       	mov	r14, r1
    174a:	f1 2c       	mov	r15, r1
    174c:	87 01       	movw	r16, r14
    174e:	e9 83       	std	Y+1, r30	; 0x01
    1750:	ba 82       	std	Y+2, r11	; 0x02
    1752:	cb 82       	std	Y+3, r12	; 0x03
    1754:	dc 82       	std	Y+4, r13	; 0x04
    1756:	ed 82       	std	Y+5, r14	; 0x05
    1758:	fe 82       	std	Y+6, r15	; 0x06
    175a:	0f 83       	std	Y+7, r16	; 0x07
    175c:	18 87       	std	Y+8, r17	; 0x08
    175e:	c1 2c       	mov	r12, r1
    1760:	d1 2c       	mov	r13, r1
    1762:	e1 2c       	mov	r14, r1
    1764:	f1 2c       	mov	r15, r1
    1766:	00 e0       	ldi	r16, 0x00	; 0
    1768:	10 e0       	ldi	r17, 0x00	; 0
    176a:	0e 94 44 17 	call	0x2e88	; 0x2e88 <__muldi3>
    176e:	01 e2       	ldi	r16, 0x21	; 33
    1770:	0e 94 46 18 	call	0x308c	; 0x308c <__ashrdi3>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:284
  var2 = var1 * var1 * (int64_t)_bmp280_calib.dig_P6;
  var2 = var2 + ((var1 * (int64_t)_bmp280_calib.dig_P5) << 17);
  var2 = var2 + (((int64_t)_bmp280_calib.dig_P4) << 35);
  var1 = ((var1 * var1 * (int64_t)_bmp280_calib.dig_P3) >> 8) +
         ((var1 * (int64_t)_bmp280_calib.dig_P2) << 12);
  var1 =
    1774:	29 83       	std	Y+1, r18	; 0x01
    1776:	53 2e       	mov	r5, r19
    1778:	4d 87       	std	Y+13, r20	; 0x0d
    177a:	5e 87       	std	Y+14, r21	; 0x0e
    177c:	6f 87       	std	Y+15, r22	; 0x0f
    177e:	78 8b       	std	Y+16, r23	; 0x10
    1780:	89 8b       	std	Y+17, r24	; 0x11
    1782:	49 2e       	mov	r4, r25
    1784:	a0 e0       	ldi	r26, 0x00	; 0
    1786:	0e 94 75 18 	call	0x30ea	; 0x30ea <__cmpdi2_s8>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:287
      (((((int64_t)1) << 47) + var1)) * ((int64_t)_bmp280_calib.dig_P1) >> 33;

  if (var1 == 0) {
    178a:	09 f4       	brne	.+2      	; 0x178e <Adafruit_BMP280::readPressure()+0x178>
    178c:	39 c1       	rjmp	.+626    	; 0x1a00 <Adafruit_BMP280::readPressure()+0x3ea>
    178e:	ac 8d       	ldd	r26, Y+28	; 0x1c
    1790:	bd 8d       	ldd	r27, Y+29	; 0x1d
    1792:	96 96       	adiw	r26, 0x26	; 38
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:279

  int32_t adc_P = read24(BMP280_REGISTER_PRESSUREDATA);
  adc_P >>= 4;

  var1 = ((int64_t)t_fine) - 128000;
  var2 = var1 * var1 * (int64_t)_bmp280_calib.dig_P6;
    1794:	3c 91       	ld	r19, X
    1796:	96 97       	sbiw	r26, 0x26	; 38
    1798:	95 96       	adiw	r26, 0x25	; 37
    179a:	2c 91       	ld	r18, X
    179c:	93 2f       	mov	r25, r19
    179e:	99 0f       	add	r25, r25
    17a0:	99 0b       	sbc	r25, r25
    17a2:	a3 2c       	mov	r10, r3
    17a4:	b2 2c       	mov	r11, r2
    17a6:	ca 88       	ldd	r12, Y+18	; 0x12
    17a8:	db 88       	ldd	r13, Y+19	; 0x13
    17aa:	ec 88       	ldd	r14, Y+20	; 0x14
    17ac:	fd 88       	ldd	r15, Y+21	; 0x15
    17ae:	0e 89       	ldd	r16, Y+22	; 0x16
    17b0:	1f 89       	ldd	r17, Y+23	; 0x17
    17b2:	49 2f       	mov	r20, r25
    17b4:	59 2f       	mov	r21, r25
    17b6:	69 2f       	mov	r22, r25
    17b8:	79 2f       	mov	r23, r25
    17ba:	89 2f       	mov	r24, r25
    17bc:	0e 94 44 17 	call	0x2e88	; 0x2e88 <__muldi3>
    17c0:	19 01       	movw	r2, r18
    17c2:	4a 8b       	std	Y+18, r20	; 0x12
    17c4:	5b 8b       	std	Y+19, r21	; 0x13
    17c6:	6c 8b       	std	Y+20, r22	; 0x14
    17c8:	7d 8b       	std	Y+21, r23	; 0x15
    17ca:	8e 8b       	std	Y+22, r24	; 0x16
    17cc:	9f 8b       	std	Y+23, r25	; 0x17
    17ce:	ec 8d       	ldd	r30, Y+28	; 0x1c
    17d0:	fd 8d       	ldd	r31, Y+29	; 0x1d
    17d2:	34 a1       	ldd	r19, Z+36	; 0x24
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:280
  var2 = var2 + ((var1 * (int64_t)_bmp280_calib.dig_P5) << 17);
    17d4:	23 a1       	ldd	r18, Z+35	; 0x23
    17d6:	93 2f       	mov	r25, r19
    17d8:	99 0f       	add	r25, r25
    17da:	99 0b       	sbc	r25, r25
    17dc:	a9 84       	ldd	r10, Y+9	; 0x09
    17de:	ba 84       	ldd	r11, Y+10	; 0x0a
    17e0:	cb 84       	ldd	r12, Y+11	; 0x0b
    17e2:	dc 84       	ldd	r13, Y+12	; 0x0c
    17e4:	73 01       	movw	r14, r6
    17e6:	84 01       	movw	r16, r8
    17e8:	49 2f       	mov	r20, r25
    17ea:	59 2f       	mov	r21, r25
    17ec:	69 2f       	mov	r22, r25
    17ee:	79 2f       	mov	r23, r25
    17f0:	89 2f       	mov	r24, r25
    17f2:	0e 94 44 17 	call	0x2e88	; 0x2e88 <__muldi3>
    17f6:	01 e1       	ldi	r16, 0x11	; 17
    17f8:	0e 94 2d 18 	call	0x305a	; 0x305a <__ashldi3>
    17fc:	51 01       	movw	r10, r2
    17fe:	ca 88       	ldd	r12, Y+18	; 0x12
    1800:	db 88       	ldd	r13, Y+19	; 0x13
    1802:	ec 88       	ldd	r14, Y+20	; 0x14
    1804:	fd 88       	ldd	r15, Y+21	; 0x15
    1806:	0e 89       	ldd	r16, Y+22	; 0x16
    1808:	1f 89       	ldd	r17, Y+23	; 0x17
    180a:	0e 94 63 18 	call	0x30c6	; 0x30c6 <__adddi3>
    180e:	59 01       	movw	r10, r18
    1810:	6a 01       	movw	r12, r20
    1812:	7b 01       	movw	r14, r22
    1814:	28 2e       	mov	r2, r24
    1816:	19 2f       	mov	r17, r25
    1818:	48 8d       	ldd	r20, Y+24	; 0x18
    181a:	59 8d       	ldd	r21, Y+25	; 0x19
    181c:	6a 8d       	ldd	r22, Y+26	; 0x1a
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:276

  // Must be done first to get the t_fine variable set up
  readTemperature();

  int32_t adc_P = read24(BMP280_REGISTER_PRESSUREDATA);
  adc_P >>= 4;
    181e:	7b 8d       	ldd	r23, Y+27	; 0x1b
    1820:	84 e0       	ldi	r24, 0x04	; 4
    1822:	75 95       	asr	r23
    1824:	67 95       	ror	r22
    1826:	57 95       	ror	r21
    1828:	47 95       	ror	r20
    182a:	8a 95       	dec	r24
    182c:	d1 f7       	brne	.-12     	; 0x1822 <Adafruit_BMP280::readPressure()+0x20c>
    182e:	80 e0       	ldi	r24, 0x00	; 0
    1830:	90 e0       	ldi	r25, 0x00	; 0
    1832:	a0 e1       	ldi	r26, 0x10	; 16
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:290
      (((((int64_t)1) << 47) + var1)) * ((int64_t)_bmp280_calib.dig_P1) >> 33;

  if (var1 == 0) {
    return 0; // avoid exception caused by division by zero
  }
  p = 1048576 - adc_P;
    1834:	b0 e0       	ldi	r27, 0x00	; 0
    1836:	84 1b       	sub	r24, r20
    1838:	95 0b       	sbc	r25, r21
    183a:	a6 0b       	sbc	r26, r22
    183c:	b7 0b       	sbc	r27, r23
    183e:	3c 01       	movw	r6, r24
    1840:	4d 01       	movw	r8, r26
    1842:	99 0c       	add	r9, r9
    1844:	66 08       	sbc	r6, r6
    1846:	76 2c       	mov	r7, r6
    1848:	43 01       	movw	r8, r6
    184a:	9c 01       	movw	r18, r24
    184c:	ad 01       	movw	r20, r26
    184e:	66 2d       	mov	r22, r6
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:291
  p = (((p << 31) - var2) * 3125) / var1;
    1850:	76 2d       	mov	r23, r6
    1852:	86 2d       	mov	r24, r6
    1854:	96 2d       	mov	r25, r6
    1856:	0f e1       	ldi	r16, 0x1F	; 31
    1858:	0e 94 2d 18 	call	0x305a	; 0x305a <__ashldi3>
    185c:	72 2e       	mov	r7, r18
    185e:	83 2e       	mov	r8, r19
    1860:	94 2e       	mov	r9, r20
    1862:	65 2e       	mov	r6, r21
    1864:	b6 2f       	mov	r27, r22
    1866:	a7 2f       	mov	r26, r23
    1868:	38 2e       	mov	r3, r24
    186a:	99 87       	std	Y+9, r25	; 0x09
    186c:	ec 8d       	ldd	r30, Y+28	; 0x1c
    186e:	fd 8d       	ldd	r31, Y+29	; 0x1d
    1870:	32 a1       	ldd	r19, Z+34	; 0x22
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:281
  adc_P >>= 4;

  var1 = ((int64_t)t_fine) - 128000;
  var2 = var1 * var1 * (int64_t)_bmp280_calib.dig_P6;
  var2 = var2 + ((var1 * (int64_t)_bmp280_calib.dig_P5) << 17);
  var2 = var2 + (((int64_t)_bmp280_calib.dig_P4) << 35);
    1872:	21 a1       	ldd	r18, Z+33	; 0x21
    1874:	93 2f       	mov	r25, r19
    1876:	99 0f       	add	r25, r25
    1878:	99 0b       	sbc	r25, r25
    187a:	49 2f       	mov	r20, r25
    187c:	59 2f       	mov	r21, r25
    187e:	69 2f       	mov	r22, r25
    1880:	79 2f       	mov	r23, r25
    1882:	89 2f       	mov	r24, r25
    1884:	03 e2       	ldi	r16, 0x23	; 35
    1886:	0e 94 2d 18 	call	0x305a	; 0x305a <__ashldi3>
    188a:	02 2d       	mov	r16, r2
    188c:	0e 94 63 18 	call	0x30c6	; 0x30c6 <__adddi3>
    1890:	59 01       	movw	r10, r18
    1892:	6a 01       	movw	r12, r20
    1894:	7b 01       	movw	r14, r22
    1896:	8c 01       	movw	r16, r24
    1898:	27 2d       	mov	r18, r7
    189a:	38 2d       	mov	r19, r8
    189c:	49 2d       	mov	r20, r9
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:291

  if (var1 == 0) {
    return 0; // avoid exception caused by division by zero
  }
  p = 1048576 - adc_P;
  p = (((p << 31) - var2) * 3125) / var1;
    189e:	56 2d       	mov	r21, r6
    18a0:	6b 2f       	mov	r22, r27
    18a2:	7a 2f       	mov	r23, r26
    18a4:	83 2d       	mov	r24, r3
    18a6:	99 85       	ldd	r25, Y+9	; 0x09
    18a8:	0e 94 6c 18 	call	0x30d8	; 0x30d8 <__subdi3>
    18ac:	e5 e3       	ldi	r30, 0x35	; 53
    18ae:	ae 2e       	mov	r10, r30
    18b0:	fc e0       	ldi	r31, 0x0C	; 12
    18b2:	bf 2e       	mov	r11, r31
    18b4:	c1 2c       	mov	r12, r1
    18b6:	d1 2c       	mov	r13, r1
    18b8:	e1 2c       	mov	r14, r1
    18ba:	f1 2c       	mov	r15, r1
    18bc:	00 e0       	ldi	r16, 0x00	; 0
    18be:	10 e0       	ldi	r17, 0x00	; 0
    18c0:	0e 94 44 17 	call	0x2e88	; 0x2e88 <__muldi3>
    18c4:	a9 80       	ldd	r10, Y+1	; 0x01
    18c6:	b5 2c       	mov	r11, r5
    18c8:	cd 84       	ldd	r12, Y+13	; 0x0d
    18ca:	de 84       	ldd	r13, Y+14	; 0x0e
    18cc:	ef 84       	ldd	r14, Y+15	; 0x0f
    18ce:	f8 88       	ldd	r15, Y+16	; 0x10
    18d0:	09 89       	ldd	r16, Y+17	; 0x11
    18d2:	14 2d       	mov	r17, r4
    18d4:	0e 94 96 17 	call	0x2f2c	; 0x2f2c <__divdi3>
    18d8:	29 87       	std	Y+9, r18	; 0x09
    18da:	3a 87       	std	Y+10, r19	; 0x0a
    18dc:	4b 87       	std	Y+11, r20	; 0x0b
    18de:	5c 87       	std	Y+12, r21	; 0x0c
    18e0:	69 83       	std	Y+1, r22	; 0x01
    18e2:	7d 87       	std	Y+13, r23	; 0x0d
    18e4:	8e 87       	std	Y+14, r24	; 0x0e
    18e6:	9f 87       	std	Y+15, r25	; 0x0f
    18e8:	0d e0       	ldi	r16, 0x0D	; 13
    18ea:	0e 94 46 18 	call	0x308c	; 0x308c <__ashrdi3>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:292
  var1 = (((int64_t)_bmp280_calib.dig_P9) * (p >> 13) * (p >> 13)) >> 25;
    18ee:	92 2e       	mov	r9, r18
    18f0:	83 2e       	mov	r8, r19
    18f2:	74 2e       	mov	r7, r20
    18f4:	65 2e       	mov	r6, r21
    18f6:	56 2e       	mov	r5, r22
    18f8:	47 2e       	mov	r4, r23
    18fa:	38 2e       	mov	r3, r24
    18fc:	29 2e       	mov	r2, r25
    18fe:	ac 8d       	ldd	r26, Y+28	; 0x1c
    1900:	bd 8d       	ldd	r27, Y+29	; 0x1d
    1902:	9c 96       	adiw	r26, 0x2c	; 44
    1904:	3c 91       	ld	r19, X
    1906:	9c 97       	sbiw	r26, 0x2c	; 44
    1908:	9b 96       	adiw	r26, 0x2b	; 43
    190a:	2c 91       	ld	r18, X
    190c:	93 2f       	mov	r25, r19
    190e:	99 0f       	add	r25, r25
    1910:	99 0b       	sbc	r25, r25
    1912:	a9 2c       	mov	r10, r9
    1914:	b8 2c       	mov	r11, r8
    1916:	c7 2c       	mov	r12, r7
    1918:	d6 2c       	mov	r13, r6
    191a:	e5 2c       	mov	r14, r5
    191c:	f4 2c       	mov	r15, r4
    191e:	03 2d       	mov	r16, r3
    1920:	12 2d       	mov	r17, r2
    1922:	49 2f       	mov	r20, r25
    1924:	59 2f       	mov	r21, r25
    1926:	69 2f       	mov	r22, r25
    1928:	79 2f       	mov	r23, r25
    192a:	89 2f       	mov	r24, r25
    192c:	0e 94 44 17 	call	0x2e88	; 0x2e88 <__muldi3>
    1930:	0e 94 44 17 	call	0x2e88	; 0x2e88 <__muldi3>
    1934:	09 e1       	ldi	r16, 0x19	; 25
    1936:	0e 94 46 18 	call	0x308c	; 0x308c <__ashrdi3>
    193a:	a9 84       	ldd	r10, Y+9	; 0x09
    193c:	ba 84       	ldd	r11, Y+10	; 0x0a
    193e:	cb 84       	ldd	r12, Y+11	; 0x0b
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:295
  var2 = (((int64_t)_bmp280_calib.dig_P8) * p) >> 19;

  p = ((p + var1 + var2) >> 8) + (((int64_t)_bmp280_calib.dig_P7) << 4);
    1940:	dc 84       	ldd	r13, Y+12	; 0x0c
    1942:	e9 80       	ldd	r14, Y+1	; 0x01
    1944:	fd 84       	ldd	r15, Y+13	; 0x0d
    1946:	0e 85       	ldd	r16, Y+14	; 0x0e
    1948:	1f 85       	ldd	r17, Y+15	; 0x0f
    194a:	0e 94 63 18 	call	0x30c6	; 0x30c6 <__adddi3>
    194e:	19 01       	movw	r2, r18
    1950:	2a 01       	movw	r4, r20
    1952:	3b 01       	movw	r6, r22
    1954:	4c 01       	movw	r8, r24
    1956:	ec 8d       	ldd	r30, Y+28	; 0x1c
    1958:	fd 8d       	ldd	r31, Y+29	; 0x1d
    195a:	32 a5       	ldd	r19, Z+42	; 0x2a
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:293
    return 0; // avoid exception caused by division by zero
  }
  p = 1048576 - adc_P;
  p = (((p << 31) - var2) * 3125) / var1;
  var1 = (((int64_t)_bmp280_calib.dig_P9) * (p >> 13) * (p >> 13)) >> 25;
  var2 = (((int64_t)_bmp280_calib.dig_P8) * p) >> 19;
    195c:	21 a5       	ldd	r18, Z+41	; 0x29
    195e:	93 2f       	mov	r25, r19
    1960:	99 0f       	add	r25, r25
    1962:	99 0b       	sbc	r25, r25
    1964:	49 2f       	mov	r20, r25
    1966:	59 2f       	mov	r21, r25
    1968:	69 2f       	mov	r22, r25
    196a:	79 2f       	mov	r23, r25
    196c:	89 2f       	mov	r24, r25
    196e:	0e 94 44 17 	call	0x2e88	; 0x2e88 <__muldi3>
    1972:	03 e1       	ldi	r16, 0x13	; 19
    1974:	0e 94 46 18 	call	0x308c	; 0x308c <__ashrdi3>
    1978:	59 01       	movw	r10, r18
    197a:	6a 01       	movw	r12, r20
    197c:	7b 01       	movw	r14, r22
    197e:	8c 01       	movw	r16, r24
    1980:	91 01       	movw	r18, r2
    1982:	a2 01       	movw	r20, r4
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:295

  p = ((p + var1 + var2) >> 8) + (((int64_t)_bmp280_calib.dig_P7) << 4);
    1984:	b3 01       	movw	r22, r6
    1986:	c4 01       	movw	r24, r8
    1988:	0e 94 63 18 	call	0x30c6	; 0x30c6 <__adddi3>
    198c:	08 e0       	ldi	r16, 0x08	; 8
    198e:	0e 94 46 18 	call	0x308c	; 0x308c <__ashrdi3>
    1992:	59 01       	movw	r10, r18
    1994:	6a 01       	movw	r12, r20
    1996:	7b 01       	movw	r14, r22
    1998:	e8 2f       	mov	r30, r24
    199a:	19 2f       	mov	r17, r25
    199c:	ac 8d       	ldd	r26, Y+28	; 0x1c
    199e:	bd 8d       	ldd	r27, Y+29	; 0x1d
    19a0:	98 96       	adiw	r26, 0x28	; 40
    19a2:	3c 91       	ld	r19, X
    19a4:	98 97       	sbiw	r26, 0x28	; 40
    19a6:	97 96       	adiw	r26, 0x27	; 39
    19a8:	2c 91       	ld	r18, X
    19aa:	93 2f       	mov	r25, r19
    19ac:	99 0f       	add	r25, r25
    19ae:	99 0b       	sbc	r25, r25
    19b0:	49 2f       	mov	r20, r25
    19b2:	59 2f       	mov	r21, r25
    19b4:	69 2f       	mov	r22, r25
    19b6:	79 2f       	mov	r23, r25
    19b8:	89 2f       	mov	r24, r25
    19ba:	04 e0       	ldi	r16, 0x04	; 4
    19bc:	0e 94 2d 18 	call	0x305a	; 0x305a <__ashldi3>
    19c0:	0e 2f       	mov	r16, r30
    19c2:	0e 94 63 18 	call	0x30c6	; 0x30c6 <__adddi3>
    19c6:	4b d7       	rcall	.+3734   	; 0x285e <__floatdisf>
    19c8:	20 e0       	ldi	r18, 0x00	; 0
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:296
  return (float)p / 256;
    19ca:	30 e0       	ldi	r19, 0x00	; 0
    19cc:	40 e8       	ldi	r20, 0x80	; 128
    19ce:	5b e3       	ldi	r21, 0x3B	; 59
    19d0:	0e 94 37 15 	call	0x2a6e	; 0x2a6e <__mulsf3>
    19d4:	6d 96       	adiw	r28, 0x1d	; 29
    19d6:	cd bf       	out	0x3d, r28	; 61
    19d8:	de bf       	out	0x3e, r29	; 62
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:297
}
    19da:	df 91       	pop	r29
    19dc:	cf 91       	pop	r28
    19de:	1f 91       	pop	r17
    19e0:	0f 91       	pop	r16
    19e2:	ff 90       	pop	r15
    19e4:	ef 90       	pop	r14
    19e6:	df 90       	pop	r13
    19e8:	cf 90       	pop	r12
    19ea:	bf 90       	pop	r11
    19ec:	af 90       	pop	r10
    19ee:	9f 90       	pop	r9
    19f0:	8f 90       	pop	r8
    19f2:	7f 90       	pop	r7
    19f4:	6f 90       	pop	r6
    19f6:	5f 90       	pop	r5
    19f8:	4f 90       	pop	r4
    19fa:	3f 90       	pop	r3
    19fc:	2f 90       	pop	r2
    19fe:	08 95       	ret
    1a00:	60 e0       	ldi	r22, 0x00	; 0
    1a02:	70 e0       	ldi	r23, 0x00	; 0
    1a04:	cb 01       	movw	r24, r22
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:288
         ((var1 * (int64_t)_bmp280_calib.dig_P2) << 12);
  var1 =
      (((((int64_t)1) << 47) + var1)) * ((int64_t)_bmp280_calib.dig_P1) >> 33;

  if (var1 == 0) {
    return 0; // avoid exception caused by division by zero
    1a06:	e6 cf       	rjmp	.-52     	; 0x19d4 <Adafruit_BMP280::readPressure()+0x3be>

00001a08 <Adafruit_BMP280_Temp::~Adafruit_BMP280_Temp()>:
_ZN20Adafruit_BMP280_TempD0Ev():
    1a08:	0c 94 32 19 	jmp	0x3264	; 0x3264 <free>

00001a0c <Adafruit_BMP280_Pressure::~Adafruit_BMP280_Pressure()>:
_ZN24Adafruit_BMP280_PressureD0Ev():
    1a0c:	0c 94 32 19 	jmp	0x3264	; 0x3264 <free>

00001a10 <Adafruit_BMP280_Pressure::getEvent(sensors_event_t*)>:
_ZN24Adafruit_BMP280_Pressure8getEventEP15sensors_event_t():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/new.cpp:63
// Since C++14, also need two more delete variants...
// Note thnat this CAN break code that compiled amd worked in C++11.
#if (__cpp_sized_deallocation >= 201309L)
  void  operator delete  (void* ptr, size_t size) noexcept {
    (void) size;
    free(ptr);
    1a10:	cf 93       	push	r28
    1a12:	df 93       	push	r29
    1a14:	eb 01       	movw	r28, r22
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:477
    @brief  Gets the pressure as a standard sensor event
    @param  event Sensor event object that will be populated
    @returns True
*/
/**************************************************************************/
bool Adafruit_BMP280_Pressure::getEvent(sensors_event_t *event) {
    1a16:	fb 01       	movw	r30, r22
    1a18:	34 96       	adiw	r30, 0x04	; 4
    1a1a:	20 e2       	ldi	r18, 0x20	; 32
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:479
  /* Clear the event */
  memset(event, 0, sizeof(sensors_event_t));
    1a1c:	df 01       	movw	r26, r30
    1a1e:	1d 92       	st	X+, r1
    1a20:	2a 95       	dec	r18
    1a22:	e9 f7       	brne	.-6      	; 0x1a1e <Adafruit_BMP280_Pressure::getEvent(sensors_event_t*)+0xe>
    1a24:	44 e2       	ldi	r20, 0x24	; 36
    1a26:	50 e0       	ldi	r21, 0x00	; 0
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:481

  event->version = sizeof(sensors_event_t);
    1a28:	60 e0       	ldi	r22, 0x00	; 0
    1a2a:	70 e0       	ldi	r23, 0x00	; 0
    1a2c:	48 83       	st	Y, r20
    1a2e:	59 83       	std	Y+1, r21	; 0x01
    1a30:	6a 83       	std	Y+2, r22	; 0x02
    1a32:	7b 83       	std	Y+3, r23	; 0x03
    1a34:	fc 01       	movw	r30, r24
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:482
  event->sensor_id = _sensorID;
    1a36:	43 81       	ldd	r20, Z+3	; 0x03
    1a38:	54 81       	ldd	r21, Z+4	; 0x04
    1a3a:	05 2e       	mov	r0, r21
    1a3c:	00 0c       	add	r0, r0
    1a3e:	66 0b       	sbc	r22, r22
    1a40:	77 0b       	sbc	r23, r23
    1a42:	4c 83       	std	Y+4, r20	; 0x04
    1a44:	5d 83       	std	Y+5, r21	; 0x05
    1a46:	6e 83       	std	Y+6, r22	; 0x06
    1a48:	7f 83       	std	Y+7, r23	; 0x07
    1a4a:	46 e0       	ldi	r20, 0x06	; 6
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:483
  event->type = SENSOR_TYPE_PRESSURE;
    1a4c:	50 e0       	ldi	r21, 0x00	; 0
    1a4e:	60 e0       	ldi	r22, 0x00	; 0
    1a50:	70 e0       	ldi	r23, 0x00	; 0
    1a52:	48 87       	std	Y+8, r20	; 0x08
    1a54:	59 87       	std	Y+9, r21	; 0x09
    1a56:	6a 87       	std	Y+10, r22	; 0x0a
    1a58:	7b 87       	std	Y+11, r23	; 0x0b
millis():
    1a5a:	2f b7       	in	r18, 0x3f	; 63
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:226


unsigned long millis() {
  // return timer_overflow_count; // for debugging timekeeping issues where these variables are out of scope from the sketch
  unsigned long m;
  uint8_t oldSREG = SREG;
    1a5c:	f8 94       	cli
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:227
  cli();
    1a5e:	40 91 06 38 	lds	r20, 0x3806	; 0x803806 <__data_end>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:255

     * Not only that - but a dedicated optimizing assembly programmer could probably ensure that instead of the >> 7 (a little mini loop)
     * that was implemented leftshifting it once, retaining the carried bit, and
     */
  #else
    m = timer_millis;
    1a62:	50 91 07 38 	lds	r21, 0x3807	; 0x803807 <__data_end+0x1>
    1a66:	60 91 08 38 	lds	r22, 0x3808	; 0x803808 <__data_end+0x2>
    1a6a:	70 91 09 38 	lds	r23, 0x3809	; 0x803809 <__data_end+0x3>
    1a6e:	2f bf       	out	0x3f, r18	; 63
_ZN24Adafruit_BMP280_Pressure8getEventEP15sensors_event_t():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:256
    SREG = oldSREG;
    1a70:	48 8b       	std	Y+16, r20	; 0x10
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:484
  event->timestamp = millis();
    1a72:	59 8b       	std	Y+17, r21	; 0x11
    1a74:	6a 8b       	std	Y+18, r22	; 0x12
    1a76:	7b 8b       	std	Y+19, r23	; 0x13
    1a78:	85 81       	ldd	r24, Z+5	; 0x05
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:485
  event->pressure = _theBMP280->readPressure() / 100; // convert Pa to hPa
    1a7a:	96 81       	ldd	r25, Z+6	; 0x06
    1a7c:	cc dd       	rcall	.-1128   	; 0x1616 <Adafruit_BMP280::readPressure()>
    1a7e:	20 e0       	ldi	r18, 0x00	; 0
    1a80:	30 e0       	ldi	r19, 0x00	; 0
    1a82:	48 ec       	ldi	r20, 0xC8	; 200
    1a84:	52 e4       	ldi	r21, 0x42	; 66
    1a86:	57 d6       	rcall	.+3246   	; 0x2736 <__divsf3>
    1a88:	6c 8b       	std	Y+20, r22	; 0x14
    1a8a:	7d 8b       	std	Y+21, r23	; 0x15
    1a8c:	8e 8b       	std	Y+22, r24	; 0x16
    1a8e:	9f 8b       	std	Y+23, r25	; 0x17
    1a90:	81 e0       	ldi	r24, 0x01	; 1
    1a92:	df 91       	pop	r29
    1a94:	cf 91       	pop	r28
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:487
  return true;
}
    1a96:	08 95       	ret

00001a98 <Adafruit_BMP280_Temp::getEvent(sensors_event_t*)>:
_ZN20Adafruit_BMP280_Temp8getEventEP15sensors_event_t():
    1a98:	cf 93       	push	r28
    1a9a:	df 93       	push	r29
    1a9c:	eb 01       	movw	r28, r22
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:437
    @brief  Gets the temperature as a standard sensor event
    @param  event Sensor event object that will be populated
    @returns True
*/
/**************************************************************************/
bool Adafruit_BMP280_Temp::getEvent(sensors_event_t *event) {
    1a9e:	fb 01       	movw	r30, r22
    1aa0:	34 96       	adiw	r30, 0x04	; 4
    1aa2:	20 e2       	ldi	r18, 0x20	; 32
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:439
  /* Clear the event */
  memset(event, 0, sizeof(sensors_event_t));
    1aa4:	df 01       	movw	r26, r30
    1aa6:	1d 92       	st	X+, r1
    1aa8:	2a 95       	dec	r18
    1aaa:	e9 f7       	brne	.-6      	; 0x1aa6 <Adafruit_BMP280_Temp::getEvent(sensors_event_t*)+0xe>
    1aac:	44 e2       	ldi	r20, 0x24	; 36
    1aae:	50 e0       	ldi	r21, 0x00	; 0
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:441

  event->version = sizeof(sensors_event_t);
    1ab0:	60 e0       	ldi	r22, 0x00	; 0
    1ab2:	70 e0       	ldi	r23, 0x00	; 0
    1ab4:	48 83       	st	Y, r20
    1ab6:	59 83       	std	Y+1, r21	; 0x01
    1ab8:	6a 83       	std	Y+2, r22	; 0x02
    1aba:	7b 83       	std	Y+3, r23	; 0x03
    1abc:	fc 01       	movw	r30, r24
    1abe:	43 81       	ldd	r20, Z+3	; 0x03
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:442
  event->sensor_id = _sensorID;
    1ac0:	54 81       	ldd	r21, Z+4	; 0x04
    1ac2:	05 2e       	mov	r0, r21
    1ac4:	00 0c       	add	r0, r0
    1ac6:	66 0b       	sbc	r22, r22
    1ac8:	77 0b       	sbc	r23, r23
    1aca:	4c 83       	std	Y+4, r20	; 0x04
    1acc:	5d 83       	std	Y+5, r21	; 0x05
    1ace:	6e 83       	std	Y+6, r22	; 0x06
    1ad0:	7f 83       	std	Y+7, r23	; 0x07
    1ad2:	4d e0       	ldi	r20, 0x0D	; 13
    1ad4:	50 e0       	ldi	r21, 0x00	; 0
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:443
  event->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
    1ad6:	60 e0       	ldi	r22, 0x00	; 0
    1ad8:	70 e0       	ldi	r23, 0x00	; 0
    1ada:	48 87       	std	Y+8, r20	; 0x08
    1adc:	59 87       	std	Y+9, r21	; 0x09
    1ade:	6a 87       	std	Y+10, r22	; 0x0a
    1ae0:	7b 87       	std	Y+11, r23	; 0x0b
millis():
    1ae2:	2f b7       	in	r18, 0x3f	; 63
    1ae4:	f8 94       	cli
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:226


unsigned long millis() {
  // return timer_overflow_count; // for debugging timekeeping issues where these variables are out of scope from the sketch
  unsigned long m;
  uint8_t oldSREG = SREG;
    1ae6:	40 91 06 38 	lds	r20, 0x3806	; 0x803806 <__data_end>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:255

     * Not only that - but a dedicated optimizing assembly programmer could probably ensure that instead of the >> 7 (a little mini loop)
     * that was implemented leftshifting it once, retaining the carried bit, and
     */
  #else
    m = timer_millis;
    1aea:	50 91 07 38 	lds	r21, 0x3807	; 0x803807 <__data_end+0x1>
    1aee:	60 91 08 38 	lds	r22, 0x3808	; 0x803808 <__data_end+0x2>
    1af2:	70 91 09 38 	lds	r23, 0x3809	; 0x803809 <__data_end+0x3>
    1af6:	2f bf       	out	0x3f, r18	; 63
_ZN20Adafruit_BMP280_Temp8getEventEP15sensors_event_t():
    1af8:	48 8b       	std	Y+16, r20	; 0x10
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:256
    SREG = oldSREG;
    1afa:	59 8b       	std	Y+17, r21	; 0x11
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:444
  event->timestamp = millis();
    1afc:	6a 8b       	std	Y+18, r22	; 0x12
    1afe:	7b 8b       	std	Y+19, r23	; 0x13
    1b00:	85 81       	ldd	r24, Z+5	; 0x05
    1b02:	96 81       	ldd	r25, Z+6	; 0x06
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:445
  event->temperature = _theBMP280->readTemperature();
    1b04:	04 dd       	rcall	.-1528   	; 0x150e <Adafruit_BMP280::readTemperature()>
    1b06:	6c 8b       	std	Y+20, r22	; 0x14
    1b08:	7d 8b       	std	Y+21, r23	; 0x15
    1b0a:	8e 8b       	std	Y+22, r24	; 0x16
    1b0c:	9f 8b       	std	Y+23, r25	; 0x17
    1b0e:	81 e0       	ldi	r24, 0x01	; 1
    1b10:	df 91       	pop	r29
    1b12:	cf 91       	pop	r28
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:447
  return true;
}
    1b14:	08 95       	ret

00001b16 <Adafruit_BMP280_Pressure::getSensor(sensor_t*)>:
_ZN24Adafruit_BMP280_Pressure9getSensorEP8sensor_t():
    1b16:	0f 93       	push	r16
    1b18:	1f 93       	push	r17
    1b1a:	cf 93       	push	r28
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:454
/**************************************************************************/
/*!
    @brief  Gets the sensor_t data for the BMP280's pressure sensor
*/
/**************************************************************************/
void Adafruit_BMP280_Pressure::getSensor(sensor_t *sensor) {
    1b1c:	df 93       	push	r29
    1b1e:	8c 01       	movw	r16, r24
    1b20:	eb 01       	movw	r28, r22
    1b22:	88 e2       	ldi	r24, 0x28	; 40
    1b24:	fb 01       	movw	r30, r22
    1b26:	11 92       	st	Z+, r1
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:456
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));
    1b28:	8a 95       	dec	r24
    1b2a:	e9 f7       	brne	.-6      	; 0x1b26 <Adafruit_BMP280_Pressure::getSensor(sensor_t*)+0x10>
    1b2c:	4b e0       	ldi	r20, 0x0B	; 11
    1b2e:	50 e0       	ldi	r21, 0x00	; 0
    1b30:	6d e3       	ldi	r22, 0x3D	; 61
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:459

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "BMP280", sizeof(sensor->name) - 1);
    1b32:	74 eb       	ldi	r23, 0xB4	; 180
    1b34:	ce 01       	movw	r24, r28
    1b36:	0e 94 bb 19 	call	0x3376	; 0x3376 <strncpy>
    1b3a:	1b 86       	std	Y+11, r1	; 0x0b
    1b3c:	81 e0       	ldi	r24, 0x01	; 1
    1b3e:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:460
  sensor->name[sizeof(sensor->name) - 1] = 0;
    1b40:	a0 e0       	ldi	r26, 0x00	; 0
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:461
  sensor->version = 1;
    1b42:	b0 e0       	ldi	r27, 0x00	; 0
    1b44:	8c 87       	std	Y+12, r24	; 0x0c
    1b46:	9d 87       	std	Y+13, r25	; 0x0d
    1b48:	ae 87       	std	Y+14, r26	; 0x0e
    1b4a:	bf 87       	std	Y+15, r27	; 0x0f
    1b4c:	f8 01       	movw	r30, r16
    1b4e:	83 81       	ldd	r24, Z+3	; 0x03
    1b50:	94 81       	ldd	r25, Z+4	; 0x04
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:462
  sensor->sensor_id = _sensorID;
    1b52:	09 2e       	mov	r0, r25
    1b54:	00 0c       	add	r0, r0
    1b56:	aa 0b       	sbc	r26, r26
    1b58:	bb 0b       	sbc	r27, r27
    1b5a:	88 8b       	std	Y+16, r24	; 0x10
    1b5c:	99 8b       	std	Y+17, r25	; 0x11
    1b5e:	aa 8b       	std	Y+18, r26	; 0x12
    1b60:	bb 8b       	std	Y+19, r27	; 0x13
    1b62:	86 e0       	ldi	r24, 0x06	; 6
    1b64:	90 e0       	ldi	r25, 0x00	; 0
    1b66:	a0 e0       	ldi	r26, 0x00	; 0
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:463
  sensor->type = SENSOR_TYPE_PRESSURE;
    1b68:	b0 e0       	ldi	r27, 0x00	; 0
    1b6a:	8c 8b       	std	Y+20, r24	; 0x14
    1b6c:	9d 8b       	std	Y+21, r25	; 0x15
    1b6e:	ae 8b       	std	Y+22, r26	; 0x16
    1b70:	bf 8b       	std	Y+23, r27	; 0x17
    1b72:	1c a2       	std	Y+36, r1	; 0x24
    1b74:	1d a2       	std	Y+37, r1	; 0x25
    1b76:	1e a2       	std	Y+38, r1	; 0x26
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:464
  sensor->min_delay = 0;
    1b78:	1f a2       	std	Y+39, r1	; 0x27
    1b7a:	80 e0       	ldi	r24, 0x00	; 0
    1b7c:	90 e0       	ldi	r25, 0x00	; 0
    1b7e:	a6 e9       	ldi	r26, 0x96	; 150
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:465
  sensor->min_value = 300.0; /* 300 ~ 1100 hPa  */
    1b80:	b3 e4       	ldi	r27, 0x43	; 67
    1b82:	8c 8f       	std	Y+28, r24	; 0x1c
    1b84:	9d 8f       	std	Y+29, r25	; 0x1d
    1b86:	ae 8f       	std	Y+30, r26	; 0x1e
    1b88:	bf 8f       	std	Y+31, r27	; 0x1f
    1b8a:	80 e0       	ldi	r24, 0x00	; 0
    1b8c:	90 e8       	ldi	r25, 0x80	; 128
    1b8e:	a9 e8       	ldi	r26, 0x89	; 137
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:466
  sensor->max_value = 1100.0;
    1b90:	b4 e4       	ldi	r27, 0x44	; 68
    1b92:	88 8f       	std	Y+24, r24	; 0x18
    1b94:	99 8f       	std	Y+25, r25	; 0x19
    1b96:	aa 8f       	std	Y+26, r26	; 0x1a
    1b98:	bb 8f       	std	Y+27, r27	; 0x1b
    1b9a:	86 ea       	ldi	r24, 0xA6	; 166
    1b9c:	9b e9       	ldi	r25, 0x9B	; 155
    1b9e:	a4 e4       	ldi	r26, 0x44	; 68
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:467
  sensor->resolution = 0.012; /* 0.12 hPa relative */
    1ba0:	bc e3       	ldi	r27, 0x3C	; 60
    1ba2:	88 a3       	std	Y+32, r24	; 0x20
    1ba4:	99 a3       	std	Y+33, r25	; 0x21
    1ba6:	aa a3       	std	Y+34, r26	; 0x22
    1ba8:	bb a3       	std	Y+35, r27	; 0x23
    1baa:	df 91       	pop	r29
    1bac:	cf 91       	pop	r28
    1bae:	1f 91       	pop	r17
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:468
}
    1bb0:	0f 91       	pop	r16
    1bb2:	08 95       	ret

00001bb4 <Adafruit_BMP280_Temp::getSensor(sensor_t*)>:
_ZN20Adafruit_BMP280_Temp9getSensorEP8sensor_t():
    1bb4:	0f 93       	push	r16
    1bb6:	1f 93       	push	r17
    1bb8:	cf 93       	push	r28
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:414
/**************************************************************************/
/*!
    @brief  Gets the sensor_t data for the BMP280's temperature sensor
*/
/**************************************************************************/
void Adafruit_BMP280_Temp::getSensor(sensor_t *sensor) {
    1bba:	df 93       	push	r29
    1bbc:	8c 01       	movw	r16, r24
    1bbe:	eb 01       	movw	r28, r22
    1bc0:	88 e2       	ldi	r24, 0x28	; 40
    1bc2:	fb 01       	movw	r30, r22
    1bc4:	11 92       	st	Z+, r1
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:416
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));
    1bc6:	8a 95       	dec	r24
    1bc8:	e9 f7       	brne	.-6      	; 0x1bc4 <Adafruit_BMP280_Temp::getSensor(sensor_t*)+0x10>
    1bca:	4b e0       	ldi	r20, 0x0B	; 11
    1bcc:	50 e0       	ldi	r21, 0x00	; 0
    1bce:	6d e3       	ldi	r22, 0x3D	; 61
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:419

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "BMP280", sizeof(sensor->name) - 1);
    1bd0:	74 eb       	ldi	r23, 0xB4	; 180
    1bd2:	ce 01       	movw	r24, r28
    1bd4:	0e 94 bb 19 	call	0x3376	; 0x3376 <strncpy>
    1bd8:	1b 86       	std	Y+11, r1	; 0x0b
    1bda:	81 e0       	ldi	r24, 0x01	; 1
    1bdc:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:420
  sensor->name[sizeof(sensor->name) - 1] = 0;
    1bde:	a0 e0       	ldi	r26, 0x00	; 0
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:421
  sensor->version = 1;
    1be0:	b0 e0       	ldi	r27, 0x00	; 0
    1be2:	8c 87       	std	Y+12, r24	; 0x0c
    1be4:	9d 87       	std	Y+13, r25	; 0x0d
    1be6:	ae 87       	std	Y+14, r26	; 0x0e
    1be8:	bf 87       	std	Y+15, r27	; 0x0f
    1bea:	f8 01       	movw	r30, r16
    1bec:	83 81       	ldd	r24, Z+3	; 0x03
    1bee:	94 81       	ldd	r25, Z+4	; 0x04
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:422
  sensor->sensor_id = _sensorID;
    1bf0:	09 2e       	mov	r0, r25
    1bf2:	00 0c       	add	r0, r0
    1bf4:	aa 0b       	sbc	r26, r26
    1bf6:	bb 0b       	sbc	r27, r27
    1bf8:	88 8b       	std	Y+16, r24	; 0x10
    1bfa:	99 8b       	std	Y+17, r25	; 0x11
    1bfc:	aa 8b       	std	Y+18, r26	; 0x12
    1bfe:	bb 8b       	std	Y+19, r27	; 0x13
    1c00:	8d e0       	ldi	r24, 0x0D	; 13
    1c02:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:423
  sensor->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
    1c04:	a0 e0       	ldi	r26, 0x00	; 0
    1c06:	b0 e0       	ldi	r27, 0x00	; 0
    1c08:	8c 8b       	std	Y+20, r24	; 0x14
    1c0a:	9d 8b       	std	Y+21, r25	; 0x15
    1c0c:	ae 8b       	std	Y+22, r26	; 0x16
    1c0e:	bf 8b       	std	Y+23, r27	; 0x17
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:424
  sensor->min_delay = 0;
    1c10:	1c a2       	std	Y+36, r1	; 0x24
    1c12:	1d a2       	std	Y+37, r1	; 0x25
    1c14:	1e a2       	std	Y+38, r1	; 0x26
    1c16:	1f a2       	std	Y+39, r1	; 0x27
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:425
  sensor->min_value = -40.0; /* Temperature range -40 ~ +85 C  */
    1c18:	80 e0       	ldi	r24, 0x00	; 0
    1c1a:	90 e0       	ldi	r25, 0x00	; 0
    1c1c:	a0 e2       	ldi	r26, 0x20	; 32
    1c1e:	b2 ec       	ldi	r27, 0xC2	; 194
    1c20:	8c 8f       	std	Y+28, r24	; 0x1c
    1c22:	9d 8f       	std	Y+29, r25	; 0x1d
    1c24:	ae 8f       	std	Y+30, r26	; 0x1e
    1c26:	bf 8f       	std	Y+31, r27	; 0x1f
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:426
  sensor->max_value = +85.0;
    1c28:	80 e0       	ldi	r24, 0x00	; 0
    1c2a:	90 e0       	ldi	r25, 0x00	; 0
    1c2c:	aa ea       	ldi	r26, 0xAA	; 170
    1c2e:	b2 e4       	ldi	r27, 0x42	; 66
    1c30:	88 8f       	std	Y+24, r24	; 0x18
    1c32:	99 8f       	std	Y+25, r25	; 0x19
    1c34:	aa 8f       	std	Y+26, r26	; 0x1a
    1c36:	bb 8f       	std	Y+27, r27	; 0x1b
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:427
  sensor->resolution = 0.01; /*  0.01 C */
    1c38:	8a e0       	ldi	r24, 0x0A	; 10
    1c3a:	97 ed       	ldi	r25, 0xD7	; 215
    1c3c:	a3 e2       	ldi	r26, 0x23	; 35
    1c3e:	bc e3       	ldi	r27, 0x3C	; 60
    1c40:	88 a3       	std	Y+32, r24	; 0x20
    1c42:	99 a3       	std	Y+33, r25	; 0x21
    1c44:	aa a3       	std	Y+34, r26	; 0x22
    1c46:	bb a3       	std	Y+35, r27	; 0x23
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:428
}
    1c48:	df 91       	pop	r29
    1c4a:	cf 91       	pop	r28
    1c4c:	1f 91       	pop	r17
    1c4e:	0f 91       	pop	r16
    1c50:	08 95       	ret

00001c52 <__vector_18>:
__vector_18():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART0.cpp:73
  #else
    ISR(USART0_DRE_vect, ISR_NAKED) {
      __asm__ __volatile__(
                "push  r30"    "\n\t"
                "push  r31"    "\n\t"
                :::);
    1c52:	ef 93       	push	r30
    1c54:	ff 93       	push	r31
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART0.cpp:76
      __asm__ __volatile__(
                "jmp _do_dre"  "\n"
                ::"z"(&Serial));
    1c56:	ea e1       	ldi	r30, 0x1A	; 26
    1c58:	f8 e3       	ldi	r31, 0x38	; 56
    1c5a:	08 c0       	rjmp	.+16     	; 0x1c6c <_do_dre()>

00001c5c <__vector_17>:
__vector_17():
    1c5c:	ef 93       	push	r30
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART0.cpp:55
  #else
    ISR(USART0_RXC_vect, ISR_NAKED) {
      __asm__ __volatile__(
            "push      r30"     "\n\t"
            "push      r31"     "\n\t"
            :::);
    1c5e:	ff 93       	push	r31
    1c60:	ea e1       	ldi	r30, 0x1A	; 26
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART0.cpp:58
      __asm__ __volatile__(
            "jmp   _do_rxc"     "\n\t"
            ::"z"(&Serial));
    1c62:	f8 e3       	ldi	r31, 0x38	; 56
    1c64:	32 c0       	rjmp	.+100    	; 0x1cca <_do_rxc()>

00001c66 <__vector_19>:
__vector_19():
    1c66:	ef 93       	push	r30
    1c68:	e0 e0       	ldi	r30, 0x00	; 0
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART0.cpp:31
    ISR(USART0_TXC_vect, ISR_NAKED) {
      __asm__ __volatile__(
            "push  r30"         "\n\t" // push the low byte of Z
            "ldi r30, 0x00"     "\n\t" // and put the low bit of this USART there - 0x20 * n
            "jmp _do_txc"      "\n\t" // _do_txc pushes the other necessary registers and loads 0x08 into the high byte.
            :::);
    1c6a:	53 c0       	rjmp	.+166    	; 0x1d12 <_do_txc()>

00001c6c <_do_dre()>:
_Z7_do_drev():
    1c6c:	2f 93       	push	r18
    1c6e:	2f b7       	in	r18, 0x3f	; 63
    1c70:	2f 93       	push	r18
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:307
      "out        0x3f,     r18"      "\n\t"  // restore SREG
      "pop         r18"               "\n\t"  // pop old r18
      "pop         r31"               "\n\t"  // pop the Z that the isr pushed.
      "pop         r30"               "\n\t"
      "reti"                        "\n"   // and RETI!
      ::);
    1c72:	8f 93       	push	r24
    1c74:	9f 93       	push	r25
    1c76:	af 93       	push	r26
    1c78:	bf 93       	push	r27
    1c7a:	68 94       	set

00001c7c <_poll_dre>:
    1c7c:	cf 93       	push	r28
    1c7e:	df 93       	push	r29
    1c80:	20 e0       	ldi	r18, 0x00	; 0
    1c82:	c4 85       	ldd	r28, Z+12	; 0x0c
    1c84:	d8 e0       	ldi	r29, 0x08	; 8
    1c86:	94 89       	ldd	r25, Z+20	; 0x14
    1c88:	df 01       	movw	r26, r30
    1c8a:	a9 0f       	add	r26, r25
    1c8c:	b2 1f       	adc	r27, r18
    1c8e:	ab 5a       	subi	r26, 0xAB	; 171
    1c90:	bf 4f       	sbci	r27, 0xFF	; 255
    1c92:	8c 91       	ld	r24, X
    1c94:	20 e4       	ldi	r18, 0x40	; 64
    1c96:	2c 83       	std	Y+4, r18	; 0x04
    1c98:	8a 83       	std	Y+2, r24	; 0x02
    1c9a:	9f 5f       	subi	r25, 0xFF	; 255
    1c9c:	9f 73       	andi	r25, 0x3F	; 63
    1c9e:	8d 81       	ldd	r24, Y+5	; 0x05
    1ca0:	23 89       	ldd	r18, Z+19	; 0x13
    1ca2:	29 13       	cpse	r18, r25
    1ca4:	02 c0       	rjmp	.+4      	; 0x1caa <_done_dre_irq>
    1ca6:	8f 7d       	andi	r24, 0xDF	; 223
    1ca8:	8d 83       	std	Y+5, r24	; 0x05

00001caa <_done_dre_irq>:
    1caa:	94 8b       	std	Z+20, r25	; 0x14
    1cac:	df 91       	pop	r29
    1cae:	cf 91       	pop	r28
    1cb0:	16 f0       	brts	.+4      	; 0x1cb6 <_done_dre_irq+0xc>
    1cb2:	0c 94 87 01 	jmp	0x30e	; 0x30e <_poll_dre_done>
    1cb6:	bf 91       	pop	r27
    1cb8:	af 91       	pop	r26
    1cba:	9f 91       	pop	r25
    1cbc:	8f 91       	pop	r24
    1cbe:	2f 91       	pop	r18
    1cc0:	2f bf       	out	0x3f, r18	; 63
    1cc2:	2f 91       	pop	r18
    1cc4:	ff 91       	pop	r31
    1cc6:	ef 91       	pop	r30
    1cc8:	18 95       	reti

00001cca <_do_rxc()>:
_Z7_do_rxcv():
    1cca:	2f 93       	push	r18
    1ccc:	2f b7       	in	r18, 0x3f	; 63
    1cce:	2f 93       	push	r18
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:175
        "out       0x3f,       r18"   "\n\t" // and write back
        "pop        r18"              "\n\t" // used as tail pointer and z known zero.
        "pop        r31"              "\n\t" // end with Z which the isr pushed to make room for
        "pop        r30"              "\n\t" // pointer to serial instance
        "reti"                        "\n"   // return
        ::);
    1cd0:	8f 93       	push	r24
    1cd2:	9f 93       	push	r25
    1cd4:	cf 93       	push	r28
    1cd6:	df 93       	push	r29
    1cd8:	c4 85       	ldd	r28, Z+12	; 0x0c
    1cda:	d8 e0       	ldi	r29, 0x08	; 8
    1cdc:	89 81       	ldd	r24, Y+1	; 0x01
    1cde:	98 81       	ld	r25, Y
    1ce0:	81 fd       	sbrc	r24, 1
    1ce2:	0d c0       	rjmp	.+26     	; 0x1cfe <_end_rxc>
    1ce4:	c1 89       	ldd	r28, Z+17	; 0x11
    1ce6:	81 e0       	ldi	r24, 0x01	; 1
    1ce8:	8c 0f       	add	r24, r28
    1cea:	8f 73       	andi	r24, 0x3F	; 63
    1cec:	22 89       	ldd	r18, Z+18	; 0x12
    1cee:	28 17       	cp	r18, r24
    1cf0:	31 f0       	breq	.+12     	; 0x1cfe <_end_rxc>
    1cf2:	ce 0f       	add	r28, r30
    1cf4:	df 2f       	mov	r29, r31
    1cf6:	20 e0       	ldi	r18, 0x00	; 0
    1cf8:	d2 1f       	adc	r29, r18
    1cfa:	9d 8b       	std	Y+21, r25	; 0x15
    1cfc:	81 8b       	std	Z+17, r24	; 0x11

00001cfe <_end_rxc>:
    1cfe:	df 91       	pop	r29
    1d00:	cf 91       	pop	r28
    1d02:	9f 91       	pop	r25
    1d04:	8f 91       	pop	r24
    1d06:	2f 91       	pop	r18
    1d08:	2f bf       	out	0x3f, r18	; 63
    1d0a:	2f 91       	pop	r18
    1d0c:	ff 91       	pop	r31
    1d0e:	ef 91       	pop	r30
    1d10:	18 95       	reti

00001d12 <_do_txc()>:
_Z7_do_txcv():
    1d12:	ff 93       	push	r31
    1d14:	8f 93       	push	r24
    1d16:	8f b7       	in	r24, 0x3f	; 63
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/UART.cpp:105
        "out     0x3f,      r24"  "\n\t"  // restore it
        "pop      r24"            "\n\t"  // pop r24 to get it's old value back
        "pop      r31"            "\n\t"  // and r31
        "pop      r30"            "\n\t"  // Pop the register the ISR did
        "reti"                    "\n"    // return from the interrupt.
        ::);
    1d18:	8f 93       	push	r24
    1d1a:	f8 e0       	ldi	r31, 0x08	; 8

00001d1c <_txc_flush_rx>:
    1d1c:	80 81       	ld	r24, Z
    1d1e:	84 81       	ldd	r24, Z+4	; 0x04
    1d20:	87 ff       	sbrs	r24, 7
    1d22:	fc cf       	rjmp	.-8      	; 0x1d1c <_txc_flush_rx>
    1d24:	85 81       	ldd	r24, Z+5	; 0x05
    1d26:	8f 7b       	andi	r24, 0xBF	; 191
    1d28:	80 68       	ori	r24, 0x80	; 128
    1d2a:	85 83       	std	Z+5, r24	; 0x05
    1d2c:	8f 91       	pop	r24
    1d2e:	8f bf       	out	0x3f, r24	; 63
    1d30:	8f 91       	pop	r24
    1d32:	ff 91       	pop	r31
    1d34:	ef 91       	pop	r30
    1d36:	18 95       	reti

00001d38 <__vector_25>:
__vector_25():
    1d38:	1f 92       	push	r1
    1d3a:	0f 92       	push	r0
    1d3c:	0f b6       	in	r0, 0x3f	; 63
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:142
#elif defined(MILLIS_USE_TIMERB1)
  ISR(TCB1_INT_vect)
#else
  #error "No millis timer selected, but not disabled - cannot determine millis vector"
#endif
{
    1d3e:	0f 92       	push	r0
    1d40:	11 24       	eor	r1, r1
    1d42:	8f 93       	push	r24
    1d44:	9f 93       	push	r25
    1d46:	af 93       	push	r26
    1d48:	bf 93       	push	r27
    1d4a:	80 91 06 38 	lds	r24, 0x3806	; 0x803806 <__data_end>
    1d4e:	90 91 07 38 	lds	r25, 0x3807	; 0x803807 <__data_end+0x1>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:148
  // copy these to local variables so they can be stored in registers
  // (volatile variables must be read from memory on every access)

  #if (defined(MILLIS_USE_TIMERB0)|defined(MILLIS_USE_TIMERB1))
    #if (F_CPU>1000000)
      timer_millis++; // that's all we need to do!
    1d52:	a0 91 08 38 	lds	r26, 0x3808	; 0x803808 <__data_end+0x2>
    1d56:	b0 91 09 38 	lds	r27, 0x3809	; 0x803809 <__data_end+0x3>
    1d5a:	01 96       	adiw	r24, 0x01	; 1
    1d5c:	a1 1d       	adc	r26, r1
    1d5e:	b1 1d       	adc	r27, r1
    1d60:	80 93 06 38 	sts	0x3806, r24	; 0x803806 <__data_end>
    1d64:	90 93 07 38 	sts	0x3807, r25	; 0x803807 <__data_end+0x1>
    1d68:	a0 93 08 38 	sts	0x3808, r26	; 0x803808 <__data_end+0x2>
    1d6c:	b0 93 09 38 	sts	0x3809, r27	; 0x803809 <__data_end+0x3>
    1d70:	81 e0       	ldi	r24, 0x01	; 1
    1d72:	80 93 96 0a 	sts	0x0A96, r24	; 0x800a96 <vtable for Adafruit_BMP280_Temp+0x7f5678>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:177
  #elif defined(MILLIS_USE_TIMERD0)
    TCD0.INTFLAGS = TCD_OVF_bm;
  #elif defined(MILLIS_USE_TIMERRTC)
    RTC.INTFLAGS = RTC_OVF_bm;
  #else // timerb
    _timer->INTFLAGS = TCB_CAPT_bm;
    1d76:	bf 91       	pop	r27
    1d78:	af 91       	pop	r26
    1d7a:	9f 91       	pop	r25
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:179
  #endif
}
    1d7c:	8f 91       	pop	r24
    1d7e:	0f 90       	pop	r0
    1d80:	0f be       	out	0x3f, r0	; 63
    1d82:	0f 90       	pop	r0
    1d84:	1f 90       	pop	r1
    1d86:	18 95       	reti

00001d88 <__vector_14>:
__vector_14():
    1d88:	1f 92       	push	r1
    1d8a:	0f 92       	push	r0
    1d8c:	0f b6       	in	r0, 0x3f	; 63
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:776


/**
 *@brief      TWI0 Slave Interrupt vector
 */
ISR(TWI0_TWIS_vect) {
    1d8e:	0f 92       	push	r0
    1d90:	11 24       	eor	r1, r1
    1d92:	2f 93       	push	r18
    1d94:	3f 93       	push	r19
    1d96:	4f 93       	push	r20
    1d98:	5f 93       	push	r21
    1d9a:	6f 93       	push	r22
    1d9c:	7f 93       	push	r23
    1d9e:	8f 93       	push	r24
    1da0:	9f 93       	push	r25
    1da2:	af 93       	push	r26
    1da4:	bf 93       	push	r27
    1da6:	ef 93       	push	r30
    1da8:	ff 93       	push	r31
TWI_HandleSlaveIRQ():
    1daa:	e0 91 bb 38 	lds	r30, 0x38BB	; 0x8038bb <Wire+0xc>
    1dae:	f0 91 bc 38 	lds	r31, 0x38BC	; 0x8038bc <Wire+0xd>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:511
      uint8_t* txHead   = &(_data->_bytesToWrite);
      uint8_t* rxHead   = &(_data->_bytesToRead);
    #endif
  #endif

  uint8_t clientStatus = _data->_module->SSTATUS;
    1db2:	83 85       	ldd	r24, Z+11	; 0x0b
    1db4:	98 2f       	mov	r25, r24
    1db6:	9c 70       	andi	r25, 0x0C	; 12
    1db8:	b1 f0       	breq	.+44     	; 0x1de6 <__vector_14+0x5e>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:513

  if (clientStatus & (TWI_BUSERR_bm | TWI_COLL_bm)) {   // if Bus error/Collision was detected
    1dba:	85 85       	ldd	r24, Z+13	; 0x0d
    1dbc:	10 92 c0 38 	sts	0x38C0, r1	; 0x8038c0 <Wire+0x11>
SlaveIRQ_DataReadNack():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:514
    _data->_module->SDATA;                              // Read data to remove Status flags
    1dc0:	10 92 bf 38 	sts	0x38BF, r1	; 0x8038bf <Wire+0x10>
__vector_14():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:515
    (*rxHead) = 0;                                      // Abort
    1dc4:	ff 91       	pop	r31
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:652
  #endif


  _data->_bools._ackMatters = false;                // stop checking for NACK
  _data->_module->SCTRLB = TWI_SCMD_COMPTRANS_gc;   // "Wait for any Start (S/Sr) condition"
  (*txHead) = 0;                                    // Abort further data writes
    1dc6:	ef 91       	pop	r30
    1dc8:	bf 91       	pop	r27
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/Wire.cpp:778
  TwoWire::onSlaveIRQ(&TWI0);
}
    1dca:	af 91       	pop	r26
    1dcc:	9f 91       	pop	r25
    1dce:	8f 91       	pop	r24
    1dd0:	7f 91       	pop	r23
    1dd2:	6f 91       	pop	r22
    1dd4:	5f 91       	pop	r21
    1dd6:	4f 91       	pop	r20
    1dd8:	3f 91       	pop	r19
    1dda:	2f 91       	pop	r18
    1ddc:	0f 90       	pop	r0
    1dde:	0f be       	out	0x3f, r0	; 63
    1de0:	0f 90       	pop	r0
    1de2:	1f 90       	pop	r1
    1de4:	18 95       	reti
TWI_HandleSlaveIRQ():
    1de6:	86 ff       	sbrs	r24, 6
    1de8:	2b c0       	rjmp	.+86     	; 0x1e40 <__vector_14+0xb8>
    1dea:	80 ff       	sbrs	r24, 0
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:522
  } else {                                              // No Bus error/Collision was detected
    #if defined(TWI_MANDS)
      _data->_bools._toggleStreamFn = 0x01;             // reroute stream functions to slave elements
    #endif

    if (clientStatus & TWI_APIF_bm) {  // Address/Stop Bit set
    1dec:	20 c0       	rjmp	.+64     	; 0x1e2e <__vector_14+0xa6>
    1dee:	81 ff       	sbrs	r24, 1
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:523
      if (clientStatus & TWI_AP_bm) {    // Address bit set
    1df0:	15 c0       	rjmp	.+42     	; 0x1e1c <__vector_14+0x94>
SlaveIRQ_AddrRead():
    1df2:	85 85       	ldd	r24, Z+13	; 0x0d
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:524
        if (clientStatus & TWI_DIR_bm) {   // Master is reading
    1df4:	80 93 be 38 	sts	0x38BE, r24	; 0x8038be <Wire+0xf>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:581
      uint8_t* txHead   = &(_data->_bytesToWrite);
      uint8_t* txTail   = &(_data->_bytesWritten);
    #endif
  #endif

  (*address) = _data->_module->SDATA;       // saving address to expose to the user sketch
    1df8:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <NotifyUser_onReceive.constprop.5>
    1dfc:	10 92 bf 38 	sts	0x38BF, r1	; 0x8038bf <Wire+0x10>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:584

                                            // There is no way to identify a REPSTART, so when a Master Read occurs after a Master write
  NotifyUser_onReceive(_data);              // Notify user program "onReceive" if necessary
    1e00:	10 92 c2 38 	sts	0x38C2, r1	; 0x8038c2 <Wire+0x13>
NotifyUser_onRequest():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:586

  (*txHead) = 0;                            // reset buffer positions so the Slave can start writing at zero.
    1e04:	e0 91 c3 38 	lds	r30, 0x38C3	; 0x8038c3 <Wire+0x14>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:587
  (*txTail) = 0;
    1e08:	f0 91 c4 38 	lds	r31, 0x38C4	; 0x8038c4 <Wire+0x15>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:730
 *
 *
 *@return     void
 */
void NotifyUser_onRequest(struct twiData *_data) {
  if (_data->user_onRequest != NULL) {
    1e0c:	30 97       	sbiw	r30, 0x00	; 0
    1e0e:	09 f0       	breq	.+2      	; 0x1e12 <__vector_14+0x8a>
    1e10:	09 95       	icall
SlaveIRQ_DataWrite():
    1e12:	e0 91 bb 38 	lds	r30, 0x38BB	; 0x8038bb <Wire+0xc>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:731
    _data->user_onRequest();
    1e16:	f0 91 bc 38 	lds	r31, 0x38BC	; 0x8038bc <Wire+0xd>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:706
  uint8_t payload = _data->_module->SDATA;

  if ((*rxHead) < BUFFER_LENGTH) {                // if buffer is not full
    rxBuffer[(*rxHead)] = payload;                  // Load data into the buffer
    (*rxHead)++;                                    // Advance Head
    _data->_module->SCTRLB = TWI_SCMD_RESPONSE_gc;  // "Execute Acknowledge Action succeeded by reception of next byte"
    1e1a:	07 c0       	rjmp	.+14     	; 0x1e2a <__vector_14+0xa2>
SlaveIRQ_AddrWrite():
    1e1c:	85 85       	ldd	r24, Z+13	; 0x0d
    1e1e:	80 93 be 38 	sts	0x38BE, r24	; 0x8038be <Wire+0xf>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:611
      uint8_t* rxTail   = &(_data->_bytesRead);
    #endif
  #endif


  (*address) = _data->_module->SDATA;
    1e22:	10 92 c0 38 	sts	0x38C0, r1	; 0x8038c0 <Wire+0x11>
    1e26:	10 92 c1 38 	sts	0x38C1, r1	; 0x8038c1 <Wire+0x12>
SlaveIRQ_DataWrite():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:612
  (*rxHead) = 0;                                    // reset buffer positions so the Master can start writing at zero.
    1e2a:	83 e0       	ldi	r24, 0x03	; 3
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:613
  (*rxTail) = 0;
    1e2c:	32 c0       	rjmp	.+100    	; 0x1e92 <__vector_14+0x10a>
SlaveIRQ_Stop():
    1e2e:	80 e4       	ldi	r24, 0x40	; 64
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:706
  uint8_t payload = _data->_module->SDATA;

  if ((*rxHead) < BUFFER_LENGTH) {                // if buffer is not full
    rxBuffer[(*rxHead)] = payload;                  // Load data into the buffer
    (*rxHead)++;                                    // Advance Head
    _data->_module->SCTRLB = TWI_SCMD_RESPONSE_gc;  // "Execute Acknowledge Action succeeded by reception of next byte"
    1e30:	83 87       	std	Z+11, r24	; 0x0b
    1e32:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <NotifyUser_onReceive.constprop.5>
SlaveIRQ_DataWrite():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:632
      uint8_t* rxTail   = &(_data->_bytesRead);
    #endif
  #endif


  _data->_module->SSTATUS = TWI_APIF_bm;      // Clear Flag, no further action needed
    1e36:	10 92 c0 38 	sts	0x38C0, r1	; 0x8038c0 <Wire+0x11>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:633
  NotifyUser_onReceive(_data);                // Notify user program "onReceive" if necessary
    1e3a:	10 92 c1 38 	sts	0x38C1, r1	; 0x8038c1 <Wire+0x12>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:709
    rxBuffer[(*rxHead)] = payload;                  // Load data into the buffer
    (*rxHead)++;                                    // Advance Head
    _data->_module->SCTRLB = TWI_SCMD_RESPONSE_gc;  // "Execute Acknowledge Action succeeded by reception of next byte"
  } else {                                          // else buffer is full
    _data->_module->SCTRLB = TWI_ACKACT_bm | TWI_SCMD_COMPTRANS_gc;  // "Execute ACK Action succeeded by waiting for any Start (S/Sr) condition"
    (*rxHead) = 0;                                           // Dismiss all received Data since data integrity can't be guaranteed
    1e3e:	c2 cf       	rjmp	.-124    	; 0x1dc4 <__vector_14+0x3c>
TWI_HandleSlaveIRQ():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:710
    (*rxTail) = 0;  // Make sure available will return 0
    1e40:	87 ff       	sbrs	r24, 7
    1e42:	c0 cf       	rjmp	.-128    	; 0x1dc4 <__vector_14+0x3c>
    1e44:	81 ff       	sbrs	r24, 1
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:532
          SlaveIRQ_AddrWrite(_data);
        }
      } else {                          // Stop bit set
        SlaveIRQ_Stop(_data);
      }
    } else if (clientStatus & TWI_DIF_bm) {  // Data bit set
    1e46:	27 c0       	rjmp	.+78     	; 0x1e96 <__vector_14+0x10e>
    1e48:	84 ff       	sbrs	r24, 4
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:533
      if (clientStatus & TWI_DIR_bm) {         // Master is reading
    1e4a:	0a c0       	rjmp	.+20     	; 0x1e60 <__vector_14+0xd8>
    1e4c:	80 91 bd 38 	lds	r24, 0x38BD	; 0x8038bd <Wire+0xe>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:534
        if ((clientStatus & TWI_RXACK_bm) && _data->_bools._ackMatters) {  // RXACK bit is set and it matters
    1e50:	87 ff       	sbrs	r24, 7
    1e52:	06 c0       	rjmp	.+12     	; 0x1e60 <__vector_14+0xd8>
SlaveIRQ_DataReadNack():
    1e54:	8f 77       	andi	r24, 0x7F	; 127
    1e56:	80 93 bd 38 	sts	0x38BD, r24	; 0x8038bd <Wire+0xe>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:650
      uint8_t* txHead   = &(_data->_bytesToWrite);
    #endif
  #endif


  _data->_bools._ackMatters = false;                // stop checking for NACK
    1e5a:	82 e0       	ldi	r24, 0x02	; 2
    1e5c:	82 87       	std	Z+10, r24	; 0x0a
    1e5e:	b0 cf       	rjmp	.-160    	; 0x1dc0 <__vector_14+0x38>
SlaveIRQ_DataReadAck():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:651
  _data->_module->SCTRLB = TWI_SCMD_COMPTRANS_gc;   // "Wait for any Start (S/Sr) condition"
    1e60:	80 91 bd 38 	lds	r24, 0x38BD	; 0x8038bd <Wire+0xe>
    1e64:	80 68       	ori	r24, 0x80	; 128
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:672
      uint8_t* txTail   = &(_data->_bytesWritten);
      uint8_t* txBuffer =   _data->_txBuffer;
    #endif
  #endif

  _data->_bools._ackMatters = true;             // start checking for NACK
    1e66:	80 93 bd 38 	sts	0x38BD, r24	; 0x8038bd <Wire+0xe>
    1e6a:	a0 91 c2 38 	lds	r26, 0x38C2	; 0x8038c2 <Wire+0x13>
    1e6e:	80 91 bf 38 	lds	r24, 0x38BF	; 0x8038bf <Wire+0x10>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:673
  if ((*txTail) < (*txHead)) {                  // Data is available
    1e72:	a8 17       	cp	r26, r24
    1e74:	68 f4       	brcc	.+26     	; 0x1e90 <__vector_14+0x108>
    1e76:	b0 e0       	ldi	r27, 0x00	; 0
    1e78:	a9 53       	subi	r26, 0x39	; 57
    1e7a:	b7 4c       	sbci	r27, 0xC7	; 199
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:674
    _data->_module->SDATA = txBuffer[(*txTail)];    // Writing to the register to send data
    1e7c:	8c 91       	ld	r24, X
    1e7e:	85 87       	std	Z+13, r24	; 0x0d
    1e80:	83 e0       	ldi	r24, 0x03	; 3
    1e82:	82 87       	std	Z+10, r24	; 0x0a
    1e84:	80 91 c2 38 	lds	r24, 0x38C2	; 0x8038c2 <Wire+0x13>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:675
    _data->_module->SCTRLB = TWI_SCMD_RESPONSE_gc;  // "Execute a byte read operation followed by Acknowledge Action"
    1e88:	8f 5f       	subi	r24, 0xFF	; 255
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:676
    (*txTail)++;                                    // Increment counter for sent bytes
    1e8a:	80 93 c2 38 	sts	0x38C2, r24	; 0x8038c2 <Wire+0x13>
    1e8e:	9a cf       	rjmp	.-204    	; 0x1dc4 <__vector_14+0x3c>
    1e90:	82 e0       	ldi	r24, 0x02	; 2
SlaveIRQ_DataWrite():
    1e92:	82 87       	std	Z+10, r24	; 0x0a
    1e94:	97 cf       	rjmp	.-210    	; 0x1dc4 <__vector_14+0x3c>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:679

  } else {                                            // No more data available
    _data->_module->SCTRLB = TWI_SCMD_COMPTRANS_gc;   // "Wait for any Start (S/Sr) condition"
    1e96:	95 85       	ldd	r25, Z+13	; 0x0d
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:706
  uint8_t payload = _data->_module->SDATA;

  if ((*rxHead) < BUFFER_LENGTH) {                // if buffer is not full
    rxBuffer[(*rxHead)] = payload;                  // Load data into the buffer
    (*rxHead)++;                                    // Advance Head
    _data->_module->SCTRLB = TWI_SCMD_RESPONSE_gc;  // "Execute Acknowledge Action succeeded by reception of next byte"
    1e98:	80 91 c0 38 	lds	r24, 0x38C0	; 0x8038c0 <Wire+0x11>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:701
      uint8_t* rxBuffer =   _data->_rxBuffer;
    #endif
  #endif


  uint8_t payload = _data->_module->SDATA;
    1e9c:	80 32       	cpi	r24, 0x20	; 32
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:703

  if ((*rxHead) < BUFFER_LENGTH) {                // if buffer is not full
    1e9e:	58 f4       	brcc	.+22     	; 0x1eb6 <__vector_14+0x12e>
    1ea0:	e8 2f       	mov	r30, r24
    1ea2:	f0 e0       	ldi	r31, 0x00	; 0
    1ea4:	e9 51       	subi	r30, 0x19	; 25
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:704
    rxBuffer[(*rxHead)] = payload;                  // Load data into the buffer
    1ea6:	f7 4c       	sbci	r31, 0xC7	; 199
    1ea8:	90 83       	st	Z, r25
    1eaa:	80 91 c0 38 	lds	r24, 0x38C0	; 0x8038c0 <Wire+0x11>
    1eae:	8f 5f       	subi	r24, 0xFF	; 255
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:705
    (*rxHead)++;                                    // Advance Head
    1eb0:	80 93 c0 38 	sts	0x38C0, r24	; 0x8038c0 <Wire+0x11>
    1eb4:	ae cf       	rjmp	.-164    	; 0x1e12 <__vector_14+0x8a>
    1eb6:	86 e0       	ldi	r24, 0x06	; 6
    1eb8:	82 87       	std	Z+10, r24	; 0x0a
    1eba:	bd cf       	rjmp	.-134    	; 0x1e36 <__vector_14+0xae>

00001ebc <global constructors keyed to 65535_0_Altimetr_SPI.cpp.o.3748>:
_GLOBAL__I_65535_0_Altimetr_SPI.cpp.o.3748():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\Wire\src/twi.c:708
    _data->_module->SCTRLB = TWI_SCMD_RESPONSE_gc;  // "Execute Acknowledge Action succeeded by reception of next byte"
  } else {                                          // else buffer is full
    _data->_module->SCTRLB = TWI_ACKACT_bm | TWI_SCMD_COMPTRANS_gc;  // "Execute ACK Action succeeded by waiting for any Start (S/Sr) condition"
    1ebc:	ff 92       	push	r15
    1ebe:	0f 93       	push	r16
    1ec0:	1f 93       	push	r17
    1ec2:	cf 93       	push	r28
    1ec4:	df 93       	push	r29
    1ec6:	10 92 1c 38 	sts	0x381C, r1	; 0x80381c <Serial+0x2>
    1eca:	10 92 1d 38 	sts	0x381D, r1	; 0x80381d <Serial+0x3>
    1ece:	88 ee       	ldi	r24, 0xE8	; 232
    1ed0:	93 e0       	ldi	r25, 0x03	; 3
    1ed2:	a0 e0       	ldi	r26, 0x00	; 0
    1ed4:	b0 e0       	ldi	r27, 0x00	; 0
    1ed6:	80 93 1e 38 	sts	0x381E, r24	; 0x80381e <Serial+0x4>
    1eda:	90 93 1f 38 	sts	0x381F, r25	; 0x80381f <Serial+0x5>
    1ede:	a0 93 20 38 	sts	0x3820, r26	; 0x803820 <Serial+0x6>
    1ee2:	b0 93 21 38 	sts	0x3821, r27	; 0x803821 <Serial+0x7>
    1ee6:	40 ed       	ldi	r20, 0xD0	; 208
    1ee8:	53 eb       	ldi	r21, 0xB3	; 179
    1eea:	40 93 1a 38 	sts	0x381A, r20	; 0x80381a <Serial>
    1eee:	50 93 1b 38 	sts	0x381B, r21	; 0x80381b <Serial+0x1>
    1ef2:	40 e0       	ldi	r20, 0x00	; 0
    1ef4:	58 e0       	ldi	r21, 0x08	; 8
    1ef6:	40 93 26 38 	sts	0x3826, r20	; 0x803826 <Serial+0xc>
    1efa:	50 93 27 38 	sts	0x3827, r21	; 0x803827 <Serial+0xd>
    1efe:	10 92 28 38 	sts	0x3828, r1	; 0x803828 <Serial+0xe>
    1f02:	10 92 29 38 	sts	0x3829, r1	; 0x803829 <Serial+0xf>
    1f06:	10 92 b1 38 	sts	0x38B1, r1	; 0x8038b1 <Wire+0x2>
    1f0a:	10 92 b2 38 	sts	0x38B2, r1	; 0x8038b2 <Wire+0x3>
    1f0e:	80 93 b3 38 	sts	0x38B3, r24	; 0x8038b3 <Wire+0x4>
    1f12:	90 93 b4 38 	sts	0x38B4, r25	; 0x8038b4 <Wire+0x5>
    1f16:	a0 93 b5 38 	sts	0x38B5, r26	; 0x8038b5 <Wire+0x6>
    1f1a:	b0 93 b6 38 	sts	0x38B6, r27	; 0x8038b6 <Wire+0x7>
    1f1e:	8a ee       	ldi	r24, 0xEA	; 234
    1f20:	93 eb       	ldi	r25, 0xB3	; 179
    1f22:	80 93 af 38 	sts	0x38AF, r24	; 0x8038af <Wire>
    1f26:	90 93 b0 38 	sts	0x38B0, r25	; 0x8038b0 <Wire+0x1>
    1f2a:	80 ea       	ldi	r24, 0xA0	; 160
    1f2c:	98 e0       	ldi	r25, 0x08	; 8
    1f2e:	80 93 bb 38 	sts	0x38BB, r24	; 0x8038bb <Wire+0xc>
    1f32:	90 93 bc 38 	sts	0x38BC, r25	; 0x8038bc <Wire+0xd>
    1f36:	40 e8       	ldi	r20, 0x80	; 128
    1f38:	56 e9       	ldi	r21, 0x96	; 150
    1f3a:	68 e9       	ldi	r22, 0x98	; 152
    1f3c:	70 e0       	ldi	r23, 0x00	; 0
    1f3e:	80 e0       	ldi	r24, 0x00	; 0
    1f40:	8f 5f       	subi	r24, 0xFF	; 255
    1f42:	86 30       	cpi	r24, 0x06	; 6
    1f44:	11 f4       	brne	.+4      	; 0x1f4a <global constructors keyed to 65535_0_Altimetr_SPI.cpp.o.3748+0x8e>
    1f46:	87 e0       	ldi	r24, 0x07	; 7
    1f48:	0b c0       	rjmp	.+22     	; 0x1f60 <global constructors keyed to 65535_0_Altimetr_SPI.cpp.o.3748+0xa4>
    1f4a:	76 95       	lsr	r23
    1f4c:	67 95       	ror	r22
    1f4e:	57 95       	ror	r21
    1f50:	47 95       	ror	r20
    1f52:	41 30       	cpi	r20, 0x01	; 1
    1f54:	99 e0       	ldi	r25, 0x09	; 9
    1f56:	59 07       	cpc	r21, r25
    1f58:	9d e3       	ldi	r25, 0x3D	; 61
    1f5a:	69 07       	cpc	r22, r25
    1f5c:	71 05       	cpc	r23, r1
    1f5e:	80 f7       	brcc	.-32     	; 0x1f40 <global constructors keyed to 65535_0_Altimetr_SPI.cpp.o.3748+0x84>
    1f60:	34 e0       	ldi	r19, 0x04	; 4
    1f62:	f3 2e       	mov	r15, r19
    1f64:	f0 92 08 39 	sts	0x3908, r15	; 0x803908 <DEFAULT_SPI_SETTINGS+0x1>
    1f68:	98 2f       	mov	r25, r24
    1f6a:	90 95       	com	r25
    1f6c:	29 2f       	mov	r18, r25
    1f6e:	21 70       	andi	r18, 0x01	; 1
    1f70:	30 e0       	ldi	r19, 0x00	; 0
    1f72:	44 e0       	ldi	r20, 0x04	; 4
    1f74:	22 0f       	add	r18, r18
    1f76:	33 1f       	adc	r19, r19
    1f78:	4a 95       	dec	r20
    1f7a:	e1 f7       	brne	.-8      	; 0x1f74 <global constructors keyed to 65535_0_Altimetr_SPI.cpp.o.3748+0xb8>
    1f7c:	81 62       	ori	r24, 0x21	; 33
    1f7e:	82 2b       	or	r24, r18
    1f80:	80 93 07 39 	sts	0x3907, r24	; 0x803907 <DEFAULT_SPI_SETTINGS>
    1f84:	10 92 0b 39 	sts	0x390B, r1	; 0x80390b <bmp+0x2>
    1f88:	10 92 0c 39 	sts	0x390C, r1	; 0x80390c <bmp+0x3>
    1f8c:	8c e1       	ldi	r24, 0x1C	; 28
    1f8e:	90 e0       	ldi	r25, 0x00	; 0
    1f90:	0e 94 96 18 	call	0x312c	; 0x312c <malloc>
    1f94:	ec 01       	movw	r28, r24
    1f96:	87 e0       	ldi	r24, 0x07	; 7
    1f98:	8b 87       	std	Y+11, r24	; 0x0b
    1f9a:	8a e0       	ldi	r24, 0x0A	; 10
    1f9c:	8c 87       	std	Y+12, r24	; 0x0c
    1f9e:	89 e0       	ldi	r24, 0x09	; 9
    1fa0:	8e 87       	std	Y+14, r24	; 0x0e
    1fa2:	88 e0       	ldi	r24, 0x08	; 8
    1fa4:	8d 87       	std	Y+13, r24	; 0x0d
    1fa6:	24 e2       	ldi	r18, 0x24	; 36
    1fa8:	34 e0       	ldi	r19, 0x04	; 4
    1faa:	2d 8b       	std	Y+21, r18	; 0x15
    1fac:	3e 8b       	std	Y+22, r19	; 0x16
    1fae:	91 e0       	ldi	r25, 0x01	; 1
    1fb0:	9a 8f       	std	Y+26, r25	; 0x1a
    1fb2:	24 e0       	ldi	r18, 0x04	; 4
    1fb4:	34 e0       	ldi	r19, 0x04	; 4
    1fb6:	2f 87       	std	Y+15, r18	; 0x0f
    1fb8:	38 8b       	std	Y+16, r19	; 0x10
    1fba:	92 e0       	ldi	r25, 0x02	; 2
    1fbc:	9f 8b       	std	Y+23, r25	; 0x17
    1fbe:	48 e0       	ldi	r20, 0x08	; 8
    1fc0:	54 e0       	ldi	r21, 0x04	; 4
    1fc2:	4b 8b       	std	Y+19, r20	; 0x13
    1fc4:	5c 8b       	std	Y+20, r21	; 0x14
    1fc6:	f8 8e       	std	Y+24, r15	; 0x18
    1fc8:	29 8b       	std	Y+17, r18	; 0x11
    1fca:	3a 8b       	std	Y+18, r19	; 0x12
    1fcc:	89 8f       	std	Y+25, r24	; 0x19
    1fce:	80 e4       	ldi	r24, 0x40	; 64
    1fd0:	92 e4       	ldi	r25, 0x42	; 66
    1fd2:	af e0       	ldi	r26, 0x0F	; 15
    1fd4:	b0 e0       	ldi	r27, 0x00	; 0
    1fd6:	8c 83       	std	Y+4, r24	; 0x04
    1fd8:	9d 83       	std	Y+5, r25	; 0x05
    1fda:	ae 83       	std	Y+6, r26	; 0x06
    1fdc:	bf 83       	std	Y+7, r27	; 0x07
    1fde:	81 e0       	ldi	r24, 0x01	; 1
    1fe0:	90 e0       	ldi	r25, 0x00	; 0
    1fe2:	88 87       	std	Y+8, r24	; 0x08
    1fe4:	99 87       	std	Y+9, r25	; 0x09
    1fe6:	1a 86       	std	Y+10, r1	; 0x0a
    1fe8:	1b 8e       	std	Y+27, r1	; 0x1b
    1fea:	82 e0       	ldi	r24, 0x02	; 2
    1fec:	90 e0       	ldi	r25, 0x00	; 0
    1fee:	0e 94 96 18 	call	0x312c	; 0x312c <malloc>
    1ff2:	fc 01       	movw	r30, r24
    1ff4:	40 e8       	ldi	r20, 0x80	; 128
    1ff6:	56 e9       	ldi	r21, 0x96	; 150
    1ff8:	68 e9       	ldi	r22, 0x98	; 152
    1ffa:	70 e0       	ldi	r23, 0x00	; 0
    1ffc:	90 e0       	ldi	r25, 0x00	; 0
    1ffe:	9f 5f       	subi	r25, 0xFF	; 255
    2000:	96 30       	cpi	r25, 0x06	; 6
    2002:	11 f4       	brne	.+4      	; 0x2008 <global constructors keyed to 65535_0_Altimetr_SPI.cpp.o.3748+0x14c>
    2004:	97 e0       	ldi	r25, 0x07	; 7
    2006:	0b c0       	rjmp	.+22     	; 0x201e <global constructors keyed to 65535_0_Altimetr_SPI.cpp.o.3748+0x162>
    2008:	76 95       	lsr	r23
    200a:	67 95       	ror	r22
    200c:	57 95       	ror	r21
    200e:	47 95       	ror	r20
    2010:	41 34       	cpi	r20, 0x41	; 65
    2012:	82 e4       	ldi	r24, 0x42	; 66
    2014:	58 07       	cpc	r21, r24
    2016:	8f e0       	ldi	r24, 0x0F	; 15
    2018:	68 07       	cpc	r22, r24
    201a:	71 05       	cpc	r23, r1
    201c:	80 f7       	brcc	.-32     	; 0x1ffe <global constructors keyed to 65535_0_Altimetr_SPI.cpp.o.3748+0x142>
    201e:	84 e0       	ldi	r24, 0x04	; 4
    2020:	81 83       	std	Z+1, r24	; 0x01
    2022:	89 2f       	mov	r24, r25
    2024:	80 95       	com	r24
    2026:	08 2f       	mov	r16, r24
    2028:	01 70       	andi	r16, 0x01	; 1
    202a:	10 e0       	ldi	r17, 0x00	; 0
    202c:	84 e0       	ldi	r24, 0x04	; 4
    202e:	00 0f       	add	r16, r16
    2030:	11 1f       	adc	r17, r17
    2032:	8a 95       	dec	r24
    2034:	e1 f7       	brne	.-8      	; 0x202e <global constructors keyed to 65535_0_Altimetr_SPI.cpp.o.3748+0x172>
    2036:	91 62       	ori	r25, 0x21	; 33
    2038:	90 2b       	or	r25, r16
    203a:	90 83       	st	Z, r25
    203c:	ea 83       	std	Y+2, r30	; 0x02
    203e:	fb 83       	std	Y+3, r31	; 0x03
    2040:	18 82       	st	Y, r1
    2042:	19 82       	std	Y+1, r1	; 0x01
    2044:	09 e0       	ldi	r16, 0x09	; 9
    2046:	19 e3       	ldi	r17, 0x39	; 57
    2048:	c0 93 0d 39 	sts	0x390D, r28	; 0x80390d <bmp+0x4>
    204c:	d0 93 0e 39 	sts	0x390E, r29	; 0x80390e <bmp+0x5>
    2050:	87 e0       	ldi	r24, 0x07	; 7
    2052:	90 e0       	ldi	r25, 0x00	; 0
    2054:	0e 94 96 18 	call	0x312c	; 0x312c <malloc>
    2058:	fc 01       	movw	r30, r24
    205a:	82 e2       	ldi	r24, 0x22	; 34
    205c:	94 eb       	ldi	r25, 0xB4	; 180
    205e:	80 83       	st	Z, r24
    2060:	91 83       	std	Z+1, r25	; 0x01
    2062:	88 e1       	ldi	r24, 0x18	; 24
    2064:	91 e0       	ldi	r25, 0x01	; 1
    2066:	83 83       	std	Z+3, r24	; 0x03
    2068:	94 83       	std	Z+4, r25	; 0x04
    206a:	05 83       	std	Z+5, r16	; 0x05
    206c:	16 83       	std	Z+6, r17	; 0x06
    206e:	e0 93 0f 39 	sts	0x390F, r30	; 0x80390f <bmp+0x6>
    2072:	f0 93 10 39 	sts	0x3910, r31	; 0x803910 <bmp+0x7>
    2076:	87 e0       	ldi	r24, 0x07	; 7
    2078:	90 e0       	ldi	r25, 0x00	; 0
    207a:	0e 94 96 18 	call	0x312c	; 0x312c <malloc>
    207e:	fc 01       	movw	r30, r24
    2080:	84 e1       	ldi	r24, 0x14	; 20
    2082:	94 eb       	ldi	r25, 0xB4	; 180
    2084:	80 83       	st	Z, r24
    2086:	91 83       	std	Z+1, r25	; 0x01
    2088:	13 82       	std	Z+3, r1	; 0x03
    208a:	14 82       	std	Z+4, r1	; 0x04
    208c:	05 83       	std	Z+5, r16	; 0x05
    208e:	16 83       	std	Z+6, r17	; 0x06
    2090:	e0 93 11 39 	sts	0x3911, r30	; 0x803911 <bmp+0x8>
    2094:	f0 93 12 39 	sts	0x3912, r31	; 0x803912 <bmp+0x9>
    2098:	df 91       	pop	r29
    209a:	cf 91       	pop	r28
    209c:	1f 91       	pop	r17
    209e:	0f 91       	pop	r16
    20a0:	ff 90       	pop	r15
    20a2:	08 95       	ret

000020a4 <main>:
main():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/main.cpp:49
 * called first in non-optiboot configurations (neither is needed on Optibooot configurations() *
 * an extra bit of initialization code in .init3 to fix the vectors and still happen if user    *
 * overrides main. In the past there was a USB-related function here, that is removed, as work  *
 * will be needed in any event at the core level if VUSB-based "stuff" arrives, but really I'm  *
 * just waiting for the DU-series now                                                           */
int main() {
    20a4:	cf 93       	push	r28
    20a6:	df 93       	push	r29
    20a8:	1f 92       	push	r1
    20aa:	cd b7       	in	r28, 0x3d	; 61
    20ac:	de b7       	in	r29, 0x3e	; 62
init_clock():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:1275
    #if (defined(CLOCK_TUNE_INTERNAL))
      tune_internal(); // Will be inlined as only called once. Just too long and ugly to put two implementations in middle of this.
    #else
      #if (F_CPU == 20000000)
        /* No division on clock */
        _PROTECTED_WRITE(CLKCTRL_MCLKCTRLB, 0x00);
    20ae:	88 ed       	ldi	r24, 0xD8	; 216
    20b0:	90 e0       	ldi	r25, 0x00	; 0
    20b2:	84 bf       	out	0x34, r24	; 52
    20b4:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <vtable for Adafruit_BMP280_Temp+0x7f4c43>
init_ADC0():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:1407
    #elif F_CPU  >= 30000000            // 32 MHz /12 = 2.67 MHz
      ADC0.CTRLB  = ADC_PRESC_DIV12_gc; // 30 MHz /12 = 2.50 MHz
    #elif F_CPU  >= 24000000            // 25 MHz /10 = 2.50 MHz
      ADC0.CTRLB  = ADC_PRESC_DIV10_gc; // 24 MHz /10 = 2.40 MHz
    #elif F_CPU  >= 20000000
      ADC0.CTRLB  = ADC_PRESC_DIV8_gc;  // 20 MHz / 8 = 2.50 MHz
    20b8:	83 e0       	ldi	r24, 0x03	; 3
    20ba:	80 93 01 06 	sts	0x0601, r24	; 0x800601 <vtable for Adafruit_BMP280_Temp+0x7f51e3>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:1417
    #elif F_CPU  >=  6000000            // 10 MHz / 4 = 2.50 MHz
      ADC0.CTRLB  = ADC_PRESC_DIV4_gc;  //  8 MHz / 4 = 2.00 MHz
    #else                               //  5 MHz / 2 = 2.50 MHz
      ADC0.CTRLB  = ADC_PRESC_DIV2_gc;  //  4 MHz / 2 = 2.00 MHz
    #endif                              //  1 MHz / 2 =  500 kHz
    ADC0.CTRLE = 15; // 15.5 without PGA, 16 with PGA, corresponding to 7.75 or 8 us.
    20be:	9f e0       	ldi	r25, 0x0F	; 15
    20c0:	90 93 08 06 	sts	0x0608, r25	; 0x800608 <vtable for Adafruit_BMP280_Temp+0x7f51ea>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:1418
    ADC0.CTRLA = ADC_ENABLE_bm | ADC_LOWLAT_bm;
    20c4:	91 e2       	ldi	r25, 0x21	; 33
    20c6:	90 93 00 06 	sts	0x0600, r25	; 0x800600 <vtable for Adafruit_BMP280_Temp+0x7f51e2>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:1423
    /* Default low latency mode on
     * Users can turn it off if they care about power consumption while ADC is on
     * and chip is awake, since these parts don't have the perverse ADC-left-on
     * behavior of classic AVRs. */
    ADC0.CTRLC = TIMEBASE_1US; // defined in Arduino.h.
    20ca:	90 ea       	ldi	r25, 0xA0	; 160
    20cc:	90 93 02 06 	sts	0x0602, r25	; 0x800602 <vtable for Adafruit_BMP280_Temp+0x7f51e4>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:1424
    ADC0.PGACTRL = ADC_PGABIASSEL_3_4X_gc | ADC_ADCPGASAMPDUR_15CLK_gc;
    20d0:	9a e0       	ldi	r25, 0x0A	; 10
    20d2:	90 93 0b 06 	sts	0x060B, r25	; 0x80060b <vtable for Adafruit_BMP280_Temp+0x7f51ed>
init_TCA0():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:1487
  #ifdef __AVR_ATtinyxy2__
    PORTMUX.CTRLC = 1; // move WO0 output to PA7 so PA3 can be used with WO3
  #endif

  /* Enable Split Mode */
  TCA0.SPLIT.CTRLD = TCA_SPLIT_SPLITM_bm;
    20d6:	91 e0       	ldi	r25, 0x01	; 1
    20d8:	90 93 03 0a 	sts	0x0A03, r25	; 0x800a03 <vtable for Adafruit_BMP280_Temp+0x7f55e5>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:1492

  // Only 1 WGM so no need to specifically set up.

  /* Period setting, 8-bit register in SPLIT mode */
  TCA0.SPLIT.LPER    = PWM_TIMER_PERIOD;
    20dc:	2e ef       	ldi	r18, 0xFE	; 254
    20de:	20 93 26 0a 	sts	0x0A26, r18	; 0x800a26 <vtable for Adafruit_BMP280_Temp+0x7f5608>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:1493
  TCA0.SPLIT.HPER    = PWM_TIMER_PERIOD;
    20e2:	20 93 27 0a 	sts	0x0A27, r18	; 0x800a27 <vtable for Adafruit_BMP280_Temp+0x7f5609>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:1511
  /* Use prescale appropriate for system clock speed */

  #if (F_CPU > 25000000) //   use 256 divider when clocked over 25 MHz
    TCA0.SPLIT.CTRLA   = (TCA_SPLIT_CLKSEL_DIV256_gc) | (TCA_SPLIT_ENABLE_bm);
  #elif (F_CPU > 5000000) //  use 64 divider for everything in the middle
    TCA0.SPLIT.CTRLA   =  (TCA_SPLIT_CLKSEL_DIV64_gc) | (TCA_SPLIT_ENABLE_bm);
    20e6:	2b e0       	ldi	r18, 0x0B	; 11
    20e8:	20 93 00 0a 	sts	0x0A00, r18	; 0x800a00 <vtable for Adafruit_BMP280_Temp+0x7f55e2>
init_millis():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:1204
        // RTC.CLKSEL=0; this is the power on value
      #endif
      RTC.INTCTRL         = 0x01; // enable overflow interrupt
      RTC.CTRLA           = (RTC_RUNSTDBY_bm|RTC_RTCEN_bm|RTC_PRESCALER_DIV32_gc);//fire it up, prescale by 32.
    #else // It's a type b timer - we have already errored out if that wasn't defined
      _timer->CCMP = TIME_TRACKING_TIMER_PERIOD;
    20ec:	2f e0       	ldi	r18, 0x0F	; 15
    20ee:	37 e2       	ldi	r19, 0x27	; 39
    20f0:	20 93 9c 0a 	sts	0x0A9C, r18	; 0x800a9c <vtable for Adafruit_BMP280_Temp+0x7f567e>
    20f4:	30 93 9d 0a 	sts	0x0A9D, r19	; 0x800a9d <vtable for Adafruit_BMP280_Temp+0x7f567f>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:1206
      // Enable timer interrupt, but clear the rest of register
      _timer->INTCTRL = TCB_CAPT_bm;
    20f8:	90 93 95 0a 	sts	0x0A95, r25	; 0x800a95 <vtable for Adafruit_BMP280_Temp+0x7f5677>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:1208
      // Clear timer mode (since it will have been set as PWM by init())
      _timer->CTRLB = 0;
    20fc:	10 92 91 0a 	sts	0x0A91, r1	; 0x800a91 <vtable for Adafruit_BMP280_Temp+0x7f5673>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:1210
      // CLK_PER/1 is 0b00,. CLK_PER/2 is 0b01, so bitwise OR of valid divider with enable works
      _timer->CTRLA = TIME_TRACKING_TIMER_DIVIDER|TCB_ENABLE_bm;  // Keep this last before enabling interrupts to ensure tracking as accurate as possible
    2100:	80 93 90 0a 	sts	0x0A90, r24	; 0x800a90 <vtable for Adafruit_BMP280_Temp+0x7f5672>
init():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:1257
  #ifndef MILLIS_USE_TIMERNONE
    init_millis();
  #endif
  /*************************** ENABLE GLOBAL INTERRUPTS *************************/
  // Finally, after everything is initialized, we go ahead and enable interrupts.
  sei();
    2104:	78 94       	sei
main():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/main.cpp:53
  onBeforeInit(); // Emnpty callback called before init but after the .init stuff. First normal code executed
  init(); // Interrupts are turned on just prior to init() returning.
  initVariant();
  if (!onAfterInit()) sei();  // enable interrupts.
    2106:	78 94       	sei
    2108:	10 e0       	ldi	r17, 0x00	; 0
setup():
g:\Studia\PUT Rocket LAB\altimetr\Altimetr_SPI/Altimetr_SPI.ino:32
uint64_t t = 0; // timer updated with millis()
void setup()
{
  // put your setup code here, to run once:
  for (int i = 0; i < 11; i++) // For all pins
    pinMode(i, OUTPUT);
    210a:	61 e0       	ldi	r22, 0x01	; 1
    210c:	81 2f       	mov	r24, r17
    210e:	0e 94 5e 06 	call	0xcbc	; 0xcbc <pinMode>
    2112:	1f 5f       	subi	r17, 0xFF	; 255
g:\Studia\PUT Rocket LAB\altimetr\Altimetr_SPI/Altimetr_SPI.ino:31
float initialHight;
uint64_t t = 0; // timer updated with millis()
void setup()
{
  // put your setup code here, to run once:
  for (int i = 0; i < 11; i++) // For all pins
    2114:	1b 30       	cpi	r17, 0x0B	; 11
    2116:	c9 f7       	brne	.-14     	; 0x210a <main+0x66>
g:\Studia\PUT Rocket LAB\altimetr\Altimetr_SPI/Altimetr_SPI.ino:33
    pinMode(i, OUTPUT);
  pinMode(SEND_DATA_UART_EN, INPUT_PULLUP);
    2118:	62 e0       	ldi	r22, 0x02	; 2
    211a:	83 e0       	ldi	r24, 0x03	; 3
    211c:	0e 94 5e 06 	call	0xcbc	; 0xcbc <pinMode>
g:\Studia\PUT Rocket LAB\altimetr\Altimetr_SPI/Altimetr_SPI.ino:34
  Serial.begin(115200);
    2120:	40 e0       	ldi	r20, 0x00	; 0
    2122:	52 ec       	ldi	r21, 0xC2	; 194
    2124:	61 e0       	ldi	r22, 0x01	; 1
    2126:	70 e0       	ldi	r23, 0x00	; 0
    2128:	8a e1       	ldi	r24, 0x1A	; 26
    212a:	98 e3       	ldi	r25, 0x38	; 56
    212c:	0e 94 91 05 	call	0xb22	; 0xb22 <UartClass::begin(unsigned long)>
write():
    2130:	84 e4       	ldi	r24, 0x44	; 68
    2132:	94 eb       	ldi	r25, 0xB4	; 180
    2134:	0e 94 40 07 	call	0xe80	; 0xe80 <Print::write(char const*) [clone .part.2] [clone .constprop.52]>
    2138:	8a e3       	ldi	r24, 0x3A	; 58
    213a:	94 eb       	ldi	r25, 0xB4	; 180
    213c:	0e 94 40 07 	call	0xe80	; 0xe80 <Print::write(char const*) [clone .part.2] [clone .constprop.52]>
begin():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:86
 *  @param chipid
 *         The expected chip ID (used to validate connection).
 *  @return True if the init was successful, otherwise false.
 */
bool Adafruit_BMP280::begin(uint8_t addr, uint8_t chipid) {
  if (spi_dev == NULL) {
    2140:	00 91 0d 39 	lds	r16, 0x390D	; 0x80390d <bmp+0x4>
    2144:	10 91 0e 39 	lds	r17, 0x390E	; 0x80390e <bmp+0x5>
    2148:	01 15       	cp	r16, r1
    214a:	11 05       	cpc	r17, r1
    214c:	09 f0       	breq	.+2      	; 0x2150 <main+0xac>
    214e:	40 c0       	rjmp	.+128    	; 0x21d0 <main+0x12c>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:88
    // I2C mode
    if (i2c_dev)
    2150:	80 91 0b 39 	lds	r24, 0x390B	; 0x80390b <bmp+0x2>
    2154:	90 91 0c 39 	lds	r25, 0x390C	; 0x80390c <bmp+0x3>
    2158:	00 97       	sbiw	r24, 0x00	; 0
    215a:	11 f0       	breq	.+4      	; 0x2160 <main+0xbc>
operator delete():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/new.cpp:63
    215c:	0e 94 32 19 	call	0x3264	; 0x3264 <free>
operator new():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/new.cpp:33

#include <stdlib.h>

// For C++11, only need the following:
void *operator new  (size_t size) {
  return malloc(size);
    2160:	86 e0       	ldi	r24, 0x06	; 6
    2162:	90 e0       	ldi	r25, 0x00	; 0
    2164:	e3 d7       	rcall	.+4038   	; 0x312c <malloc>
begin():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:90
      delete i2c_dev;
    i2c_dev = new Adafruit_I2CDevice(addr, _wire);
    2166:	20 91 09 39 	lds	r18, 0x3909	; 0x803909 <bmp>
    216a:	30 91 0a 39 	lds	r19, 0x390A	; 0x80390a <bmp+0x1>
__base_ctor ():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:12
 *    @brief  Create an I2C device at a given address
 *    @param  addr The 7-bit I2C address for the device
 *    @param  theWire The I2C bus to use, defaults to &Wire
 */
Adafruit_I2CDevice::Adafruit_I2CDevice(uint8_t addr, TwoWire *theWire) {
  _addr = addr;
    216e:	46 e7       	ldi	r20, 0x76	; 118
    2170:	dc 01       	movw	r26, r24
    2172:	4c 93       	st	X, r20
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:13
  _wire = theWire;
    2174:	11 96       	adiw	r26, 0x01	; 1
    2176:	2d 93       	st	X+, r18
    2178:	3c 93       	st	X, r19
    217a:	12 97       	sbiw	r26, 0x02	; 2
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:14
  _begun = false;
    217c:	13 96       	adiw	r26, 0x03	; 3
    217e:	1c 92       	st	X, r1
    2180:	13 97       	sbiw	r26, 0x03	; 3
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:18
#ifdef ARDUINO_ARCH_SAMD
  _maxBufferSize = 250; // as defined in Wire.h's RingBuffer
#else
  _maxBufferSize = 32;
    2182:	20 e2       	ldi	r18, 0x20	; 32
    2184:	30 e0       	ldi	r19, 0x00	; 0
    2186:	14 96       	adiw	r26, 0x04	; 4
    2188:	2d 93       	st	X+, r18
    218a:	3c 93       	st	X, r19
    218c:	15 97       	sbiw	r26, 0x05	; 5
begin():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:90
    218e:	80 93 0b 39 	sts	0x390B, r24	; 0x80390b <bmp+0x2>
    2192:	90 93 0c 39 	sts	0x390C, r25	; 0x80390c <bmp+0x3>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:91
    if (!i2c_dev->begin())
    2196:	0e 94 9a 05 	call	0xb34	; 0xb34 <Adafruit_I2CDevice::begin(bool) [clone .constprop.16]>
    219a:	81 11       	cpse	r24, r1
    219c:	5d c0       	rjmp	.+186    	; 0x2258 <main+0x1b4>
    219e:	0a ef       	ldi	r16, 0xFA	; 250
    21a0:	10 e0       	ldi	r17, 0x00	; 0
print():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:46
size_t Print::print(const __FlashStringHelper *ifsh) {
  #if defined(__AVR__)
  PGM_P p = reinterpret_cast<PGM_P>(ifsh);
  size_t n = 0;
  while (1) {
    unsigned char c = pgm_read_byte(p++);
    21a2:	f8 01       	movw	r30, r16
    21a4:	64 91       	lpm	r22, Z
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:47
    if (c == 0) {
    21a6:	66 23       	and	r22, r22
    21a8:	41 f0       	breq	.+16     	; 0x21ba <main+0x116>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore\api/Print.cpp:50
      break;
    }
    if (write(c)) {
    21aa:	8a e1       	ldi	r24, 0x1A	; 26
    21ac:	98 e3       	ldi	r25, 0x38	; 56
    21ae:	0e 94 88 01 	call	0x310	; 0x310 <UartClass::write(unsigned char)>
    21b2:	0f 5f       	subi	r16, 0xFF	; 255
    21b4:	1f 4f       	sbci	r17, 0xFF	; 255
    21b6:	89 2b       	or	r24, r25
    21b8:	a1 f7       	brne	.-24     	; 0x21a2 <main+0xfe>
write():
    21ba:	8a e3       	ldi	r24, 0x3A	; 58
    21bc:	94 eb       	ldi	r25, 0xB4	; 180
    21be:	0e 94 40 07 	call	0xe80	; 0xe80 <Print::write(char const*) [clone .part.2] [clone .constprop.52]>
setup():
g:\Studia\PUT Rocket LAB\altimetr\Altimetr_SPI/Altimetr_SPI.ino:42
  if (!bmp.begin())
  {
    Serial.println(F("Could not find a valid BMP280 sensor, check wiring or "
                     "try a different address!"));
    while (1)
      delay(10);
    21c2:	6a e0       	ldi	r22, 0x0A	; 10
    21c4:	70 e0       	ldi	r23, 0x00	; 0
    21c6:	80 e0       	ldi	r24, 0x00	; 0
    21c8:	90 e0       	ldi	r25, 0x00	; 0
    21ca:	0e 94 37 02 	call	0x46e	; 0x46e <delay>
    21ce:	f9 cf       	rjmp	.-14     	; 0x21c2 <main+0x11e>
begin():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:92
 *    @brief  Initializes SPI bus and sets CS pin high
 *    @return Always returns true because there's no way to test success of SPI
 * init
 */
bool Adafruit_SPIDevice::begin(void) {
  pinMode(_cs, OUTPUT);
    21d0:	61 e0       	ldi	r22, 0x01	; 1
    21d2:	f8 01       	movw	r30, r16
    21d4:	83 85       	ldd	r24, Z+11	; 0x0b
    21d6:	0e 94 5e 06 	call	0xcbc	; 0xcbc <pinMode>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:93
  digitalWrite(_cs, HIGH);
    21da:	61 e0       	ldi	r22, 0x01	; 1
    21dc:	d8 01       	movw	r26, r16
    21de:	1b 96       	adiw	r26, 0x0b	; 11
    21e0:	8c 91       	ld	r24, X
    21e2:	0e 94 db 05 	call	0xbb6	; 0xbb6 <digitalWrite>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:95

  if (_spi) { // hardware SPI
    21e6:	d8 01       	movw	r26, r16
    21e8:	ed 91       	ld	r30, X+
    21ea:	fc 91       	ld	r31, X
    21ec:	30 97       	sbiw	r30, 0x00	; 0
    21ee:	09 f4       	brne	.+2      	; 0x21f2 <main+0x14e>
    21f0:	8b c1       	rjmp	.+790    	; 0x2508 <main+0x464>
init():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:149

  config(DEFAULT_SPI_SETTINGS);
}

void SPIClass::init() {
  if (initialized) {
    21f2:	85 81       	ldd	r24, Z+5	; 0x05
    21f4:	81 11       	cpse	r24, r1
    21f6:	0c c0       	rjmp	.+24     	; 0x2210 <main+0x16c>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:152
    return;
  }
  interruptMode = SPI_IMODE_NONE;
    21f8:	16 82       	std	Z+6, r1	; 0x06
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:153
  interruptSave = 0;
    21fa:	17 82       	std	Z+7, r1	; 0x07
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:154
  interruptMask_lo = 0;
    21fc:	10 86       	std	Z+8, r1	; 0x08
    21fe:	11 86       	std	Z+9, r1	; 0x09
    2200:	12 86       	std	Z+10, r1	; 0x0a
    2202:	13 86       	std	Z+11, r1	; 0x0b
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:155
  interruptMask_hi = 0;
    2204:	14 86       	std	Z+12, r1	; 0x0c
    2206:	15 86       	std	Z+13, r1	; 0x0d
    2208:	16 86       	std	Z+14, r1	; 0x0e
    220a:	17 86       	std	Z+15, r1	; 0x0f
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:156
  initialized = true;
    220c:	81 e0       	ldi	r24, 0x01	; 1
    220e:	85 83       	std	Z+5, r24	; 0x05
begin():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:111
void SPIClass::begin() {
  init();
  #if defined(PORTMUX_CTRLB)
  PORTMUX.CTRLB = _uc_mux | (PORTMUX.CTRLB & ~PORTMUX_SPI0_bm);
  #elif defined(PORTMUX_SPIROUTEA)
  PORTMUX.SPIROUTEA = _uc_mux | (PORTMUX.SPIROUTEA & ~3);
    2210:	80 91 e3 05 	lds	r24, 0x05E3	; 0x8005e3 <vtable for Adafruit_BMP280_Temp+0x7f51c5>
    2214:	8c 7f       	andi	r24, 0xFC	; 252
    2216:	94 81       	ldd	r25, Z+4	; 0x04
    2218:	89 2b       	or	r24, r25
    221a:	80 93 e3 05 	sts	0x05E3, r24	; 0x8005e3 <vtable for Adafruit_BMP280_Temp+0x7f51c5>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:138
    pinMode(PIN_SPI_SCK_PINSWAP_2, OUTPUT);
  }
  #endif
  #else
  // MISO is set to input by the controller
  pinMode(PIN_SPI_MOSI, OUTPUT);
    221e:	61 e0       	ldi	r22, 0x01	; 1
    2220:	88 e0       	ldi	r24, 0x08	; 8
    2222:	0e 94 5e 06 	call	0xcbc	; 0xcbc <pinMode>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:139
  pinMode(PIN_SPI_SCK, OUTPUT);
    2226:	61 e0       	ldi	r22, 0x01	; 1
    2228:	8a e0       	ldi	r24, 0x0A	; 10
    222a:	0e 94 5e 06 	call	0xcbc	; 0xcbc <pinMode>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:142
  #endif

  SPI0.CTRLB |= (SPI_SSD_bm);
    222e:	80 91 c1 08 	lds	r24, 0x08C1	; 0x8008c1 <vtable for Adafruit_BMP280_Temp+0x7f54a3>
    2232:	84 60       	ori	r24, 0x04	; 4
    2234:	80 93 c1 08 	sts	0x08C1, r24	; 0x8008c1 <vtable for Adafruit_BMP280_Temp+0x7f54a3>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:143
  SPI0.CTRLA |= (SPI_ENABLE_bm | SPI_MASTER_bm);
    2238:	80 91 c0 08 	lds	r24, 0x08C0	; 0x8008c0 <vtable for Adafruit_BMP280_Temp+0x7f54a2>
    223c:	81 62       	ori	r24, 0x21	; 33
    223e:	80 93 c0 08 	sts	0x08C0, r24	; 0x8008c0 <vtable for Adafruit_BMP280_Temp+0x7f54a2>
    2242:	90 91 07 39 	lds	r25, 0x3907	; 0x803907 <DEFAULT_SPI_SETTINGS>
    2246:	80 91 08 39 	lds	r24, 0x3908	; 0x803908 <DEFAULT_SPI_SETTINGS+0x1>
config():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:160
  interruptMask_hi = 0;
  initialized = true;
}

void SPIClass::config(SPISettings settings) {
  SPI0.CTRLA = settings.ctrla;
    224a:	90 93 c0 08 	sts	0x08C0, r25	; 0x8008c0 <vtable for Adafruit_BMP280_Temp+0x7f54a2>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\libraries\SPI\src/SPI.cpp:161
  SPI0.CTRLB = settings.ctrlb;
    224e:	80 93 c1 08 	sts	0x08C1, r24	; 0x8008c1 <vtable for Adafruit_BMP280_Temp+0x7f54a3>
begin():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:116
    if (_miso != -1) {
      pinMode(_miso, INPUT);
    }
  }

  _begun = true;
    2252:	81 e0       	ldi	r24, 0x01	; 1
    2254:	f8 01       	movw	r30, r16
    2256:	83 8f       	std	Z+27, r24	; 0x1b
read8():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:163
 *          selected register
 *  @return value from selected register
 */
uint8_t Adafruit_BMP280::read8(byte reg) {
  uint8_t buffer[1];
  if (i2c_dev) {
    2258:	80 91 0b 39 	lds	r24, 0x390B	; 0x80390b <bmp+0x2>
    225c:	90 91 0c 39 	lds	r25, 0x390C	; 0x80390c <bmp+0x3>
    2260:	00 97       	sbiw	r24, 0x00	; 0
    2262:	09 f4       	brne	.+2      	; 0x2266 <main+0x1c2>
    2264:	7c c1       	rjmp	.+760    	; 0x255e <main+0x4ba>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:164
    buffer[0] = uint8_t(reg);
    2266:	20 ed       	ldi	r18, 0xD0	; 208
    2268:	29 83       	std	Y+1, r18	; 0x01
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:165
    i2c_dev->write_then_read(buffer, 1, buffer, 1);
    226a:	21 e0       	ldi	r18, 0x01	; 1
    226c:	30 e0       	ldi	r19, 0x00	; 0
    226e:	ae 01       	movw	r20, r28
    2270:	4f 5f       	subi	r20, 0xFF	; 255
    2272:	5f 4f       	sbci	r21, 0xFF	; 255
    2274:	ba 01       	movw	r22, r20
    2276:	38 d8       	rcall	.-3984   	; 0x12e8 <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool) [clone .constprop.33]>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:170
  } else {
    buffer[0] = uint8_t(reg | 0x80);
    spi_dev->write_then_read(buffer, 1, buffer, 1);
  }
  return buffer[0];
    2278:	89 81       	ldd	r24, Y+1	; 0x01
begin():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:99
    // SPI mode
    if (!spi_dev->begin())
      return false;
  }

  if (read8(BMP280_REGISTER_CHIPID) != chipid)
    227a:	88 35       	cpi	r24, 0x58	; 88
    227c:	09 f0       	breq	.+2      	; 0x2280 <main+0x1dc>
    227e:	8f cf       	rjmp	.-226    	; 0x219e <main+0xfa>
readCoefficients():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:224

/*!
 *  @brief  Reads the factory-set coefficients
 */
void Adafruit_BMP280::readCoefficients() {
  _bmp280_calib.dig_T1 = read16_LE(BMP280_REGISTER_DIG_T1);
    2280:	88 e8       	ldi	r24, 0x88	; 136
    2282:	fb d8       	rcall	.-3594   	; 0x147a <Adafruit_BMP280::read16_LE(unsigned char) [clone .constprop.23]>
    2284:	80 93 1e 39 	sts	0x391E, r24	; 0x80391e <bmp+0x15>
    2288:	90 93 1f 39 	sts	0x391F, r25	; 0x80391f <bmp+0x16>
readS16_LE():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:200
 *   @brief  Reads a signed 16 bit value over I2C/SPI
 */
int16_t Adafruit_BMP280::readS16(byte reg) { return (int16_t)read16(reg); }

int16_t Adafruit_BMP280::readS16_LE(byte reg) {
  return (int16_t)read16_LE(reg);
    228c:	8a e8       	ldi	r24, 0x8A	; 138
    228e:	f5 d8       	rcall	.-3606   	; 0x147a <Adafruit_BMP280::read16_LE(unsigned char) [clone .constprop.23]>
readCoefficients():
    2290:	80 93 20 39 	sts	0x3920, r24	; 0x803920 <bmp+0x17>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:225
/*!
 *  @brief  Reads the factory-set coefficients
 */
void Adafruit_BMP280::readCoefficients() {
  _bmp280_calib.dig_T1 = read16_LE(BMP280_REGISTER_DIG_T1);
  _bmp280_calib.dig_T2 = readS16_LE(BMP280_REGISTER_DIG_T2);
    2294:	90 93 21 39 	sts	0x3921, r25	; 0x803921 <bmp+0x18>
readS16_LE():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:200
 *   @brief  Reads a signed 16 bit value over I2C/SPI
 */
int16_t Adafruit_BMP280::readS16(byte reg) { return (int16_t)read16(reg); }

int16_t Adafruit_BMP280::readS16_LE(byte reg) {
  return (int16_t)read16_LE(reg);
    2298:	8c e8       	ldi	r24, 0x8C	; 140
    229a:	ef d8       	rcall	.-3618   	; 0x147a <Adafruit_BMP280::read16_LE(unsigned char) [clone .constprop.23]>
readCoefficients():
    229c:	80 93 22 39 	sts	0x3922, r24	; 0x803922 <bmp+0x19>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:226
 *  @brief  Reads the factory-set coefficients
 */
void Adafruit_BMP280::readCoefficients() {
  _bmp280_calib.dig_T1 = read16_LE(BMP280_REGISTER_DIG_T1);
  _bmp280_calib.dig_T2 = readS16_LE(BMP280_REGISTER_DIG_T2);
  _bmp280_calib.dig_T3 = readS16_LE(BMP280_REGISTER_DIG_T3);
    22a0:	90 93 23 39 	sts	0x3923, r25	; 0x803923 <bmp+0x1a>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:228

  _bmp280_calib.dig_P1 = read16_LE(BMP280_REGISTER_DIG_P1);
    22a4:	8e e8       	ldi	r24, 0x8E	; 142
    22a6:	e9 d8       	rcall	.-3630   	; 0x147a <Adafruit_BMP280::read16_LE(unsigned char) [clone .constprop.23]>
    22a8:	80 93 24 39 	sts	0x3924, r24	; 0x803924 <bmp+0x1b>
    22ac:	90 93 25 39 	sts	0x3925, r25	; 0x803925 <bmp+0x1c>
readS16_LE():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:200
 *   @brief  Reads a signed 16 bit value over I2C/SPI
 */
int16_t Adafruit_BMP280::readS16(byte reg) { return (int16_t)read16(reg); }

int16_t Adafruit_BMP280::readS16_LE(byte reg) {
  return (int16_t)read16_LE(reg);
    22b0:	80 e9       	ldi	r24, 0x90	; 144
    22b2:	e3 d8       	rcall	.-3642   	; 0x147a <Adafruit_BMP280::read16_LE(unsigned char) [clone .constprop.23]>
readCoefficients():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:229
  _bmp280_calib.dig_T1 = read16_LE(BMP280_REGISTER_DIG_T1);
  _bmp280_calib.dig_T2 = readS16_LE(BMP280_REGISTER_DIG_T2);
  _bmp280_calib.dig_T3 = readS16_LE(BMP280_REGISTER_DIG_T3);

  _bmp280_calib.dig_P1 = read16_LE(BMP280_REGISTER_DIG_P1);
  _bmp280_calib.dig_P2 = readS16_LE(BMP280_REGISTER_DIG_P2);
    22b4:	80 93 26 39 	sts	0x3926, r24	; 0x803926 <bmp+0x1d>
    22b8:	90 93 27 39 	sts	0x3927, r25	; 0x803927 <bmp+0x1e>
readS16_LE():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:200
 *   @brief  Reads a signed 16 bit value over I2C/SPI
 */
int16_t Adafruit_BMP280::readS16(byte reg) { return (int16_t)read16(reg); }

int16_t Adafruit_BMP280::readS16_LE(byte reg) {
  return (int16_t)read16_LE(reg);
    22bc:	82 e9       	ldi	r24, 0x92	; 146
    22be:	dd d8       	rcall	.-3654   	; 0x147a <Adafruit_BMP280::read16_LE(unsigned char) [clone .constprop.23]>
readCoefficients():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:230
  _bmp280_calib.dig_T2 = readS16_LE(BMP280_REGISTER_DIG_T2);
  _bmp280_calib.dig_T3 = readS16_LE(BMP280_REGISTER_DIG_T3);

  _bmp280_calib.dig_P1 = read16_LE(BMP280_REGISTER_DIG_P1);
  _bmp280_calib.dig_P2 = readS16_LE(BMP280_REGISTER_DIG_P2);
  _bmp280_calib.dig_P3 = readS16_LE(BMP280_REGISTER_DIG_P3);
    22c0:	80 93 28 39 	sts	0x3928, r24	; 0x803928 <bmp+0x1f>
    22c4:	90 93 29 39 	sts	0x3929, r25	; 0x803929 <bmp+0x20>
readS16_LE():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:200
 *   @brief  Reads a signed 16 bit value over I2C/SPI
 */
int16_t Adafruit_BMP280::readS16(byte reg) { return (int16_t)read16(reg); }

int16_t Adafruit_BMP280::readS16_LE(byte reg) {
  return (int16_t)read16_LE(reg);
    22c8:	84 e9       	ldi	r24, 0x94	; 148
    22ca:	d7 d8       	rcall	.-3666   	; 0x147a <Adafruit_BMP280::read16_LE(unsigned char) [clone .constprop.23]>
readCoefficients():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:231
  _bmp280_calib.dig_T3 = readS16_LE(BMP280_REGISTER_DIG_T3);

  _bmp280_calib.dig_P1 = read16_LE(BMP280_REGISTER_DIG_P1);
  _bmp280_calib.dig_P2 = readS16_LE(BMP280_REGISTER_DIG_P2);
  _bmp280_calib.dig_P3 = readS16_LE(BMP280_REGISTER_DIG_P3);
  _bmp280_calib.dig_P4 = readS16_LE(BMP280_REGISTER_DIG_P4);
    22cc:	80 93 2a 39 	sts	0x392A, r24	; 0x80392a <bmp+0x21>
    22d0:	90 93 2b 39 	sts	0x392B, r25	; 0x80392b <bmp+0x22>
readS16_LE():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:200
 *   @brief  Reads a signed 16 bit value over I2C/SPI
 */
int16_t Adafruit_BMP280::readS16(byte reg) { return (int16_t)read16(reg); }

int16_t Adafruit_BMP280::readS16_LE(byte reg) {
  return (int16_t)read16_LE(reg);
    22d4:	86 e9       	ldi	r24, 0x96	; 150
    22d6:	d1 d8       	rcall	.-3678   	; 0x147a <Adafruit_BMP280::read16_LE(unsigned char) [clone .constprop.23]>
readCoefficients():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:232

  _bmp280_calib.dig_P1 = read16_LE(BMP280_REGISTER_DIG_P1);
  _bmp280_calib.dig_P2 = readS16_LE(BMP280_REGISTER_DIG_P2);
  _bmp280_calib.dig_P3 = readS16_LE(BMP280_REGISTER_DIG_P3);
  _bmp280_calib.dig_P4 = readS16_LE(BMP280_REGISTER_DIG_P4);
  _bmp280_calib.dig_P5 = readS16_LE(BMP280_REGISTER_DIG_P5);
    22d8:	80 93 2c 39 	sts	0x392C, r24	; 0x80392c <bmp+0x23>
    22dc:	90 93 2d 39 	sts	0x392D, r25	; 0x80392d <bmp+0x24>
readS16_LE():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:200
 *   @brief  Reads a signed 16 bit value over I2C/SPI
 */
int16_t Adafruit_BMP280::readS16(byte reg) { return (int16_t)read16(reg); }

int16_t Adafruit_BMP280::readS16_LE(byte reg) {
  return (int16_t)read16_LE(reg);
    22e0:	88 e9       	ldi	r24, 0x98	; 152
    22e2:	cb d8       	rcall	.-3690   	; 0x147a <Adafruit_BMP280::read16_LE(unsigned char) [clone .constprop.23]>
readCoefficients():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:233
  _bmp280_calib.dig_P1 = read16_LE(BMP280_REGISTER_DIG_P1);
  _bmp280_calib.dig_P2 = readS16_LE(BMP280_REGISTER_DIG_P2);
  _bmp280_calib.dig_P3 = readS16_LE(BMP280_REGISTER_DIG_P3);
  _bmp280_calib.dig_P4 = readS16_LE(BMP280_REGISTER_DIG_P4);
  _bmp280_calib.dig_P5 = readS16_LE(BMP280_REGISTER_DIG_P5);
  _bmp280_calib.dig_P6 = readS16_LE(BMP280_REGISTER_DIG_P6);
    22e4:	80 93 2e 39 	sts	0x392E, r24	; 0x80392e <bmp+0x25>
    22e8:	90 93 2f 39 	sts	0x392F, r25	; 0x80392f <bmp+0x26>
readS16_LE():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:200
 *   @brief  Reads a signed 16 bit value over I2C/SPI
 */
int16_t Adafruit_BMP280::readS16(byte reg) { return (int16_t)read16(reg); }

int16_t Adafruit_BMP280::readS16_LE(byte reg) {
  return (int16_t)read16_LE(reg);
    22ec:	8a e9       	ldi	r24, 0x9A	; 154
    22ee:	c5 d8       	rcall	.-3702   	; 0x147a <Adafruit_BMP280::read16_LE(unsigned char) [clone .constprop.23]>
readCoefficients():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:234
  _bmp280_calib.dig_P2 = readS16_LE(BMP280_REGISTER_DIG_P2);
  _bmp280_calib.dig_P3 = readS16_LE(BMP280_REGISTER_DIG_P3);
  _bmp280_calib.dig_P4 = readS16_LE(BMP280_REGISTER_DIG_P4);
  _bmp280_calib.dig_P5 = readS16_LE(BMP280_REGISTER_DIG_P5);
  _bmp280_calib.dig_P6 = readS16_LE(BMP280_REGISTER_DIG_P6);
  _bmp280_calib.dig_P7 = readS16_LE(BMP280_REGISTER_DIG_P7);
    22f0:	80 93 30 39 	sts	0x3930, r24	; 0x803930 <bmp+0x27>
    22f4:	90 93 31 39 	sts	0x3931, r25	; 0x803931 <bmp+0x28>
readS16_LE():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:200
 *   @brief  Reads a signed 16 bit value over I2C/SPI
 */
int16_t Adafruit_BMP280::readS16(byte reg) { return (int16_t)read16(reg); }

int16_t Adafruit_BMP280::readS16_LE(byte reg) {
  return (int16_t)read16_LE(reg);
    22f8:	8c e9       	ldi	r24, 0x9C	; 156
    22fa:	bf d8       	rcall	.-3714   	; 0x147a <Adafruit_BMP280::read16_LE(unsigned char) [clone .constprop.23]>
readCoefficients():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:235
  _bmp280_calib.dig_P3 = readS16_LE(BMP280_REGISTER_DIG_P3);
  _bmp280_calib.dig_P4 = readS16_LE(BMP280_REGISTER_DIG_P4);
  _bmp280_calib.dig_P5 = readS16_LE(BMP280_REGISTER_DIG_P5);
  _bmp280_calib.dig_P6 = readS16_LE(BMP280_REGISTER_DIG_P6);
  _bmp280_calib.dig_P7 = readS16_LE(BMP280_REGISTER_DIG_P7);
  _bmp280_calib.dig_P8 = readS16_LE(BMP280_REGISTER_DIG_P8);
    22fc:	80 93 32 39 	sts	0x3932, r24	; 0x803932 <bmp+0x29>
    2300:	90 93 33 39 	sts	0x3933, r25	; 0x803933 <bmp+0x2a>
readS16_LE():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:200
 *   @brief  Reads a signed 16 bit value over I2C/SPI
 */
int16_t Adafruit_BMP280::readS16(byte reg) { return (int16_t)read16(reg); }

int16_t Adafruit_BMP280::readS16_LE(byte reg) {
  return (int16_t)read16_LE(reg);
    2304:	8e e9       	ldi	r24, 0x9E	; 158
    2306:	b9 d8       	rcall	.-3726   	; 0x147a <Adafruit_BMP280::read16_LE(unsigned char) [clone .constprop.23]>
readCoefficients():
    2308:	80 93 34 39 	sts	0x3934, r24	; 0x803934 <bmp+0x2b>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:236
  _bmp280_calib.dig_P4 = readS16_LE(BMP280_REGISTER_DIG_P4);
  _bmp280_calib.dig_P5 = readS16_LE(BMP280_REGISTER_DIG_P5);
  _bmp280_calib.dig_P6 = readS16_LE(BMP280_REGISTER_DIG_P6);
  _bmp280_calib.dig_P7 = readS16_LE(BMP280_REGISTER_DIG_P7);
  _bmp280_calib.dig_P8 = readS16_LE(BMP280_REGISTER_DIG_P8);
  _bmp280_calib.dig_P9 = readS16_LE(BMP280_REGISTER_DIG_P9);
    230c:	90 93 35 39 	sts	0x3935, r25	; 0x803935 <bmp+0x2c>
begin():
    2310:	30 e0       	ldi	r19, 0x00	; 0
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:104
  if (read8(BMP280_REGISTER_CHIPID) != chipid)
    return false;

  readCoefficients();
  // write8(BMP280_REGISTER_CONTROL, 0x3F); /* needed? */
  setSampling();
    2312:	20 e0       	ldi	r18, 0x00	; 0
    2314:	50 e0       	ldi	r21, 0x00	; 0
    2316:	40 e0       	ldi	r20, 0x00	; 0
    2318:	65 e0       	ldi	r22, 0x05	; 5
    231a:	70 e0       	ldi	r23, 0x00	; 0
    231c:	85 e0       	ldi	r24, 0x05	; 5
    231e:	90 e0       	ldi	r25, 0x00	; 0
    2320:	0e 94 2f 09 	call	0x125e	; 0x125e <Adafruit_BMP280::setSampling(Adafruit_BMP280::sensor_mode, Adafruit_BMP280::sensor_sampling, Adafruit_BMP280::sensor_sampling, Adafruit_BMP280::sensor_filter, Adafruit_BMP280::standby_duration) [clone .constprop.27]>
    2324:	64 e6       	ldi	r22, 0x64	; 100
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:105
  delay(100);
    2326:	70 e0       	ldi	r23, 0x00	; 0
    2328:	80 e0       	ldi	r24, 0x00	; 0
    232a:	90 e0       	ldi	r25, 0x00	; 0
    232c:	0e 94 37 02 	call	0x46e	; 0x46e <delay>
setup():
g:\Studia\PUT Rocket LAB\altimetr\Altimetr_SPI/Altimetr_SPI.ino:55
  RMS Noise[cm]:  6.4
  3 wire SPI:     false -> 0xF5[0] -> 0
  IIR filter:     4 -> 0xF5[4:2] -> 010?
  standby [ms]:   125 -> 0xF5 [7:5] -> 010
  */
  bmp.setSampling(Adafruit_BMP280::MODE_NORMAL,     /* Operating Mode. */
    2330:	22 e0       	ldi	r18, 0x02	; 2
    2332:	30 e0       	ldi	r19, 0x00	; 0
    2334:	42 e0       	ldi	r20, 0x02	; 2
    2336:	50 e0       	ldi	r21, 0x00	; 0
    2338:	63 e0       	ldi	r22, 0x03	; 3
    233a:	70 e0       	ldi	r23, 0x00	; 0
    233c:	81 e0       	ldi	r24, 0x01	; 1
    233e:	90 e0       	ldi	r25, 0x00	; 0
    2340:	0e 94 2f 09 	call	0x125e	; 0x125e <Adafruit_BMP280::setSampling(Adafruit_BMP280::sensor_mode, Adafruit_BMP280::sensor_sampling, Adafruit_BMP280::sensor_sampling, Adafruit_BMP280::sensor_filter, Adafruit_BMP280::standby_duration) [clone .constprop.27]>
readAltitude():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:309
 * @return The approximate altitude above sea level in meters.
 */
float Adafruit_BMP280::readAltitude(float seaLevelhPa) {
  float altitude;

  float pressure = readPressure(); // in Si units for Pascal
    2344:	89 e0       	ldi	r24, 0x09	; 9
    2346:	99 e3       	ldi	r25, 0x39	; 57
    2348:	66 d9       	rcall	.-3380   	; 0x1616 <Adafruit_BMP280::readPressure()>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:310
  pressure /= 100;
    234a:	20 e0       	ldi	r18, 0x00	; 0
    234c:	30 e0       	ldi	r19, 0x00	; 0
    234e:	48 ec       	ldi	r20, 0xC8	; 200
    2350:	52 e4       	ldi	r21, 0x42	; 66
    2352:	f1 d1       	rcall	.+994    	; 0x2736 <__divsf3>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:312

  altitude = 44330 * (1.0 - pow(pressure / seaLevelhPa, 0.1903));
    2354:	20 e0       	ldi	r18, 0x00	; 0
    2356:	30 e0       	ldi	r19, 0x00	; 0
    2358:	4f e7       	ldi	r20, 0x7F	; 127
    235a:	54 e4       	ldi	r21, 0x44	; 68
    235c:	ec d1       	rcall	.+984    	; 0x2736 <__divsf3>
    235e:	21 e0       	ldi	r18, 0x01	; 1
    2360:	3e ed       	ldi	r19, 0xDE	; 222
    2362:	42 e4       	ldi	r20, 0x42	; 66
    2364:	5e e3       	ldi	r21, 0x3E	; 62
    2366:	e6 d3       	rcall	.+1996   	; 0x2b34 <pow>
    2368:	9b 01       	movw	r18, r22
    236a:	ac 01       	movw	r20, r24
    236c:	60 e0       	ldi	r22, 0x00	; 0
    236e:	70 e0       	ldi	r23, 0x00	; 0
    2370:	80 e8       	ldi	r24, 0x80	; 128
    2372:	9f e3       	ldi	r25, 0x3F	; 63
    2374:	77 d1       	rcall	.+750    	; 0x2664 <__subsf3>
    2376:	20 e0       	ldi	r18, 0x00	; 0
    2378:	3a e2       	ldi	r19, 0x2A	; 42
    237a:	4d e2       	ldi	r20, 0x2D	; 45
    237c:	57 e4       	ldi	r21, 0x47	; 71
    237e:	77 d3       	rcall	.+1774   	; 0x2a6e <__mulsf3>
setup():
    2380:	60 93 0e 38 	sts	0x380E, r22	; 0x80380e <initialHight>
g:\Studia\PUT Rocket LAB\altimetr\Altimetr_SPI/Altimetr_SPI.ino:61
                  Adafruit_BMP280::SAMPLING_X1,     /* Temp. oversampling */
                  Adafruit_BMP280::SAMPLING_X4,     /* Pressure oversampling */
                  Adafruit_BMP280::FILTER_X4,       /* Filtering. */
                  Adafruit_BMP280::STANDBY_MS_125); /* Standby time. */

  initialHight = bmp.readAltitude(seaLevelhPa);
    2384:	70 93 0f 38 	sts	0x380F, r23	; 0x80380f <initialHight+0x1>
    2388:	80 93 10 38 	sts	0x3810, r24	; 0x803810 <initialHight+0x2>
    238c:	90 93 11 38 	sts	0x3811, r25	; 0x803811 <initialHight+0x3>
    2390:	8a e1       	ldi	r24, 0x1A	; 26
    2392:	98 e3       	ldi	r25, 0x38	; 56
g:\Studia\PUT Rocket LAB\altimetr\Altimetr_SPI/Altimetr_SPI.ino:62
  if (Serial.available())
    2394:	0e 94 47 01 	call	0x28e	; 0x28e <UartClass::available()>
    2398:	89 2b       	or	r24, r25
    239a:	71 f0       	breq	.+28     	; 0x23b8 <main+0x314>
write():
    239c:	8a e4       	ldi	r24, 0x4A	; 74
    239e:	94 eb       	ldi	r25, 0xB4	; 180
    23a0:	0e 94 40 07 	call	0xe80	; 0xe80 <Print::write(char const*) [clone .part.2] [clone .constprop.52]>
setup():
    23a4:	60 91 0e 38 	lds	r22, 0x380E	; 0x80380e <initialHight>
g:\Studia\PUT Rocket LAB\altimetr\Altimetr_SPI/Altimetr_SPI.ino:65
  {
    Serial.print("INITIAL HIGHT:\t");
    Serial.println(initialHight);
    23a8:	70 91 0f 38 	lds	r23, 0x380F	; 0x80380f <initialHight+0x1>
    23ac:	80 91 10 38 	lds	r24, 0x3810	; 0x803810 <initialHight+0x2>
    23b0:	90 91 11 38 	lds	r25, 0x3811	; 0x803811 <initialHight+0x3>
    23b4:	0e 94 89 07 	call	0xf12	; 0xf12 <Print::println(double, int) [clone .constprop.42]>
millis():
    23b8:	8f b7       	in	r24, 0x3f	; 63
    23ba:	f8 94       	cli
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:226


unsigned long millis() {
  // return timer_overflow_count; // for debugging timekeeping issues where these variables are out of scope from the sketch
  unsigned long m;
  uint8_t oldSREG = SREG;
    23bc:	80 90 06 38 	lds	r8, 0x3806	; 0x803806 <__data_end>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:255

     * Not only that - but a dedicated optimizing assembly programmer could probably ensure that instead of the >> 7 (a little mini loop)
     * that was implemented leftshifting it once, retaining the carried bit, and
     */
  #else
    m = timer_millis;
    23c0:	90 90 07 38 	lds	r9, 0x3807	; 0x803807 <__data_end+0x1>
    23c4:	a0 90 08 38 	lds	r10, 0x3808	; 0x803808 <__data_end+0x2>
    23c8:	b0 90 09 38 	lds	r11, 0x3809	; 0x803809 <__data_end+0x3>
    23cc:	8f bf       	out	0x3f, r24	; 63
loop():
    23ce:	94 01       	movw	r18, r8
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:256
    SREG = oldSREG;
    23d0:	a5 01       	movw	r20, r10
g:\Studia\PUT Rocket LAB\altimetr\Altimetr_SPI/Altimetr_SPI.ino:71
  }
}

void loop()
{
  if (millis() - t > TIME_INTERVAL)
    23d2:	60 e0       	ldi	r22, 0x00	; 0
    23d4:	70 e0       	ldi	r23, 0x00	; 0
    23d6:	80 e0       	ldi	r24, 0x00	; 0
    23d8:	90 e0       	ldi	r25, 0x00	; 0
    23da:	a0 90 12 38 	lds	r10, 0x3812	; 0x803812 <t>
    23de:	b0 90 13 38 	lds	r11, 0x3813	; 0x803813 <t+0x1>
    23e2:	c0 90 14 38 	lds	r12, 0x3814	; 0x803814 <t+0x2>
    23e6:	d0 90 15 38 	lds	r13, 0x3815	; 0x803815 <t+0x3>
    23ea:	e0 90 16 38 	lds	r14, 0x3816	; 0x803816 <t+0x4>
    23ee:	f0 90 17 38 	lds	r15, 0x3817	; 0x803817 <t+0x5>
    23f2:	00 91 18 38 	lds	r16, 0x3818	; 0x803818 <t+0x6>
    23f6:	10 91 19 38 	lds	r17, 0x3819	; 0x803819 <t+0x7>
    23fa:	6e d6       	rcall	.+3292   	; 0x30d8 <__subdi3>
    23fc:	28 3e       	cpi	r18, 0xE8	; 232
    23fe:	33 40       	sbci	r19, 0x03	; 3
    2400:	41 05       	cpc	r20, r1
    2402:	51 05       	cpc	r21, r1
    2404:	61 05       	cpc	r22, r1
    2406:	71 05       	cpc	r23, r1
    2408:	81 05       	cpc	r24, r1
    240a:	91 05       	cpc	r25, r1
    240c:	a9 f2       	breq	.-86     	; 0x23b8 <main+0x314>
    240e:	a0 f2       	brcs	.-88     	; 0x23b8 <main+0x314>
millis():
    2410:	8f b7       	in	r24, 0x3f	; 63
    2412:	f8 94       	cli
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:226


unsigned long millis() {
  // return timer_overflow_count; // for debugging timekeeping issues where these variables are out of scope from the sketch
  unsigned long m;
  uint8_t oldSREG = SREG;
    2414:	00 91 06 38 	lds	r16, 0x3806	; 0x803806 <__data_end>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:255

     * Not only that - but a dedicated optimizing assembly programmer could probably ensure that instead of the >> 7 (a little mini loop)
     * that was implemented leftshifting it once, retaining the carried bit, and
     */
  #else
    m = timer_millis;
    2418:	10 91 07 38 	lds	r17, 0x3807	; 0x803807 <__data_end+0x1>
    241c:	20 91 08 38 	lds	r18, 0x3808	; 0x803808 <__data_end+0x2>
    2420:	30 91 09 38 	lds	r19, 0x3809	; 0x803809 <__data_end+0x3>
    2424:	8f bf       	out	0x3f, r24	; 63
loop():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring.c:256
    SREG = oldSREG;
    2426:	00 93 12 38 	sts	0x3812, r16	; 0x803812 <t>
g:\Studia\PUT Rocket LAB\altimetr\Altimetr_SPI/Altimetr_SPI.ino:73
  {
    t = millis();
    242a:	10 93 13 38 	sts	0x3813, r17	; 0x803813 <t+0x1>
    242e:	20 93 14 38 	sts	0x3814, r18	; 0x803814 <t+0x2>
    2432:	30 93 15 38 	sts	0x3815, r19	; 0x803815 <t+0x3>
    2436:	10 92 16 38 	sts	0x3816, r1	; 0x803816 <t+0x4>
    243a:	10 92 17 38 	sts	0x3817, r1	; 0x803817 <t+0x5>
    243e:	10 92 18 38 	sts	0x3818, r1	; 0x803818 <t+0x6>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:309
 * @return The approximate altitude above sea level in meters.
 */
float Adafruit_BMP280::readAltitude(float seaLevelhPa) {
  float altitude;

  float pressure = readPressure(); // in Si units for Pascal
    2442:	10 92 19 38 	sts	0x3819, r1	; 0x803819 <t+0x7>
readAltitude():
    2446:	89 e0       	ldi	r24, 0x09	; 9
    2448:	99 e3       	ldi	r25, 0x39	; 57
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:310
  pressure /= 100;
    244a:	e5 d8       	rcall	.-3638   	; 0x1616 <Adafruit_BMP280::readPressure()>
    244c:	20 e0       	ldi	r18, 0x00	; 0
    244e:	30 e0       	ldi	r19, 0x00	; 0
    2450:	48 ec       	ldi	r20, 0xC8	; 200
    2452:	52 e4       	ldi	r21, 0x42	; 66
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:312

  altitude = 44330 * (1.0 - pow(pressure / seaLevelhPa, 0.1903));
    2454:	70 d1       	rcall	.+736    	; 0x2736 <__divsf3>
    2456:	20 e0       	ldi	r18, 0x00	; 0
    2458:	30 e0       	ldi	r19, 0x00	; 0
    245a:	4f e7       	ldi	r20, 0x7F	; 127
    245c:	54 e4       	ldi	r21, 0x44	; 68
    245e:	6b d1       	rcall	.+726    	; 0x2736 <__divsf3>
    2460:	21 e0       	ldi	r18, 0x01	; 1
    2462:	3e ed       	ldi	r19, 0xDE	; 222
    2464:	42 e4       	ldi	r20, 0x42	; 66
    2466:	5e e3       	ldi	r21, 0x3E	; 62
    2468:	65 d3       	rcall	.+1738   	; 0x2b34 <pow>
    246a:	9b 01       	movw	r18, r22
    246c:	ac 01       	movw	r20, r24
    246e:	60 e0       	ldi	r22, 0x00	; 0
    2470:	70 e0       	ldi	r23, 0x00	; 0
    2472:	80 e8       	ldi	r24, 0x80	; 128
    2474:	9f e3       	ldi	r25, 0x3F	; 63
    2476:	f6 d0       	rcall	.+492    	; 0x2664 <__subsf3>
    2478:	20 e0       	ldi	r18, 0x00	; 0
    247a:	3a e2       	ldi	r19, 0x2A	; 42
    247c:	4d e2       	ldi	r20, 0x2D	; 45
    247e:	57 e4       	ldi	r21, 0x47	; 71
    2480:	f6 d2       	rcall	.+1516   	; 0x2a6e <__mulsf3>
loop():
    2482:	20 91 0e 38 	lds	r18, 0x380E	; 0x80380e <initialHight>
g:\Studia\PUT Rocket LAB\altimetr\Altimetr_SPI/Altimetr_SPI.ino:74
    float hight = bmp.readAltitude(seaLevelhPa) - initialHight;
    2486:	30 91 0f 38 	lds	r19, 0x380F	; 0x80380f <initialHight+0x1>
    248a:	40 91 10 38 	lds	r20, 0x3810	; 0x803810 <initialHight+0x2>
    248e:	50 91 11 38 	lds	r21, 0x3811	; 0x803811 <initialHight+0x3>
    2492:	e8 d0       	rcall	.+464    	; 0x2664 <__subsf3>
    2494:	6b 01       	movw	r12, r22
    2496:	7c 01       	movw	r14, r24
    2498:	20 91 0a 38 	lds	r18, 0x380A	; 0x80380a <maxHightRAM>
g:\Studia\PUT Rocket LAB\altimetr\Altimetr_SPI/Altimetr_SPI.ino:75
    if (hight > maxHightRAM)
    249c:	30 91 0b 38 	lds	r19, 0x380B	; 0x80380b <maxHightRAM+0x1>
    24a0:	40 91 0c 38 	lds	r20, 0x380C	; 0x80380c <maxHightRAM+0x2>
    24a4:	50 91 0d 38 	lds	r21, 0x380D	; 0x80380d <maxHightRAM+0x3>
    24a8:	de d2       	rcall	.+1468   	; 0x2a66 <__gesf2>
    24aa:	18 16       	cp	r1, r24
    24ac:	44 f4       	brge	.+16     	; 0x24be <main+0x41a>
    24ae:	c0 92 0a 38 	sts	0x380A, r12	; 0x80380a <maxHightRAM>
    24b2:	d0 92 0b 38 	sts	0x380B, r13	; 0x80380b <maxHightRAM+0x1>
g:\Studia\PUT Rocket LAB\altimetr\Altimetr_SPI/Altimetr_SPI.ino:77
    {
      maxHightRAM = hight;
    24b6:	e0 92 0c 38 	sts	0x380C, r14	; 0x80380c <maxHightRAM+0x2>
    24ba:	f0 92 0d 38 	sts	0x380D, r15	; 0x80380d <maxHightRAM+0x3>
    24be:	8a e1       	ldi	r24, 0x1A	; 26
    24c0:	98 e3       	ldi	r25, 0x38	; 56
g:\Studia\PUT Rocket LAB\altimetr\Altimetr_SPI/Altimetr_SPI.ino:84
    // If the rocket has already reached the highest point write the max hight to flash
    else
    {
      // eeprom_update_float(&maxHightEEM, maxHightRAM);
    }
    if (Serial.available())
    24c2:	0e 94 47 01 	call	0x28e	; 0x28e <UartClass::available()>
    24c6:	89 2b       	or	r24, r25
    24c8:	41 f0       	breq	.+16     	; 0x24da <main+0x436>
write():
    24ca:	8e e5       	ldi	r24, 0x5E	; 94
    24cc:	94 eb       	ldi	r25, 0xB4	; 180
    24ce:	0e 94 40 07 	call	0xe80	; 0xe80 <Print::write(char const*) [clone .part.2] [clone .constprop.52]>
loop():
    24d2:	c7 01       	movw	r24, r14
    24d4:	b6 01       	movw	r22, r12
g:\Studia\PUT Rocket LAB\altimetr\Altimetr_SPI/Altimetr_SPI.ino:87
    {
      Serial.print("Hight:\t");
      Serial.println(hight);
    24d6:	0e 94 89 07 	call	0xf12	; 0xf12 <Print::println(double, int) [clone .constprop.42]>
    24da:	8a e1       	ldi	r24, 0x1A	; 26
    24dc:	98 e3       	ldi	r25, 0x38	; 56
g:\Studia\PUT Rocket LAB\altimetr\Altimetr_SPI/Altimetr_SPI.ino:90
    }

    if (Serial.available() && !digitalRead(SEND_DATA_UART_EN))
    24de:	0e 94 47 01 	call	0x28e	; 0x28e <UartClass::available()>
    24e2:	89 2b       	or	r24, r25
    24e4:	09 f4       	brne	.+2      	; 0x24e8 <main+0x444>
    24e6:	68 cf       	rjmp	.-304    	; 0x23b8 <main+0x314>
digitalRead():
    24e8:	80 91 08 04 	lds	r24, 0x0408	; 0x800408 <vtable for Adafruit_BMP280_Temp+0x7f4fea>
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/wiring_digital.c:385

  /* Get port and check valid port */
  PORT_t *port = digitalPinToPortStruct(pin);

  /* Read pin value from PORTx.IN register */
  if (port->IN & bit_mask) {
    24ec:	87 fd       	sbrc	r24, 7
    24ee:	64 cf       	rjmp	.-312    	; 0x23b8 <main+0x314>
loop():
    24f0:	80 e0       	ldi	r24, 0x00	; 0
    24f2:	90 e0       	ldi	r25, 0x00	; 0
g:\Studia\PUT Rocket LAB\altimetr\Altimetr_SPI/Altimetr_SPI.ino:92
    {
      float readHight = eeprom_read_float(&maxHightEEM);
    24f4:	78 d0       	rcall	.+240    	; 0x25e6 <eeprom_read_dword>
    24f6:	6b 01       	movw	r12, r22
    24f8:	7c 01       	movw	r14, r24
write():
    24fa:	8a e5       	ldi	r24, 0x5A	; 90
    24fc:	94 eb       	ldi	r25, 0xB4	; 180
    24fe:	0e 94 40 07 	call	0xe80	; 0xe80 <Print::write(char const*) [clone .part.2] [clone .constprop.52]>
loop():
    2502:	c7 01       	movw	r24, r14
    2504:	b6 01       	movw	r22, r12
    2506:	56 cf       	rjmp	.-340    	; 0x23b4 <main+0x310>
begin():
g:\Studia\PUT Rocket LAB\altimetr\Altimetr_SPI/Altimetr_SPI.ino:94
      Serial.print("Max Hight:\t");
      Serial.println(readHight);
    2508:	61 e0       	ldi	r22, 0x01	; 1
    250a:	f8 01       	movw	r30, r16
    250c:	84 85       	ldd	r24, Z+12	; 0x0c
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:98
  digitalWrite(_cs, HIGH);

  if (_spi) { // hardware SPI
    _spi->begin();
  } else {
    pinMode(_sck, OUTPUT);
    250e:	0e 94 5e 06 	call	0xcbc	; 0xcbc <pinMode>
    2512:	d8 01       	movw	r26, r16
    2514:	1a 96       	adiw	r26, 0x0a	; 10
    2516:	8c 91       	ld	r24, X
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:100

    if ((_dataMode == SPI_MODE0) || (_dataMode == SPI_MODE1)) {
    2518:	1a 97       	sbiw	r26, 0x0a	; 10
    251a:	82 30       	cpi	r24, 0x02	; 2
    251c:	e0 f4       	brcc	.+56     	; 0x2556 <main+0x4b2>
    251e:	60 e0       	ldi	r22, 0x00	; 0
    2520:	1c 96       	adiw	r26, 0x0c	; 12
    2522:	8c 91       	ld	r24, X
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:102
      // idle low on mode 0 and 1
      digitalWrite(_sck, LOW);
    2524:	0e 94 db 05 	call	0xbb6	; 0xbb6 <digitalWrite>
    2528:	d8 01       	movw	r26, r16
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:105
    } else {
      // idle high on mode 2 or 3
      digitalWrite(_sck, HIGH);
    252a:	1d 96       	adiw	r26, 0x0d	; 13
    252c:	8c 91       	ld	r24, X
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:107
    }
    if (_mosi != -1) {
    252e:	8f 3f       	cpi	r24, 0xFF	; 255
    2530:	41 f0       	breq	.+16     	; 0x2542 <main+0x49e>
    2532:	61 e0       	ldi	r22, 0x01	; 1
    2534:	0e 94 5e 06 	call	0xcbc	; 0xcbc <pinMode>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:108
      pinMode(_mosi, OUTPUT);
    2538:	61 e0       	ldi	r22, 0x01	; 1
    253a:	f8 01       	movw	r30, r16
    253c:	85 85       	ldd	r24, Z+13	; 0x0d
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:109
      digitalWrite(_mosi, HIGH);
    253e:	0e 94 db 05 	call	0xbb6	; 0xbb6 <digitalWrite>
    2542:	d8 01       	movw	r26, r16
    2544:	1e 96       	adiw	r26, 0x0e	; 14
    2546:	8c 91       	ld	r24, X
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:111
    }
    if (_miso != -1) {
    2548:	8f 3f       	cpi	r24, 0xFF	; 255
    254a:	09 f4       	brne	.+2      	; 0x254e <main+0x4aa>
    254c:	82 ce       	rjmp	.-764    	; 0x2252 <main+0x1ae>
    254e:	60 e0       	ldi	r22, 0x00	; 0
    2550:	0e 94 5e 06 	call	0xcbc	; 0xcbc <pinMode>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:112
      pinMode(_miso, INPUT);
    2554:	7e ce       	rjmp	.-772    	; 0x2252 <main+0x1ae>
    2556:	61 e0       	ldi	r22, 0x01	; 1
    2558:	f8 01       	movw	r30, r16
    255a:	84 85       	ldd	r24, Z+12	; 0x0c
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:105
    if ((_dataMode == SPI_MODE0) || (_dataMode == SPI_MODE1)) {
      // idle low on mode 0 and 1
      digitalWrite(_sck, LOW);
    } else {
      // idle high on mode 2 or 3
      digitalWrite(_sck, HIGH);
    255c:	e3 cf       	rjmp	.-58     	; 0x2524 <main+0x480>
read8():
    255e:	80 ed       	ldi	r24, 0xD0	; 208
    2560:	89 83       	std	Y+1, r24	; 0x01
    2562:	21 e0       	ldi	r18, 0x01	; 1
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:167
  uint8_t buffer[1];
  if (i2c_dev) {
    buffer[0] = uint8_t(reg);
    i2c_dev->write_then_read(buffer, 1, buffer, 1);
  } else {
    buffer[0] = uint8_t(reg | 0x80);
    2564:	30 e0       	ldi	r19, 0x00	; 0
    2566:	ae 01       	movw	r20, r28
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:168
    spi_dev->write_then_read(buffer, 1, buffer, 1);
    2568:	4f 5f       	subi	r20, 0xFF	; 255
    256a:	5f 4f       	sbci	r21, 0xFF	; 255
    256c:	ba 01       	movw	r22, r20
    256e:	80 91 0d 39 	lds	r24, 0x390D	; 0x80390d <bmp+0x4>
    2572:	90 91 0e 39 	lds	r25, 0x390E	; 0x80390e <bmp+0x5>
    2576:	0e 94 24 06 	call	0xc48	; 0xc48 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char) [clone .constprop.36]>
    257a:	7e ce       	rjmp	.-772    	; 0x2278 <main+0x1d4>

0000257c <_GLOBAL__sub_D_bmp>:
_GLOBAL__sub_D_bmp():
    257c:	cf 93       	push	r28
    257e:	df 93       	push	r29
__base_dtor ():
    2580:	c0 91 0d 39 	lds	r28, 0x390D	; 0x80390d <bmp+0x4>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:37
  temp_sensor = new Adafruit_BMP280_Temp(this);
  pressure_sensor = new Adafruit_BMP280_Pressure(this);
}

Adafruit_BMP280::~Adafruit_BMP280(void) {
  if (spi_dev)
    2584:	d0 91 0e 39 	lds	r29, 0x390E	; 0x80390e <bmp+0x5>
    2588:	20 97       	sbiw	r28, 0x00	; 0
    258a:	39 f0       	breq	.+14     	; 0x259a <_GLOBAL__sub_D_bmp+0x1e>
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:80

/*!
 *    @brief  Release memory allocated in constructors
 */
Adafruit_SPIDevice::~Adafruit_SPIDevice() {
  if (_spiSetting) {
    258c:	8a 81       	ldd	r24, Y+2	; 0x02
    258e:	9b 81       	ldd	r25, Y+3	; 0x03
    2590:	00 97       	sbiw	r24, 0x00	; 0
    2592:	09 f0       	breq	.+2      	; 0x2596 <_GLOBAL__sub_D_bmp+0x1a>
operator delete():
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/new.cpp:63
// Since C++14, also need two more delete variants...
// Note thnat this CAN break code that compiled amd worked in C++11.
#if (__cpp_sized_deallocation >= 201309L)
  void  operator delete  (void* ptr, size_t size) noexcept {
    (void) size;
    free(ptr);
    2594:	67 d6       	rcall	.+3278   	; 0x3264 <free>
    2596:	ce 01       	movw	r24, r28
    2598:	65 d6       	rcall	.+3274   	; 0x3264 <free>
__base_dtor ():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:39
    delete spi_dev;
  if (i2c_dev)
    259a:	80 91 0b 39 	lds	r24, 0x390B	; 0x80390b <bmp+0x2>
    259e:	90 91 0c 39 	lds	r25, 0x390C	; 0x80390c <bmp+0x3>
    25a2:	00 97       	sbiw	r24, 0x00	; 0
C:\Users\krzys\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.5.10\cores\megatinycore/new.cpp:63
    25a4:	09 f0       	breq	.+2      	; 0x25a8 <_GLOBAL__sub_D_bmp+0x2c>
operator delete():
    25a6:	5e d6       	rcall	.+3260   	; 0x3264 <free>
__base_dtor ():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:41
    delete i2c_dev;
  delete temp_sensor;
    25a8:	80 91 0f 39 	lds	r24, 0x390F	; 0x80390f <bmp+0x6>
    25ac:	90 91 10 39 	lds	r25, 0x3910	; 0x803910 <bmp+0x7>
    25b0:	00 97       	sbiw	r24, 0x00	; 0
    25b2:	39 f0       	breq	.+14     	; 0x25c2 <_GLOBAL__sub_D_bmp+0x46>
    25b4:	dc 01       	movw	r26, r24
    25b6:	ed 91       	ld	r30, X+
    25b8:	fc 91       	ld	r31, X
    25ba:	02 80       	ldd	r0, Z+2	; 0x02
    25bc:	f3 81       	ldd	r31, Z+3	; 0x03
    25be:	e0 2d       	mov	r30, r0
    25c0:	09 95       	icall
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:42
  delete pressure_sensor;
    25c2:	80 91 11 39 	lds	r24, 0x3911	; 0x803911 <bmp+0x8>
    25c6:	90 91 12 39 	lds	r25, 0x3912	; 0x803912 <bmp+0x9>
    25ca:	00 97       	sbiw	r24, 0x00	; 0
    25cc:	49 f0       	breq	.+18     	; 0x25e0 <_GLOBAL__sub_D_bmp+0x64>
    25ce:	dc 01       	movw	r26, r24
    25d0:	ed 91       	ld	r30, X+
    25d2:	fc 91       	ld	r31, X
    25d4:	02 80       	ldd	r0, Z+2	; 0x02
    25d6:	f3 81       	ldd	r31, Z+3	; 0x03
    25d8:	e0 2d       	mov	r30, r0
_GLOBAL__sub_D_bmp():
g:\Studia\PUT Rocket LAB\altimetr\Altimetr_SPI/Altimetr_SPI.ino:97
    }
  }
}
    25da:	df 91       	pop	r29
    25dc:	cf 91       	pop	r28
__base_dtor ():
C:\Users\krzys\OneDrive\Dokumenty\Arduino\libraries\Adafruit_BMP280_Library/Adafruit_BMP280.cpp:42
    25de:	09 94       	ijmp
_GLOBAL__sub_D_bmp():
g:\Studia\PUT Rocket LAB\altimetr\Altimetr_SPI/Altimetr_SPI.ino:97
    25e0:	df 91       	pop	r29
    25e2:	cf 91       	pop	r28
    25e4:	08 95       	ret

000025e6 <eeprom_read_dword>:
eeprom_read_dword():
/home/toolsbuild/workspace/avr8-devices-pack/src/avr-libc/avr/lib/avrxmega3/attiny1624/../../../../libc/misc/eerd_dword.S:50
    25e6:	09 d0       	rcall	.+18     	; 0x25fa <eeprom_mapen>
/home/toolsbuild/workspace/avr8-devices-pack/src/avr-libc/avr/lib/avrxmega3/attiny1624/../../../../libc/misc/eerd_dword.S:51
    25e8:	60 81       	ld	r22, Z
/home/toolsbuild/workspace/avr8-devices-pack/src/avr-libc/avr/lib/avrxmega3/attiny1624/../../../../libc/misc/eerd_dword.S:52
    25ea:	71 81       	ldd	r23, Z+1	; 0x01
/home/toolsbuild/workspace/avr8-devices-pack/src/avr-libc/avr/lib/avrxmega3/attiny1624/../../../../libc/misc/eerd_dword.S:53
    25ec:	82 81       	ldd	r24, Z+2	; 0x02
/home/toolsbuild/workspace/avr8-devices-pack/src/avr-libc/avr/lib/avrxmega3/attiny1624/../../../../libc/misc/eerd_dword.S:54
    25ee:	93 81       	ldd	r25, Z+3	; 0x03
/home/toolsbuild/workspace/avr8-devices-pack/src/avr-libc/avr/lib/avrxmega3/attiny1624/../../../../libc/misc/eerd_dword.S:55
    25f0:	08 95       	ret

000025f2 <eeprom_read_byte>:
eeprom_read_byte():
/home/toolsbuild/workspace/avr8-devices-pack/src/avr-libc/avr/lib/avrxmega3/attiny1624/../../../../libc/misc/eerd_byte.S:51
    25f2:	03 d0       	rcall	.+6      	; 0x25fa <eeprom_mapen>
/home/toolsbuild/workspace/avr8-devices-pack/src/avr-libc/avr/lib/avrxmega3/attiny1624/../../../../libc/misc/eerd_byte.S:52
    25f4:	80 81       	ld	r24, Z
/home/toolsbuild/workspace/avr8-devices-pack/src/avr-libc/avr/lib/avrxmega3/attiny1624/../../../../libc/misc/eerd_byte.S:53
    25f6:	99 27       	eor	r25, r25
/home/toolsbuild/workspace/avr8-devices-pack/src/avr-libc/avr/lib/avrxmega3/attiny1624/../../../../libc/misc/eerd_byte.S:54
    25f8:	08 95       	ret

000025fa <eeprom_mapen>:
/home/toolsbuild/workspace/avr8-devices-pack/src/avr-libc/avr/lib/avrxmega3/attiny1624/../../../../libc/misc/eerd_byte.S:83
    25fa:	fc 01       	movw	r30, r24
/home/toolsbuild/workspace/avr8-devices-pack/src/avr-libc/avr/lib/avrxmega3/attiny1624/../../../../libc/misc/eerd_byte.S:84
    25fc:	e0 50       	subi	r30, 0x00	; 0
/home/toolsbuild/workspace/avr8-devices-pack/src/avr-libc/avr/lib/avrxmega3/attiny1624/../../../../libc/misc/eerd_byte.S:85
    25fe:	fc 4e       	sbci	r31, 0xEC	; 236
/home/toolsbuild/workspace/avr8-devices-pack/src/avr-libc/avr/lib/avrxmega3/attiny1624/../../../../libc/misc/eerd_byte.S:87
    2600:	08 95       	ret

00002602 <__prologue_saves__>:
__prologue_saves__():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2169
    2602:	2f 92       	push	r2
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2170
    2604:	3f 92       	push	r3
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2171
    2606:	4f 92       	push	r4
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2172
    2608:	5f 92       	push	r5
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2173
    260a:	6f 92       	push	r6
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2174
    260c:	7f 92       	push	r7
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2175
    260e:	8f 92       	push	r8
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2176
    2610:	9f 92       	push	r9
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2177
    2612:	af 92       	push	r10
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2178
    2614:	bf 92       	push	r11
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2179
    2616:	cf 92       	push	r12
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2180
    2618:	df 92       	push	r13
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2181
    261a:	ef 92       	push	r14
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2182
    261c:	ff 92       	push	r15
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2183
    261e:	0f 93       	push	r16
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2184
    2620:	1f 93       	push	r17
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2185
    2622:	cf 93       	push	r28
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2186
    2624:	df 93       	push	r29
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2193
    2626:	cd b7       	in	r28, 0x3d	; 61
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2194
    2628:	de b7       	in	r29, 0x3e	; 62
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2195
    262a:	ca 1b       	sub	r28, r26
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2196
    262c:	db 0b       	sbc	r29, r27
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2197
    262e:	cd bf       	out	0x3d, r28	; 61
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2198
    2630:	de bf       	out	0x3e, r29	; 62
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2211
    2632:	09 94       	ijmp

00002634 <__epilogue_restores__>:
__epilogue_restores__():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2222
    2634:	2a 88       	ldd	r2, Y+18	; 0x12
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2223
    2636:	39 88       	ldd	r3, Y+17	; 0x11
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2224
    2638:	48 88       	ldd	r4, Y+16	; 0x10
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2225
    263a:	5f 84       	ldd	r5, Y+15	; 0x0f
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2226
    263c:	6e 84       	ldd	r6, Y+14	; 0x0e
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2227
    263e:	7d 84       	ldd	r7, Y+13	; 0x0d
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2228
    2640:	8c 84       	ldd	r8, Y+12	; 0x0c
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2229
    2642:	9b 84       	ldd	r9, Y+11	; 0x0b
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2230
    2644:	aa 84       	ldd	r10, Y+10	; 0x0a
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2231
    2646:	b9 84       	ldd	r11, Y+9	; 0x09
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2232
    2648:	c8 84       	ldd	r12, Y+8	; 0x08
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2233
    264a:	df 80       	ldd	r13, Y+7	; 0x07
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2234
    264c:	ee 80       	ldd	r14, Y+6	; 0x06
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2235
    264e:	fd 80       	ldd	r15, Y+5	; 0x05
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2236
    2650:	0c 81       	ldd	r16, Y+4	; 0x04
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2237
    2652:	1b 81       	ldd	r17, Y+3	; 0x03
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2238
    2654:	aa 81       	ldd	r26, Y+2	; 0x02
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2245
    2656:	b9 81       	ldd	r27, Y+1	; 0x01
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2246
    2658:	ce 0f       	add	r28, r30
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2247
    265a:	d1 1d       	adc	r29, r1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2248
    265c:	cd bf       	out	0x3d, r28	; 61
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2249
    265e:	de bf       	out	0x3e, r29	; 62
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2250
    2660:	ed 01       	movw	r28, r26
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2263
    2662:	08 95       	ret

00002664 <__subsf3>:
__subsf3():
    2664:	50 58       	subi	r21, 0x80	; 128

00002666 <__addsf3>:
    2666:	bb 27       	eor	r27, r27
    2668:	aa 27       	eor	r26, r26
    266a:	0e d0       	rcall	.+28     	; 0x2688 <__addsf3x>
    266c:	c2 c1       	rjmp	.+900    	; 0x29f2 <__fp_round>
__addsf3():
    266e:	b3 d1       	rcall	.+870    	; 0x29d6 <__fp_pscA>
    2670:	30 f0       	brcs	.+12     	; 0x267e <__addsf3+0x18>
    2672:	b8 d1       	rcall	.+880    	; 0x29e4 <__fp_pscB>
    2674:	20 f0       	brcs	.+8      	; 0x267e <__addsf3+0x18>
    2676:	31 f4       	brne	.+12     	; 0x2684 <__addsf3+0x1e>
    2678:	9f 3f       	cpi	r25, 0xFF	; 255
    267a:	11 f4       	brne	.+4      	; 0x2680 <__addsf3+0x1a>
    267c:	1e f4       	brtc	.+6      	; 0x2684 <__addsf3+0x1e>
    267e:	98 c1       	rjmp	.+816    	; 0x29b0 <__fp_nan>
    2680:	0e f4       	brtc	.+2      	; 0x2684 <__addsf3+0x1e>
    2682:	e0 95       	com	r30
    2684:	e7 fb       	bst	r30, 7
    2686:	8e c1       	rjmp	.+796    	; 0x29a4 <__fp_inf>

00002688 <__addsf3x>:
__addsf3x():
    2688:	e9 2f       	mov	r30, r25
    268a:	c4 d1       	rcall	.+904    	; 0x2a14 <__fp_split3>
    268c:	80 f3       	brcs	.-32     	; 0x266e <__addsf3+0x8>
    268e:	ba 17       	cp	r27, r26
    2690:	62 07       	cpc	r22, r18
    2692:	73 07       	cpc	r23, r19
    2694:	84 07       	cpc	r24, r20
    2696:	95 07       	cpc	r25, r21
    2698:	18 f0       	brcs	.+6      	; 0x26a0 <__addsf3x+0x18>
    269a:	71 f4       	brne	.+28     	; 0x26b8 <__addsf3x+0x30>
    269c:	9e f5       	brtc	.+102    	; 0x2704 <__addsf3x+0x7c>
    269e:	dc c1       	rjmp	.+952    	; 0x2a58 <__fp_zero>
    26a0:	0e f4       	brtc	.+2      	; 0x26a4 <__addsf3x+0x1c>
    26a2:	e0 95       	com	r30
    26a4:	0b 2e       	mov	r0, r27
    26a6:	ba 2f       	mov	r27, r26
    26a8:	a0 2d       	mov	r26, r0
    26aa:	0b 01       	movw	r0, r22
    26ac:	b9 01       	movw	r22, r18
    26ae:	90 01       	movw	r18, r0
    26b0:	0c 01       	movw	r0, r24
    26b2:	ca 01       	movw	r24, r20
    26b4:	a0 01       	movw	r20, r0
    26b6:	11 24       	eor	r1, r1
    26b8:	ff 27       	eor	r31, r31
    26ba:	59 1b       	sub	r21, r25
    26bc:	99 f0       	breq	.+38     	; 0x26e4 <__addsf3x+0x5c>
    26be:	59 3f       	cpi	r21, 0xF9	; 249
    26c0:	50 f4       	brcc	.+20     	; 0x26d6 <__addsf3x+0x4e>
    26c2:	50 3e       	cpi	r21, 0xE0	; 224
    26c4:	68 f1       	brcs	.+90     	; 0x2720 <__addsf3x+0x98>
    26c6:	1a 16       	cp	r1, r26
    26c8:	f0 40       	sbci	r31, 0x00	; 0
    26ca:	a2 2f       	mov	r26, r18
    26cc:	23 2f       	mov	r18, r19
    26ce:	34 2f       	mov	r19, r20
    26d0:	44 27       	eor	r20, r20
    26d2:	58 5f       	subi	r21, 0xF8	; 248
    26d4:	f3 cf       	rjmp	.-26     	; 0x26bc <__addsf3x+0x34>
    26d6:	46 95       	lsr	r20
    26d8:	37 95       	ror	r19
    26da:	27 95       	ror	r18
    26dc:	a7 95       	ror	r26
    26de:	f0 40       	sbci	r31, 0x00	; 0
    26e0:	53 95       	inc	r21
    26e2:	c9 f7       	brne	.-14     	; 0x26d6 <__addsf3x+0x4e>
    26e4:	7e f4       	brtc	.+30     	; 0x2704 <__addsf3x+0x7c>
    26e6:	1f 16       	cp	r1, r31
    26e8:	ba 0b       	sbc	r27, r26
    26ea:	62 0b       	sbc	r22, r18
    26ec:	73 0b       	sbc	r23, r19
    26ee:	84 0b       	sbc	r24, r20
    26f0:	ba f0       	brmi	.+46     	; 0x2720 <__addsf3x+0x98>
    26f2:	91 50       	subi	r25, 0x01	; 1
    26f4:	a1 f0       	breq	.+40     	; 0x271e <__addsf3x+0x96>
    26f6:	ff 0f       	add	r31, r31
    26f8:	bb 1f       	adc	r27, r27
    26fa:	66 1f       	adc	r22, r22
    26fc:	77 1f       	adc	r23, r23
    26fe:	88 1f       	adc	r24, r24
    2700:	c2 f7       	brpl	.-16     	; 0x26f2 <__addsf3x+0x6a>
    2702:	0e c0       	rjmp	.+28     	; 0x2720 <__addsf3x+0x98>
    2704:	ba 0f       	add	r27, r26
    2706:	62 1f       	adc	r22, r18
    2708:	73 1f       	adc	r23, r19
    270a:	84 1f       	adc	r24, r20
    270c:	48 f4       	brcc	.+18     	; 0x2720 <__addsf3x+0x98>
    270e:	87 95       	ror	r24
    2710:	77 95       	ror	r23
    2712:	67 95       	ror	r22
    2714:	b7 95       	ror	r27
    2716:	f7 95       	ror	r31
    2718:	9e 3f       	cpi	r25, 0xFE	; 254
    271a:	08 f0       	brcs	.+2      	; 0x271e <__addsf3x+0x96>
    271c:	b3 cf       	rjmp	.-154    	; 0x2684 <__addsf3+0x1e>
    271e:	93 95       	inc	r25
    2720:	88 0f       	add	r24, r24
    2722:	08 f0       	brcs	.+2      	; 0x2726 <__addsf3x+0x9e>
    2724:	99 27       	eor	r25, r25
    2726:	ee 0f       	add	r30, r30
    2728:	97 95       	ror	r25
    272a:	87 95       	ror	r24
    272c:	08 95       	ret

0000272e <__cmpsf2>:
    272e:	16 d1       	rcall	.+556    	; 0x295c <__fp_cmp>
    2730:	08 f4       	brcc	.+2      	; 0x2734 <__cmpsf2+0x6>
    2732:	81 e0       	ldi	r24, 0x01	; 1
    2734:	08 95       	ret

00002736 <__divsf3>:
    2736:	0c d0       	rcall	.+24     	; 0x2750 <__divsf3x>
    2738:	5c c1       	rjmp	.+696    	; 0x29f2 <__fp_round>
    273a:	54 d1       	rcall	.+680    	; 0x29e4 <__fp_pscB>
    273c:	40 f0       	brcs	.+16     	; 0x274e <__divsf3+0x18>
    273e:	4b d1       	rcall	.+662    	; 0x29d6 <__fp_pscA>
    2740:	30 f0       	brcs	.+12     	; 0x274e <__divsf3+0x18>
    2742:	21 f4       	brne	.+8      	; 0x274c <__divsf3+0x16>
    2744:	5f 3f       	cpi	r21, 0xFF	; 255
    2746:	19 f0       	breq	.+6      	; 0x274e <__divsf3+0x18>
    2748:	2d c1       	rjmp	.+602    	; 0x29a4 <__fp_inf>
    274a:	51 11       	cpse	r21, r1
    274c:	86 c1       	rjmp	.+780    	; 0x2a5a <__fp_szero>
    274e:	30 c1       	rjmp	.+608    	; 0x29b0 <__fp_nan>

00002750 <__divsf3x>:
    2750:	61 d1       	rcall	.+706    	; 0x2a14 <__fp_split3>
    2752:	98 f3       	brcs	.-26     	; 0x273a <__divsf3+0x4>

00002754 <__divsf3_pse>:
__divsf3_pse():
    2754:	99 23       	and	r25, r25
    2756:	c9 f3       	breq	.-14     	; 0x274a <__divsf3+0x14>
    2758:	55 23       	and	r21, r21
    275a:	b1 f3       	breq	.-20     	; 0x2748 <__divsf3+0x12>
    275c:	95 1b       	sub	r25, r21
    275e:	55 0b       	sbc	r21, r21
    2760:	bb 27       	eor	r27, r27
    2762:	aa 27       	eor	r26, r26
    2764:	62 17       	cp	r22, r18
    2766:	73 07       	cpc	r23, r19
    2768:	84 07       	cpc	r24, r20
    276a:	38 f0       	brcs	.+14     	; 0x277a <__divsf3_pse+0x26>
    276c:	9f 5f       	subi	r25, 0xFF	; 255
    276e:	5f 4f       	sbci	r21, 0xFF	; 255
    2770:	22 0f       	add	r18, r18
    2772:	33 1f       	adc	r19, r19
    2774:	44 1f       	adc	r20, r20
    2776:	aa 1f       	adc	r26, r26
    2778:	a9 f3       	breq	.-22     	; 0x2764 <__divsf3_pse+0x10>
    277a:	33 d0       	rcall	.+102    	; 0x27e2 <__divsf3_pse+0x8e>
    277c:	0e 2e       	mov	r0, r30
    277e:	3a f0       	brmi	.+14     	; 0x278e <__divsf3_pse+0x3a>
    2780:	e0 e8       	ldi	r30, 0x80	; 128
    2782:	30 d0       	rcall	.+96     	; 0x27e4 <__divsf3_pse+0x90>
    2784:	91 50       	subi	r25, 0x01	; 1
    2786:	50 40       	sbci	r21, 0x00	; 0
    2788:	e6 95       	lsr	r30
    278a:	00 1c       	adc	r0, r0
    278c:	ca f7       	brpl	.-14     	; 0x2780 <__divsf3_pse+0x2c>
    278e:	29 d0       	rcall	.+82     	; 0x27e2 <__divsf3_pse+0x8e>
    2790:	fe 2f       	mov	r31, r30
    2792:	27 d0       	rcall	.+78     	; 0x27e2 <__divsf3_pse+0x8e>
    2794:	66 0f       	add	r22, r22
    2796:	77 1f       	adc	r23, r23
    2798:	88 1f       	adc	r24, r24
    279a:	bb 1f       	adc	r27, r27
    279c:	26 17       	cp	r18, r22
    279e:	37 07       	cpc	r19, r23
    27a0:	48 07       	cpc	r20, r24
    27a2:	ab 07       	cpc	r26, r27
    27a4:	b0 e8       	ldi	r27, 0x80	; 128
    27a6:	09 f0       	breq	.+2      	; 0x27aa <__divsf3_pse+0x56>
    27a8:	bb 0b       	sbc	r27, r27
    27aa:	80 2d       	mov	r24, r0
    27ac:	bf 01       	movw	r22, r30
    27ae:	ff 27       	eor	r31, r31
    27b0:	93 58       	subi	r25, 0x83	; 131
    27b2:	5f 4f       	sbci	r21, 0xFF	; 255
    27b4:	2a f0       	brmi	.+10     	; 0x27c0 <__divsf3_pse+0x6c>
    27b6:	9e 3f       	cpi	r25, 0xFE	; 254
    27b8:	51 05       	cpc	r21, r1
    27ba:	68 f0       	brcs	.+26     	; 0x27d6 <__divsf3_pse+0x82>
    27bc:	f3 c0       	rjmp	.+486    	; 0x29a4 <__fp_inf>
    27be:	4d c1       	rjmp	.+666    	; 0x2a5a <__fp_szero>
    27c0:	5f 3f       	cpi	r21, 0xFF	; 255
    27c2:	ec f3       	brlt	.-6      	; 0x27be <__divsf3_pse+0x6a>
    27c4:	98 3e       	cpi	r25, 0xE8	; 232
    27c6:	dc f3       	brlt	.-10     	; 0x27be <__divsf3_pse+0x6a>
    27c8:	86 95       	lsr	r24
    27ca:	77 95       	ror	r23
    27cc:	67 95       	ror	r22
    27ce:	b7 95       	ror	r27
    27d0:	f7 95       	ror	r31
    27d2:	9f 5f       	subi	r25, 0xFF	; 255
    27d4:	c9 f7       	brne	.-14     	; 0x27c8 <__divsf3_pse+0x74>
    27d6:	88 0f       	add	r24, r24
    27d8:	91 1d       	adc	r25, r1
    27da:	96 95       	lsr	r25
    27dc:	87 95       	ror	r24
    27de:	97 f9       	bld	r25, 7
    27e0:	08 95       	ret
    27e2:	e1 e0       	ldi	r30, 0x01	; 1
    27e4:	66 0f       	add	r22, r22
    27e6:	77 1f       	adc	r23, r23
    27e8:	88 1f       	adc	r24, r24
    27ea:	bb 1f       	adc	r27, r27
    27ec:	62 17       	cp	r22, r18
    27ee:	73 07       	cpc	r23, r19
    27f0:	84 07       	cpc	r24, r20
    27f2:	ba 07       	cpc	r27, r26
    27f4:	20 f0       	brcs	.+8      	; 0x27fe <__divsf3_pse+0xaa>
    27f6:	62 1b       	sub	r22, r18
    27f8:	73 0b       	sbc	r23, r19
    27fa:	84 0b       	sbc	r24, r20
    27fc:	ba 0b       	sbc	r27, r26
    27fe:	ee 1f       	adc	r30, r30
    2800:	88 f7       	brcc	.-30     	; 0x27e4 <__divsf3_pse+0x90>
    2802:	e0 95       	com	r30
    2804:	08 95       	ret

00002806 <__fixunssfsi>:
__fixunssfsi():
    2806:	0e d1       	rcall	.+540    	; 0x2a24 <__fp_splitA>
    2808:	88 f0       	brcs	.+34     	; 0x282c <__fixunssfsi+0x26>
    280a:	9f 57       	subi	r25, 0x7F	; 127
    280c:	90 f0       	brcs	.+36     	; 0x2832 <__fixunssfsi+0x2c>
    280e:	b9 2f       	mov	r27, r25
    2810:	99 27       	eor	r25, r25
    2812:	b7 51       	subi	r27, 0x17	; 23
    2814:	a0 f0       	brcs	.+40     	; 0x283e <__fixunssfsi+0x38>
    2816:	d1 f0       	breq	.+52     	; 0x284c <__fixunssfsi+0x46>
    2818:	66 0f       	add	r22, r22
    281a:	77 1f       	adc	r23, r23
    281c:	88 1f       	adc	r24, r24
    281e:	99 1f       	adc	r25, r25
    2820:	1a f0       	brmi	.+6      	; 0x2828 <__fixunssfsi+0x22>
    2822:	ba 95       	dec	r27
    2824:	c9 f7       	brne	.-14     	; 0x2818 <__fixunssfsi+0x12>
    2826:	12 c0       	rjmp	.+36     	; 0x284c <__fixunssfsi+0x46>
    2828:	b1 30       	cpi	r27, 0x01	; 1
    282a:	81 f0       	breq	.+32     	; 0x284c <__fixunssfsi+0x46>
    282c:	15 d1       	rcall	.+554    	; 0x2a58 <__fp_zero>
    282e:	b1 e0       	ldi	r27, 0x01	; 1
    2830:	08 95       	ret
    2832:	12 c1       	rjmp	.+548    	; 0x2a58 <__fp_zero>
    2834:	67 2f       	mov	r22, r23
    2836:	78 2f       	mov	r23, r24
    2838:	88 27       	eor	r24, r24
    283a:	b8 5f       	subi	r27, 0xF8	; 248
    283c:	39 f0       	breq	.+14     	; 0x284c <__fixunssfsi+0x46>
    283e:	b9 3f       	cpi	r27, 0xF9	; 249
    2840:	cc f3       	brlt	.-14     	; 0x2834 <__fixunssfsi+0x2e>
    2842:	86 95       	lsr	r24
    2844:	77 95       	ror	r23
    2846:	67 95       	ror	r22
    2848:	b3 95       	inc	r27
    284a:	d9 f7       	brne	.-10     	; 0x2842 <__fixunssfsi+0x3c>
    284c:	3e f4       	brtc	.+14     	; 0x285c <__fixunssfsi+0x56>
    284e:	90 95       	com	r25
    2850:	80 95       	com	r24
    2852:	70 95       	com	r23
    2854:	61 95       	neg	r22
    2856:	7f 4f       	sbci	r23, 0xFF	; 255
    2858:	8f 4f       	sbci	r24, 0xFF	; 255
    285a:	9f 4f       	sbci	r25, 0xFF	; 255
    285c:	08 95       	ret

0000285e <__floatdisf>:
__floatdisf():
    285e:	97 fb       	bst	r25, 7
    2860:	0e f4       	brtc	.+2      	; 0x2864 <__floatdisf+0x6>
    2862:	a9 d0       	rcall	.+338    	; 0x29b6 <__fp_negdi>
    2864:	3e c0       	rjmp	.+124    	; 0x28e2 <__fp_di2sf>

00002866 <__floatunsisf>:
__floatunsisf():
    2866:	e8 94       	clt
    2868:	09 c0       	rjmp	.+18     	; 0x287c <__floatsisf+0x12>

0000286a <__floatsisf>:
    286a:	97 fb       	bst	r25, 7
    286c:	3e f4       	brtc	.+14     	; 0x287c <__floatsisf+0x12>
    286e:	90 95       	com	r25
    2870:	80 95       	com	r24
    2872:	70 95       	com	r23
    2874:	61 95       	neg	r22
    2876:	7f 4f       	sbci	r23, 0xFF	; 255
    2878:	8f 4f       	sbci	r24, 0xFF	; 255
    287a:	9f 4f       	sbci	r25, 0xFF	; 255
    287c:	99 23       	and	r25, r25
    287e:	a9 f0       	breq	.+42     	; 0x28aa <__floatsisf+0x40>
    2880:	f9 2f       	mov	r31, r25
    2882:	96 e9       	ldi	r25, 0x96	; 150
    2884:	bb 27       	eor	r27, r27
    2886:	93 95       	inc	r25
    2888:	f6 95       	lsr	r31
    288a:	87 95       	ror	r24
    288c:	77 95       	ror	r23
    288e:	67 95       	ror	r22
    2890:	b7 95       	ror	r27
    2892:	f1 11       	cpse	r31, r1
    2894:	f8 cf       	rjmp	.-16     	; 0x2886 <__floatsisf+0x1c>
    2896:	fa f4       	brpl	.+62     	; 0x28d6 <__floatsisf+0x6c>
    2898:	bb 0f       	add	r27, r27
    289a:	11 f4       	brne	.+4      	; 0x28a0 <__floatsisf+0x36>
    289c:	60 ff       	sbrs	r22, 0
    289e:	1b c0       	rjmp	.+54     	; 0x28d6 <__floatsisf+0x6c>
    28a0:	6f 5f       	subi	r22, 0xFF	; 255
    28a2:	7f 4f       	sbci	r23, 0xFF	; 255
    28a4:	8f 4f       	sbci	r24, 0xFF	; 255
    28a6:	9f 4f       	sbci	r25, 0xFF	; 255
    28a8:	16 c0       	rjmp	.+44     	; 0x28d6 <__floatsisf+0x6c>
    28aa:	88 23       	and	r24, r24
    28ac:	11 f0       	breq	.+4      	; 0x28b2 <__floatsisf+0x48>
    28ae:	96 e9       	ldi	r25, 0x96	; 150
    28b0:	11 c0       	rjmp	.+34     	; 0x28d4 <__floatsisf+0x6a>
    28b2:	77 23       	and	r23, r23
    28b4:	21 f0       	breq	.+8      	; 0x28be <__floatsisf+0x54>
    28b6:	9e e8       	ldi	r25, 0x8E	; 142
    28b8:	87 2f       	mov	r24, r23
    28ba:	76 2f       	mov	r23, r22
    28bc:	05 c0       	rjmp	.+10     	; 0x28c8 <__floatsisf+0x5e>
    28be:	66 23       	and	r22, r22
    28c0:	71 f0       	breq	.+28     	; 0x28de <__floatsisf+0x74>
    28c2:	96 e8       	ldi	r25, 0x86	; 134
    28c4:	86 2f       	mov	r24, r22
    28c6:	70 e0       	ldi	r23, 0x00	; 0
    28c8:	60 e0       	ldi	r22, 0x00	; 0
    28ca:	2a f0       	brmi	.+10     	; 0x28d6 <__floatsisf+0x6c>
    28cc:	9a 95       	dec	r25
    28ce:	66 0f       	add	r22, r22
    28d0:	77 1f       	adc	r23, r23
    28d2:	88 1f       	adc	r24, r24
    28d4:	da f7       	brpl	.-10     	; 0x28cc <__floatsisf+0x62>
    28d6:	88 0f       	add	r24, r24
    28d8:	96 95       	lsr	r25
    28da:	87 95       	ror	r24
    28dc:	97 f9       	bld	r25, 7
    28de:	08 95       	ret

000028e0 <__floatundisf>:
__floatundisf():
    28e0:	e8 94       	clt

000028e2 <__fp_di2sf>:
    28e2:	f9 2f       	mov	r31, r25
    28e4:	96 eb       	ldi	r25, 0xB6	; 182
    28e6:	ff 23       	and	r31, r31
    28e8:	81 f0       	breq	.+32     	; 0x290a <__fp_di2sf+0x28>
    28ea:	12 16       	cp	r1, r18
    28ec:	13 06       	cpc	r1, r19
    28ee:	14 06       	cpc	r1, r20
    28f0:	44 0b       	sbc	r20, r20
    28f2:	93 95       	inc	r25
    28f4:	f6 95       	lsr	r31
    28f6:	87 95       	ror	r24
    28f8:	77 95       	ror	r23
    28fa:	67 95       	ror	r22
    28fc:	57 95       	ror	r21
    28fe:	40 40       	sbci	r20, 0x00	; 0
    2900:	ff 23       	and	r31, r31
    2902:	b9 f7       	brne	.-18     	; 0x28f2 <__fp_di2sf+0x10>
    2904:	1b c0       	rjmp	.+54     	; 0x293c <__fp_di2sf+0x5a>
    2906:	99 27       	eor	r25, r25
    2908:	08 95       	ret
    290a:	88 23       	and	r24, r24
    290c:	51 f4       	brne	.+20     	; 0x2922 <__fp_di2sf+0x40>
    290e:	98 50       	subi	r25, 0x08	; 8
    2910:	d2 f7       	brpl	.-12     	; 0x2906 <__fp_di2sf+0x24>
    2912:	87 2b       	or	r24, r23
    2914:	76 2f       	mov	r23, r22
    2916:	65 2f       	mov	r22, r21
    2918:	54 2f       	mov	r21, r20
    291a:	43 2f       	mov	r20, r19
    291c:	32 2f       	mov	r19, r18
    291e:	20 e0       	ldi	r18, 0x00	; 0
    2920:	b1 f3       	breq	.-20     	; 0x290e <__fp_di2sf+0x2c>
    2922:	12 16       	cp	r1, r18
    2924:	13 06       	cpc	r1, r19
    2926:	14 06       	cpc	r1, r20
    2928:	44 0b       	sbc	r20, r20
    292a:	88 23       	and	r24, r24
    292c:	3a f0       	brmi	.+14     	; 0x293c <__fp_di2sf+0x5a>
    292e:	9a 95       	dec	r25
    2930:	44 0f       	add	r20, r20
    2932:	55 1f       	adc	r21, r21
    2934:	66 1f       	adc	r22, r22
    2936:	77 1f       	adc	r23, r23
    2938:	88 1f       	adc	r24, r24
    293a:	ca f7       	brpl	.-14     	; 0x292e <__fp_di2sf+0x4c>
    293c:	55 23       	and	r21, r21
    293e:	4a f4       	brpl	.+18     	; 0x2952 <__fp_di2sf+0x70>
    2940:	44 0f       	add	r20, r20
    2942:	55 1f       	adc	r21, r21
    2944:	11 f4       	brne	.+4      	; 0x294a <__fp_di2sf+0x68>
    2946:	60 ff       	sbrs	r22, 0
    2948:	04 c0       	rjmp	.+8      	; 0x2952 <__fp_di2sf+0x70>
    294a:	6f 5f       	subi	r22, 0xFF	; 255
    294c:	7f 4f       	sbci	r23, 0xFF	; 255
    294e:	8f 4f       	sbci	r24, 0xFF	; 255
    2950:	9f 4f       	sbci	r25, 0xFF	; 255
    2952:	88 0f       	add	r24, r24
    2954:	96 95       	lsr	r25
    2956:	87 95       	ror	r24
    2958:	97 f9       	bld	r25, 7
    295a:	08 95       	ret

0000295c <__fp_cmp>:
__fp_cmp():
    295c:	99 0f       	add	r25, r25
    295e:	00 08       	sbc	r0, r0
    2960:	55 0f       	add	r21, r21
    2962:	aa 0b       	sbc	r26, r26
    2964:	e0 e8       	ldi	r30, 0x80	; 128
    2966:	fe ef       	ldi	r31, 0xFE	; 254
    2968:	16 16       	cp	r1, r22
    296a:	17 06       	cpc	r1, r23
    296c:	e8 07       	cpc	r30, r24
    296e:	f9 07       	cpc	r31, r25
    2970:	c0 f0       	brcs	.+48     	; 0x29a2 <__fp_cmp+0x46>
    2972:	12 16       	cp	r1, r18
    2974:	13 06       	cpc	r1, r19
    2976:	e4 07       	cpc	r30, r20
    2978:	f5 07       	cpc	r31, r21
    297a:	98 f0       	brcs	.+38     	; 0x29a2 <__fp_cmp+0x46>
    297c:	62 1b       	sub	r22, r18
    297e:	73 0b       	sbc	r23, r19
    2980:	84 0b       	sbc	r24, r20
    2982:	95 0b       	sbc	r25, r21
    2984:	39 f4       	brne	.+14     	; 0x2994 <__fp_cmp+0x38>
    2986:	0a 26       	eor	r0, r26
    2988:	61 f0       	breq	.+24     	; 0x29a2 <__fp_cmp+0x46>
    298a:	23 2b       	or	r18, r19
    298c:	24 2b       	or	r18, r20
    298e:	25 2b       	or	r18, r21
    2990:	21 f4       	brne	.+8      	; 0x299a <__fp_cmp+0x3e>
    2992:	08 95       	ret
    2994:	0a 26       	eor	r0, r26
    2996:	09 f4       	brne	.+2      	; 0x299a <__fp_cmp+0x3e>
    2998:	a1 40       	sbci	r26, 0x01	; 1
    299a:	a6 95       	lsr	r26
    299c:	8f ef       	ldi	r24, 0xFF	; 255
    299e:	81 1d       	adc	r24, r1
    29a0:	81 1d       	adc	r24, r1
    29a2:	08 95       	ret

000029a4 <__fp_inf>:
__fp_inf():
    29a4:	97 f9       	bld	r25, 7
    29a6:	9f 67       	ori	r25, 0x7F	; 127
    29a8:	80 e8       	ldi	r24, 0x80	; 128
    29aa:	70 e0       	ldi	r23, 0x00	; 0
    29ac:	60 e0       	ldi	r22, 0x00	; 0
    29ae:	08 95       	ret

000029b0 <__fp_nan>:
__fp_nan():
    29b0:	9f ef       	ldi	r25, 0xFF	; 255
    29b2:	80 ec       	ldi	r24, 0xC0	; 192
    29b4:	08 95       	ret

000029b6 <__fp_negdi>:
__fp_negdi():
    29b6:	90 95       	com	r25
    29b8:	80 95       	com	r24
    29ba:	70 95       	com	r23
    29bc:	60 95       	com	r22
    29be:	50 95       	com	r21
    29c0:	40 95       	com	r20
    29c2:	30 95       	com	r19
    29c4:	21 95       	neg	r18
    29c6:	3f 4f       	sbci	r19, 0xFF	; 255
    29c8:	4f 4f       	sbci	r20, 0xFF	; 255
    29ca:	5f 4f       	sbci	r21, 0xFF	; 255
    29cc:	6f 4f       	sbci	r22, 0xFF	; 255
    29ce:	7f 4f       	sbci	r23, 0xFF	; 255
    29d0:	8f 4f       	sbci	r24, 0xFF	; 255
    29d2:	9f 4f       	sbci	r25, 0xFF	; 255
    29d4:	08 95       	ret

000029d6 <__fp_pscA>:
__fp_pscA():
    29d6:	00 24       	eor	r0, r0
    29d8:	0a 94       	dec	r0
    29da:	16 16       	cp	r1, r22
    29dc:	17 06       	cpc	r1, r23
    29de:	18 06       	cpc	r1, r24
    29e0:	09 06       	cpc	r0, r25
    29e2:	08 95       	ret

000029e4 <__fp_pscB>:
__fp_pscB():
    29e4:	00 24       	eor	r0, r0
    29e6:	0a 94       	dec	r0
    29e8:	12 16       	cp	r1, r18
    29ea:	13 06       	cpc	r1, r19
    29ec:	14 06       	cpc	r1, r20
    29ee:	05 06       	cpc	r0, r21
    29f0:	08 95       	ret

000029f2 <__fp_round>:
__fp_round():
    29f2:	09 2e       	mov	r0, r25
    29f4:	03 94       	inc	r0
    29f6:	00 0c       	add	r0, r0
    29f8:	11 f4       	brne	.+4      	; 0x29fe <__fp_round+0xc>
    29fa:	88 23       	and	r24, r24
    29fc:	52 f0       	brmi	.+20     	; 0x2a12 <__fp_round+0x20>
    29fe:	bb 0f       	add	r27, r27
    2a00:	40 f4       	brcc	.+16     	; 0x2a12 <__fp_round+0x20>
    2a02:	bf 2b       	or	r27, r31
    2a04:	11 f4       	brne	.+4      	; 0x2a0a <__fp_round+0x18>
    2a06:	60 ff       	sbrs	r22, 0
    2a08:	04 c0       	rjmp	.+8      	; 0x2a12 <__fp_round+0x20>
    2a0a:	6f 5f       	subi	r22, 0xFF	; 255
    2a0c:	7f 4f       	sbci	r23, 0xFF	; 255
    2a0e:	8f 4f       	sbci	r24, 0xFF	; 255
    2a10:	9f 4f       	sbci	r25, 0xFF	; 255
    2a12:	08 95       	ret

00002a14 <__fp_split3>:
__fp_split3():
    2a14:	57 fd       	sbrc	r21, 7
    2a16:	90 58       	subi	r25, 0x80	; 128
    2a18:	44 0f       	add	r20, r20
    2a1a:	55 1f       	adc	r21, r21
    2a1c:	59 f0       	breq	.+22     	; 0x2a34 <__fp_splitA+0x10>
    2a1e:	5f 3f       	cpi	r21, 0xFF	; 255
    2a20:	71 f0       	breq	.+28     	; 0x2a3e <__fp_splitA+0x1a>
    2a22:	47 95       	ror	r20

00002a24 <__fp_splitA>:
    2a24:	88 0f       	add	r24, r24
    2a26:	97 fb       	bst	r25, 7
    2a28:	99 1f       	adc	r25, r25
    2a2a:	61 f0       	breq	.+24     	; 0x2a44 <__fp_splitA+0x20>
    2a2c:	9f 3f       	cpi	r25, 0xFF	; 255
    2a2e:	79 f0       	breq	.+30     	; 0x2a4e <__fp_splitA+0x2a>
    2a30:	87 95       	ror	r24
    2a32:	08 95       	ret
    2a34:	12 16       	cp	r1, r18
    2a36:	13 06       	cpc	r1, r19
    2a38:	14 06       	cpc	r1, r20
    2a3a:	55 1f       	adc	r21, r21
    2a3c:	f2 cf       	rjmp	.-28     	; 0x2a22 <__fp_split3+0xe>
    2a3e:	46 95       	lsr	r20
    2a40:	f1 df       	rcall	.-30     	; 0x2a24 <__fp_splitA>
    2a42:	08 c0       	rjmp	.+16     	; 0x2a54 <__fp_splitA+0x30>
    2a44:	16 16       	cp	r1, r22
    2a46:	17 06       	cpc	r1, r23
    2a48:	18 06       	cpc	r1, r24
    2a4a:	99 1f       	adc	r25, r25
    2a4c:	f1 cf       	rjmp	.-30     	; 0x2a30 <__fp_splitA+0xc>
    2a4e:	86 95       	lsr	r24
    2a50:	71 05       	cpc	r23, r1
    2a52:	61 05       	cpc	r22, r1
    2a54:	08 94       	sec
    2a56:	08 95       	ret

00002a58 <__fp_zero>:
__fp_zero():
    2a58:	e8 94       	clt

00002a5a <__fp_szero>:
    2a5a:	bb 27       	eor	r27, r27
    2a5c:	66 27       	eor	r22, r22
    2a5e:	77 27       	eor	r23, r23
    2a60:	cb 01       	movw	r24, r22
    2a62:	97 f9       	bld	r25, 7
    2a64:	08 95       	ret

00002a66 <__gesf2>:
__gesf2():
    2a66:	7a df       	rcall	.-268    	; 0x295c <__fp_cmp>
    2a68:	08 f4       	brcc	.+2      	; 0x2a6c <__gesf2+0x6>
    2a6a:	8f ef       	ldi	r24, 0xFF	; 255
    2a6c:	08 95       	ret

00002a6e <__mulsf3>:
__mulsf3():
    2a6e:	0b d0       	rcall	.+22     	; 0x2a86 <__mulsf3x>
    2a70:	c0 cf       	rjmp	.-128    	; 0x29f2 <__fp_round>
    2a72:	b1 df       	rcall	.-158    	; 0x29d6 <__fp_pscA>
    2a74:	28 f0       	brcs	.+10     	; 0x2a80 <__mulsf3+0x12>
    2a76:	b6 df       	rcall	.-148    	; 0x29e4 <__fp_pscB>
    2a78:	18 f0       	brcs	.+6      	; 0x2a80 <__mulsf3+0x12>
    2a7a:	95 23       	and	r25, r21
    2a7c:	09 f0       	breq	.+2      	; 0x2a80 <__mulsf3+0x12>
    2a7e:	92 cf       	rjmp	.-220    	; 0x29a4 <__fp_inf>
    2a80:	97 cf       	rjmp	.-210    	; 0x29b0 <__fp_nan>
    2a82:	11 24       	eor	r1, r1
    2a84:	ea cf       	rjmp	.-44     	; 0x2a5a <__fp_szero>

00002a86 <__mulsf3x>:
__mulsf3x():
    2a86:	c6 df       	rcall	.-116    	; 0x2a14 <__fp_split3>
    2a88:	a0 f3       	brcs	.-24     	; 0x2a72 <__mulsf3+0x4>

00002a8a <__mulsf3_pse>:
    2a8a:	95 9f       	mul	r25, r21
    2a8c:	d1 f3       	breq	.-12     	; 0x2a82 <__mulsf3+0x14>
    2a8e:	95 0f       	add	r25, r21
    2a90:	50 e0       	ldi	r21, 0x00	; 0
    2a92:	55 1f       	adc	r21, r21
    2a94:	62 9f       	mul	r22, r18
    2a96:	f0 01       	movw	r30, r0
    2a98:	72 9f       	mul	r23, r18
    2a9a:	bb 27       	eor	r27, r27
    2a9c:	f0 0d       	add	r31, r0
    2a9e:	b1 1d       	adc	r27, r1
    2aa0:	63 9f       	mul	r22, r19
    2aa2:	aa 27       	eor	r26, r26
    2aa4:	f0 0d       	add	r31, r0
    2aa6:	b1 1d       	adc	r27, r1
    2aa8:	aa 1f       	adc	r26, r26
    2aaa:	64 9f       	mul	r22, r20
    2aac:	66 27       	eor	r22, r22
    2aae:	b0 0d       	add	r27, r0
    2ab0:	a1 1d       	adc	r26, r1
    2ab2:	66 1f       	adc	r22, r22
    2ab4:	82 9f       	mul	r24, r18
    2ab6:	22 27       	eor	r18, r18
    2ab8:	b0 0d       	add	r27, r0
    2aba:	a1 1d       	adc	r26, r1
    2abc:	62 1f       	adc	r22, r18
    2abe:	73 9f       	mul	r23, r19
    2ac0:	b0 0d       	add	r27, r0
    2ac2:	a1 1d       	adc	r26, r1
    2ac4:	62 1f       	adc	r22, r18
    2ac6:	83 9f       	mul	r24, r19
    2ac8:	a0 0d       	add	r26, r0
    2aca:	61 1d       	adc	r22, r1
    2acc:	22 1f       	adc	r18, r18
    2ace:	74 9f       	mul	r23, r20
    2ad0:	33 27       	eor	r19, r19
    2ad2:	a0 0d       	add	r26, r0
    2ad4:	61 1d       	adc	r22, r1
    2ad6:	23 1f       	adc	r18, r19
    2ad8:	84 9f       	mul	r24, r20
    2ada:	60 0d       	add	r22, r0
    2adc:	21 1d       	adc	r18, r1
    2ade:	82 2f       	mov	r24, r18
    2ae0:	76 2f       	mov	r23, r22
    2ae2:	6a 2f       	mov	r22, r26
    2ae4:	11 24       	eor	r1, r1
    2ae6:	9f 57       	subi	r25, 0x7F	; 127
    2ae8:	50 40       	sbci	r21, 0x00	; 0
    2aea:	8a f0       	brmi	.+34     	; 0x2b0e <__mulsf3_pse+0x84>
    2aec:	e1 f0       	breq	.+56     	; 0x2b26 <__mulsf3_pse+0x9c>
    2aee:	88 23       	and	r24, r24
    2af0:	4a f0       	brmi	.+18     	; 0x2b04 <__mulsf3_pse+0x7a>
    2af2:	ee 0f       	add	r30, r30
    2af4:	ff 1f       	adc	r31, r31
    2af6:	bb 1f       	adc	r27, r27
    2af8:	66 1f       	adc	r22, r22
    2afa:	77 1f       	adc	r23, r23
    2afc:	88 1f       	adc	r24, r24
    2afe:	91 50       	subi	r25, 0x01	; 1
    2b00:	50 40       	sbci	r21, 0x00	; 0
    2b02:	a9 f7       	brne	.-22     	; 0x2aee <__mulsf3_pse+0x64>
    2b04:	9e 3f       	cpi	r25, 0xFE	; 254
    2b06:	51 05       	cpc	r21, r1
    2b08:	70 f0       	brcs	.+28     	; 0x2b26 <__mulsf3_pse+0x9c>
    2b0a:	4c cf       	rjmp	.-360    	; 0x29a4 <__fp_inf>
    2b0c:	a6 cf       	rjmp	.-180    	; 0x2a5a <__fp_szero>
    2b0e:	5f 3f       	cpi	r21, 0xFF	; 255
    2b10:	ec f3       	brlt	.-6      	; 0x2b0c <__mulsf3_pse+0x82>
    2b12:	98 3e       	cpi	r25, 0xE8	; 232
    2b14:	dc f3       	brlt	.-10     	; 0x2b0c <__mulsf3_pse+0x82>
    2b16:	86 95       	lsr	r24
    2b18:	77 95       	ror	r23
    2b1a:	67 95       	ror	r22
    2b1c:	b7 95       	ror	r27
    2b1e:	f7 95       	ror	r31
    2b20:	e7 95       	ror	r30
    2b22:	9f 5f       	subi	r25, 0xFF	; 255
    2b24:	c1 f7       	brne	.-16     	; 0x2b16 <__mulsf3_pse+0x8c>
    2b26:	fe 2b       	or	r31, r30
    2b28:	88 0f       	add	r24, r24
    2b2a:	91 1d       	adc	r25, r1
    2b2c:	96 95       	lsr	r25
    2b2e:	87 95       	ror	r24
    2b30:	97 f9       	bld	r25, 7
    2b32:	08 95       	ret

00002b34 <pow>:
    2b34:	fa 01       	movw	r30, r20
    2b36:	ee 0f       	add	r30, r30
    2b38:	ff 1f       	adc	r31, r31
    2b3a:	30 96       	adiw	r30, 0x00	; 0
    2b3c:	21 05       	cpc	r18, r1
    2b3e:	31 05       	cpc	r19, r1
    2b40:	99 f1       	breq	.+102    	; 0x2ba8 <pow+0x74>
    2b42:	61 15       	cp	r22, r1
    2b44:	71 05       	cpc	r23, r1
    2b46:	61 f4       	brne	.+24     	; 0x2b60 <pow+0x2c>
    2b48:	80 38       	cpi	r24, 0x80	; 128
    2b4a:	bf e3       	ldi	r27, 0x3F	; 63
    2b4c:	9b 07       	cpc	r25, r27
    2b4e:	49 f1       	breq	.+82     	; 0x2ba2 <pow+0x6e>
    2b50:	68 94       	set
    2b52:	90 38       	cpi	r25, 0x80	; 128
    2b54:	81 05       	cpc	r24, r1
    2b56:	61 f0       	breq	.+24     	; 0x2b70 <pow+0x3c>
pow():
    2b58:	80 38       	cpi	r24, 0x80	; 128
    2b5a:	bf ef       	ldi	r27, 0xFF	; 255
    2b5c:	9b 07       	cpc	r25, r27
    2b5e:	41 f0       	breq	.+16     	; 0x2b70 <pow+0x3c>
    2b60:	99 23       	and	r25, r25
    2b62:	42 f5       	brpl	.+80     	; 0x2bb4 <pow+0x80>
    2b64:	ff 3f       	cpi	r31, 0xFF	; 255
    2b66:	e1 05       	cpc	r30, r1
    2b68:	31 05       	cpc	r19, r1
    2b6a:	21 05       	cpc	r18, r1
    2b6c:	11 f1       	breq	.+68     	; 0x2bb2 <pow+0x7e>
    2b6e:	e8 94       	clt
    2b70:	08 94       	sec
    2b72:	e7 95       	ror	r30
    2b74:	d9 01       	movw	r26, r18
    2b76:	aa 23       	and	r26, r26
    2b78:	29 f4       	brne	.+10     	; 0x2b84 <pow+0x50>
    2b7a:	ab 2f       	mov	r26, r27
    2b7c:	be 2f       	mov	r27, r30
    2b7e:	f8 5f       	subi	r31, 0xF8	; 248
    2b80:	d0 f3       	brcs	.-12     	; 0x2b76 <pow+0x42>
    2b82:	10 c0       	rjmp	.+32     	; 0x2ba4 <pow+0x70>
    2b84:	ff 5f       	subi	r31, 0xFF	; 255
    2b86:	70 f4       	brcc	.+28     	; 0x2ba4 <pow+0x70>
    2b88:	a6 95       	lsr	r26
    2b8a:	e0 f7       	brcc	.-8      	; 0x2b84 <pow+0x50>
    2b8c:	f7 39       	cpi	r31, 0x97	; 151
    2b8e:	50 f0       	brcs	.+20     	; 0x2ba4 <pow+0x70>
    2b90:	19 f0       	breq	.+6      	; 0x2b98 <pow+0x64>
    2b92:	ff 3a       	cpi	r31, 0xAF	; 175
    2b94:	38 f4       	brcc	.+14     	; 0x2ba4 <pow+0x70>
    2b96:	9f 77       	andi	r25, 0x7F	; 127
    2b98:	9f 93       	push	r25
    2b9a:	0c d0       	rcall	.+24     	; 0x2bb4 <pow+0x80>
    2b9c:	0f 90       	pop	r0
    2b9e:	07 fc       	sbrc	r0, 7
    2ba0:	90 58       	subi	r25, 0x80	; 128
    2ba2:	08 95       	ret
    2ba4:	3e f0       	brts	.+14     	; 0x2bb4 <pow+0x80>
    2ba6:	04 cf       	rjmp	.-504    	; 0x29b0 <__fp_nan>
    2ba8:	60 e0       	ldi	r22, 0x00	; 0
    2baa:	70 e0       	ldi	r23, 0x00	; 0
    2bac:	80 e8       	ldi	r24, 0x80	; 128
    2bae:	9f e3       	ldi	r25, 0x3F	; 63
    2bb0:	08 95       	ret
    2bb2:	4f e7       	ldi	r20, 0x7F	; 127
    2bb4:	9f 77       	andi	r25, 0x7F	; 127
    2bb6:	5f 93       	push	r21
    2bb8:	4f 93       	push	r20
    2bba:	3f 93       	push	r19
    2bbc:	2f 93       	push	r18
    2bbe:	a2 d0       	rcall	.+324    	; 0x2d04 <log>
    2bc0:	2f 91       	pop	r18
    2bc2:	3f 91       	pop	r19
    2bc4:	4f 91       	pop	r20
    2bc6:	5f 91       	pop	r21
    2bc8:	52 df       	rcall	.-348    	; 0x2a6e <__mulsf3>
    2bca:	09 c0       	rjmp	.+18     	; 0x2bde <exp>

00002bcc <__unordsf2>:
__unordsf2():
    2bcc:	c7 de       	rcall	.-626    	; 0x295c <__fp_cmp>
    2bce:	88 0b       	sbc	r24, r24
    2bd0:	99 0b       	sbc	r25, r25
    2bd2:	08 95       	ret
    2bd4:	19 f4       	brne	.+6      	; 0x2bdc <__unordsf2+0x10>
    2bd6:	0e f0       	brts	.+2      	; 0x2bda <__unordsf2+0xe>
    2bd8:	e5 ce       	rjmp	.-566    	; 0x29a4 <__fp_inf>
    2bda:	3e cf       	rjmp	.-388    	; 0x2a58 <__fp_zero>
    2bdc:	e9 ce       	rjmp	.-558    	; 0x29b0 <__fp_nan>

00002bde <exp>:
exp():
    2bde:	22 df       	rcall	.-444    	; 0x2a24 <__fp_splitA>
    2be0:	c8 f3       	brcs	.-14     	; 0x2bd4 <__unordsf2+0x8>
    2be2:	96 38       	cpi	r25, 0x86	; 134
    2be4:	c0 f7       	brcc	.-16     	; 0x2bd6 <__unordsf2+0xa>
    2be6:	07 f8       	bld	r0, 7
    2be8:	0f 92       	push	r0
    2bea:	e8 94       	clt
    2bec:	2b e3       	ldi	r18, 0x3B	; 59
    2bee:	3a ea       	ldi	r19, 0xAA	; 170
    2bf0:	48 eb       	ldi	r20, 0xB8	; 184
    2bf2:	5f e7       	ldi	r21, 0x7F	; 127
    2bf4:	4a df       	rcall	.-364    	; 0x2a8a <__mulsf3_pse>
    2bf6:	0f 92       	push	r0
    2bf8:	0f 92       	push	r0
    2bfa:	0f 92       	push	r0
    2bfc:	4d b7       	in	r20, 0x3d	; 61
    2bfe:	5e b7       	in	r21, 0x3e	; 62
    2c00:	0f 92       	push	r0
    2c02:	c0 d0       	rcall	.+384    	; 0x2d84 <modf>
    2c04:	e8 e7       	ldi	r30, 0x78	; 120
    2c06:	f0 e0       	ldi	r31, 0x00	; 0
    2c08:	16 d0       	rcall	.+44     	; 0x2c36 <__fp_powser>
    2c0a:	4f 91       	pop	r20
    2c0c:	5f 91       	pop	r21
    2c0e:	ef 91       	pop	r30
    2c10:	ff 91       	pop	r31
    2c12:	e5 95       	asr	r30
    2c14:	ee 1f       	adc	r30, r30
    2c16:	ff 1f       	adc	r31, r31
    2c18:	49 f0       	breq	.+18     	; 0x2c2c <exp+0x4e>
    2c1a:	fe 57       	subi	r31, 0x7E	; 126
    2c1c:	e0 68       	ori	r30, 0x80	; 128
    2c1e:	44 27       	eor	r20, r20
    2c20:	ee 0f       	add	r30, r30
    2c22:	44 1f       	adc	r20, r20
    2c24:	fa 95       	dec	r31
    2c26:	e1 f7       	brne	.-8      	; 0x2c20 <exp+0x42>
    2c28:	41 95       	neg	r20
    2c2a:	55 0b       	sbc	r21, r21
    2c2c:	32 d0       	rcall	.+100    	; 0x2c92 <ldexp>
    2c2e:	0f 90       	pop	r0
    2c30:	07 fe       	sbrs	r0, 7
    2c32:	26 c0       	rjmp	.+76     	; 0x2c80 <inverse>
    2c34:	08 95       	ret

00002c36 <__fp_powser>:
    2c36:	df 93       	push	r29
    2c38:	cf 93       	push	r28
    2c3a:	1f 93       	push	r17
    2c3c:	0f 93       	push	r16
    2c3e:	ff 92       	push	r15
    2c40:	ef 92       	push	r14
    2c42:	df 92       	push	r13
    2c44:	7b 01       	movw	r14, r22
    2c46:	8c 01       	movw	r16, r24
    2c48:	68 94       	set
    2c4a:	05 c0       	rjmp	.+10     	; 0x2c56 <__fp_powser+0x20>
    2c4c:	da 2e       	mov	r13, r26
    2c4e:	ef 01       	movw	r28, r30
    2c50:	1a df       	rcall	.-460    	; 0x2a86 <__mulsf3x>
__fp_powser():
    2c52:	fe 01       	movw	r30, r28
    2c54:	e8 94       	clt
    2c56:	a5 91       	lpm	r26, Z+
    2c58:	25 91       	lpm	r18, Z+
    2c5a:	35 91       	lpm	r19, Z+
    2c5c:	45 91       	lpm	r20, Z+
    2c5e:	55 91       	lpm	r21, Z+
    2c60:	ae f3       	brts	.-22     	; 0x2c4c <__fp_powser+0x16>
    2c62:	ef 01       	movw	r28, r30
    2c64:	11 dd       	rcall	.-1502   	; 0x2688 <__addsf3x>
    2c66:	fe 01       	movw	r30, r28
    2c68:	97 01       	movw	r18, r14
    2c6a:	a8 01       	movw	r20, r16
    2c6c:	da 94       	dec	r13
    2c6e:	79 f7       	brne	.-34     	; 0x2c4e <__fp_powser+0x18>
    2c70:	df 90       	pop	r13
    2c72:	ef 90       	pop	r14
    2c74:	ff 90       	pop	r15
    2c76:	0f 91       	pop	r16
    2c78:	1f 91       	pop	r17
    2c7a:	cf 91       	pop	r28
    2c7c:	df 91       	pop	r29
    2c7e:	08 95       	ret

00002c80 <inverse>:
inverse():
    2c80:	9b 01       	movw	r18, r22
    2c82:	ac 01       	movw	r20, r24
    2c84:	60 e0       	ldi	r22, 0x00	; 0
    2c86:	70 e0       	ldi	r23, 0x00	; 0
    2c88:	80 e8       	ldi	r24, 0x80	; 128
    2c8a:	9f e3       	ldi	r25, 0x3F	; 63
    2c8c:	54 cd       	rjmp	.-1368   	; 0x2736 <__divsf3>
    2c8e:	8a ce       	rjmp	.-748    	; 0x29a4 <__fp_inf>
    2c90:	ac c0       	rjmp	.+344    	; 0x2dea <__fp_mpack>

00002c92 <ldexp>:
ldexp():
    2c92:	c8 de       	rcall	.-624    	; 0x2a24 <__fp_splitA>
    2c94:	e8 f3       	brcs	.-6      	; 0x2c90 <inverse+0x10>
    2c96:	99 23       	and	r25, r25
    2c98:	d9 f3       	breq	.-10     	; 0x2c90 <inverse+0x10>
    2c9a:	94 0f       	add	r25, r20
    2c9c:	51 1d       	adc	r21, r1
    2c9e:	bb f3       	brvs	.-18     	; 0x2c8e <inverse+0xe>
    2ca0:	91 50       	subi	r25, 0x01	; 1
    2ca2:	50 40       	sbci	r21, 0x00	; 0
    2ca4:	94 f0       	brlt	.+36     	; 0x2cca <ldexp+0x38>
    2ca6:	59 f0       	breq	.+22     	; 0x2cbe <ldexp+0x2c>
    2ca8:	88 23       	and	r24, r24
    2caa:	32 f0       	brmi	.+12     	; 0x2cb8 <ldexp+0x26>
    2cac:	66 0f       	add	r22, r22
    2cae:	77 1f       	adc	r23, r23
    2cb0:	88 1f       	adc	r24, r24
    2cb2:	91 50       	subi	r25, 0x01	; 1
    2cb4:	50 40       	sbci	r21, 0x00	; 0
    2cb6:	c1 f7       	brne	.-16     	; 0x2ca8 <ldexp+0x16>
    2cb8:	9e 3f       	cpi	r25, 0xFE	; 254
    2cba:	51 05       	cpc	r21, r1
    2cbc:	44 f7       	brge	.-48     	; 0x2c8e <inverse+0xe>
    2cbe:	88 0f       	add	r24, r24
    2cc0:	91 1d       	adc	r25, r1
    2cc2:	96 95       	lsr	r25
    2cc4:	87 95       	ror	r24
    2cc6:	97 f9       	bld	r25, 7
    2cc8:	08 95       	ret
    2cca:	5f 3f       	cpi	r21, 0xFF	; 255
    2ccc:	ac f0       	brlt	.+42     	; 0x2cf8 <ldexp+0x66>
    2cce:	98 3e       	cpi	r25, 0xE8	; 232
    2cd0:	9c f0       	brlt	.+38     	; 0x2cf8 <ldexp+0x66>
    2cd2:	bb 27       	eor	r27, r27
    2cd4:	86 95       	lsr	r24
    2cd6:	77 95       	ror	r23
    2cd8:	67 95       	ror	r22
    2cda:	b7 95       	ror	r27
    2cdc:	08 f4       	brcc	.+2      	; 0x2ce0 <ldexp+0x4e>
    2cde:	b1 60       	ori	r27, 0x01	; 1
    2ce0:	93 95       	inc	r25
    2ce2:	c1 f7       	brne	.-16     	; 0x2cd4 <ldexp+0x42>
    2ce4:	bb 0f       	add	r27, r27
    2ce6:	58 f7       	brcc	.-42     	; 0x2cbe <ldexp+0x2c>
    2ce8:	11 f4       	brne	.+4      	; 0x2cee <ldexp+0x5c>
    2cea:	60 ff       	sbrs	r22, 0
    2cec:	e8 cf       	rjmp	.-48     	; 0x2cbe <ldexp+0x2c>
    2cee:	6f 5f       	subi	r22, 0xFF	; 255
    2cf0:	7f 4f       	sbci	r23, 0xFF	; 255
    2cf2:	8f 4f       	sbci	r24, 0xFF	; 255
    2cf4:	9f 4f       	sbci	r25, 0xFF	; 255
    2cf6:	e3 cf       	rjmp	.-58     	; 0x2cbe <ldexp+0x2c>
    2cf8:	b0 ce       	rjmp	.-672    	; 0x2a5a <__fp_szero>
    2cfa:	0e f0       	brts	.+2      	; 0x2cfe <ldexp+0x6c>
    2cfc:	76 c0       	rjmp	.+236    	; 0x2dea <__fp_mpack>
    2cfe:	58 ce       	rjmp	.-848    	; 0x29b0 <__fp_nan>
    2d00:	68 94       	set
    2d02:	50 ce       	rjmp	.-864    	; 0x29a4 <__fp_inf>

00002d04 <log>:
    2d04:	8f de       	rcall	.-738    	; 0x2a24 <__fp_splitA>
log():
    2d06:	c8 f3       	brcs	.-14     	; 0x2cfa <ldexp+0x68>
    2d08:	99 23       	and	r25, r25
    2d0a:	d1 f3       	breq	.-12     	; 0x2d00 <ldexp+0x6e>
    2d0c:	c6 f3       	brts	.-16     	; 0x2cfe <ldexp+0x6c>
    2d0e:	df 93       	push	r29
    2d10:	cf 93       	push	r28
    2d12:	1f 93       	push	r17
    2d14:	0f 93       	push	r16
    2d16:	ff 92       	push	r15
    2d18:	c9 2f       	mov	r28, r25
    2d1a:	dd 27       	eor	r29, r29
    2d1c:	88 23       	and	r24, r24
    2d1e:	2a f0       	brmi	.+10     	; 0x2d2a <log+0x26>
    2d20:	21 97       	sbiw	r28, 0x01	; 1
    2d22:	66 0f       	add	r22, r22
    2d24:	77 1f       	adc	r23, r23
    2d26:	88 1f       	adc	r24, r24
    2d28:	da f7       	brpl	.-10     	; 0x2d20 <log+0x1c>
    2d2a:	20 e0       	ldi	r18, 0x00	; 0
    2d2c:	30 e0       	ldi	r19, 0x00	; 0
    2d2e:	40 e8       	ldi	r20, 0x80	; 128
    2d30:	5f eb       	ldi	r21, 0xBF	; 191
    2d32:	9f e3       	ldi	r25, 0x3F	; 63
    2d34:	88 39       	cpi	r24, 0x98	; 152
    2d36:	20 f0       	brcs	.+8      	; 0x2d40 <log+0x3c>
    2d38:	80 3e       	cpi	r24, 0xE0	; 224
    2d3a:	30 f0       	brcs	.+12     	; 0x2d48 <log+0x44>
    2d3c:	21 96       	adiw	r28, 0x01	; 1
    2d3e:	8f 77       	andi	r24, 0x7F	; 127
    2d40:	92 dc       	rcall	.-1756   	; 0x2666 <__addsf3>
    2d42:	e0 ea       	ldi	r30, 0xA0	; 160
    2d44:	f0 e0       	ldi	r31, 0x00	; 0
    2d46:	03 c0       	rjmp	.+6      	; 0x2d4e <log+0x4a>
    2d48:	8e dc       	rcall	.-1764   	; 0x2666 <__addsf3>
    2d4a:	ed ec       	ldi	r30, 0xCD	; 205
    2d4c:	f0 e0       	ldi	r31, 0x00	; 0
    2d4e:	73 df       	rcall	.-282    	; 0x2c36 <__fp_powser>
    2d50:	8b 01       	movw	r16, r22
    2d52:	be 01       	movw	r22, r28
    2d54:	ec 01       	movw	r28, r24
    2d56:	fb 2e       	mov	r15, r27
    2d58:	6f 57       	subi	r22, 0x7F	; 127
    2d5a:	71 09       	sbc	r23, r1
    2d5c:	75 95       	asr	r23
    2d5e:	77 1f       	adc	r23, r23
    2d60:	88 0b       	sbc	r24, r24
    2d62:	99 0b       	sbc	r25, r25
    2d64:	82 dd       	rcall	.-1276   	; 0x286a <__floatsisf>
    2d66:	28 e1       	ldi	r18, 0x18	; 24
    2d68:	32 e7       	ldi	r19, 0x72	; 114
    2d6a:	41 e3       	ldi	r20, 0x31	; 49
    2d6c:	5f e3       	ldi	r21, 0x3F	; 63
    2d6e:	8b de       	rcall	.-746    	; 0x2a86 <__mulsf3x>
    2d70:	af 2d       	mov	r26, r15
    2d72:	98 01       	movw	r18, r16
    2d74:	ae 01       	movw	r20, r28
    2d76:	ff 90       	pop	r15
    2d78:	0f 91       	pop	r16
    2d7a:	1f 91       	pop	r17
    2d7c:	cf 91       	pop	r28
    2d7e:	df 91       	pop	r29
    2d80:	83 dc       	rcall	.-1786   	; 0x2688 <__addsf3x>
    2d82:	37 ce       	rjmp	.-914    	; 0x29f2 <__fp_round>

00002d84 <modf>:
    2d84:	fa 01       	movw	r30, r20
    2d86:	dc 01       	movw	r26, r24
    2d88:	aa 0f       	add	r26, r26
    2d8a:	bb 1f       	adc	r27, r27
    2d8c:	9b 01       	movw	r18, r22
    2d8e:	ac 01       	movw	r20, r24
    2d90:	bf 57       	subi	r27, 0x7F	; 127
    2d92:	28 f4       	brcc	.+10     	; 0x2d9e <modf+0x1a>
    2d94:	22 27       	eor	r18, r18
    2d96:	33 27       	eor	r19, r19
    2d98:	44 27       	eor	r20, r20
    2d9a:	50 78       	andi	r21, 0x80	; 128
    2d9c:	1f c0       	rjmp	.+62     	; 0x2ddc <modf+0x58>
    2d9e:	b7 51       	subi	r27, 0x17	; 23
    2da0:	88 f4       	brcc	.+34     	; 0x2dc4 <modf+0x40>
    2da2:	ab 2f       	mov	r26, r27
modf():
    2da4:	00 24       	eor	r0, r0
    2da6:	46 95       	lsr	r20
    2da8:	37 95       	ror	r19
    2daa:	27 95       	ror	r18
    2dac:	01 1c       	adc	r0, r1
    2dae:	a3 95       	inc	r26
    2db0:	d2 f3       	brmi	.-12     	; 0x2da6 <modf+0x22>
    2db2:	00 20       	and	r0, r0
    2db4:	69 f0       	breq	.+26     	; 0x2dd0 <modf+0x4c>
    2db6:	22 0f       	add	r18, r18
    2db8:	33 1f       	adc	r19, r19
    2dba:	44 1f       	adc	r20, r20
    2dbc:	b3 95       	inc	r27
    2dbe:	da f3       	brmi	.-10     	; 0x2db6 <modf+0x32>
    2dc0:	0d d0       	rcall	.+26     	; 0x2ddc <modf+0x58>
    2dc2:	50 cc       	rjmp	.-1888   	; 0x2664 <__subsf3>
    2dc4:	61 30       	cpi	r22, 0x01	; 1
    2dc6:	71 05       	cpc	r23, r1
    2dc8:	a0 e8       	ldi	r26, 0x80	; 128
    2dca:	8a 07       	cpc	r24, r26
    2dcc:	b9 46       	sbci	r27, 0x69	; 105
    2dce:	30 f4       	brcc	.+12     	; 0x2ddc <modf+0x58>
    2dd0:	9b 01       	movw	r18, r22
    2dd2:	ac 01       	movw	r20, r24
    2dd4:	66 27       	eor	r22, r22
    2dd6:	77 27       	eor	r23, r23
    2dd8:	88 27       	eor	r24, r24
    2dda:	90 78       	andi	r25, 0x80	; 128
    2ddc:	30 96       	adiw	r30, 0x00	; 0
    2dde:	21 f0       	breq	.+8      	; 0x2de8 <modf+0x64>
    2de0:	20 83       	st	Z, r18
    2de2:	31 83       	std	Z+1, r19	; 0x01
    2de4:	42 83       	std	Z+2, r20	; 0x02
    2de6:	53 83       	std	Z+3, r21	; 0x03
    2de8:	08 95       	ret

00002dea <__fp_mpack>:
__fp_mpack():
    2dea:	9f 3f       	cpi	r25, 0xFF	; 255
    2dec:	31 f0       	breq	.+12     	; 0x2dfa <__fp_mpack_finite+0xc>

00002dee <__fp_mpack_finite>:
    2dee:	91 50       	subi	r25, 0x01	; 1
    2df0:	20 f4       	brcc	.+8      	; 0x2dfa <__fp_mpack_finite+0xc>
    2df2:	87 95       	ror	r24
    2df4:	77 95       	ror	r23
    2df6:	67 95       	ror	r22
    2df8:	b7 95       	ror	r27
    2dfa:	88 0f       	add	r24, r24
    2dfc:	91 1d       	adc	r25, r1
    2dfe:	96 95       	lsr	r25
    2e00:	87 95       	ror	r24
    2e02:	97 f9       	bld	r25, 7
    2e04:	08 95       	ret

00002e06 <__mulsi3>:
__mulsi3():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:648
    2e06:	db 01       	movw	r26, r22
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:649
    2e08:	8f 93       	push	r24
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:650
    2e0a:	9f 93       	push	r25
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:651
    2e0c:	2d d0       	rcall	.+90     	; 0x2e68 <__muluhisi3>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:652
    2e0e:	bf 91       	pop	r27
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:653
    2e10:	af 91       	pop	r26
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:655
    2e12:	a2 9f       	mul	r26, r18
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:656
    2e14:	80 0d       	add	r24, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:657
    2e16:	91 1d       	adc	r25, r1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:658
    2e18:	a3 9f       	mul	r26, r19
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:659
    2e1a:	90 0d       	add	r25, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:660
    2e1c:	b2 9f       	mul	r27, r18
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:661
    2e1e:	90 0d       	add	r25, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:662
    2e20:	11 24       	eor	r1, r1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:663
    2e22:	08 95       	ret

00002e24 <__udivmodsi4>:
__udivmodsi4():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1638
    2e24:	a1 e2       	ldi	r26, 0x21	; 33
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1639
    2e26:	1a 2e       	mov	r1, r26
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1640
    2e28:	aa 1b       	sub	r26, r26
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1641
    2e2a:	bb 1b       	sub	r27, r27
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1642
    2e2c:	fd 01       	movw	r30, r26
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1644
    2e2e:	0d c0       	rjmp	.+26     	; 0x2e4a <__udivmodsi4_ep>

00002e30 <__udivmodsi4_loop>:
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1646
    2e30:	aa 1f       	adc	r26, r26
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1647
    2e32:	bb 1f       	adc	r27, r27
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1648
    2e34:	ee 1f       	adc	r30, r30
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1649
    2e36:	ff 1f       	adc	r31, r31
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1650
    2e38:	a2 17       	cp	r26, r18
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1651
    2e3a:	b3 07       	cpc	r27, r19
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1652
    2e3c:	e4 07       	cpc	r30, r20
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1653
    2e3e:	f5 07       	cpc	r31, r21
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1654
    2e40:	20 f0       	brcs	.+8      	; 0x2e4a <__udivmodsi4_ep>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1655
    2e42:	a2 1b       	sub	r26, r18
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1656
    2e44:	b3 0b       	sbc	r27, r19
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1657
    2e46:	e4 0b       	sbc	r30, r20
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1658
    2e48:	f5 0b       	sbc	r31, r21

00002e4a <__udivmodsi4_ep>:
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1660
    2e4a:	66 1f       	adc	r22, r22
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1661
    2e4c:	77 1f       	adc	r23, r23
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1662
    2e4e:	88 1f       	adc	r24, r24
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1663
    2e50:	99 1f       	adc	r25, r25
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1664
    2e52:	1a 94       	dec	r1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1665
    2e54:	69 f7       	brne	.-38     	; 0x2e30 <__udivmodsi4_loop>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1667
    2e56:	60 95       	com	r22
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1668
    2e58:	70 95       	com	r23
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1669
    2e5a:	80 95       	com	r24
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1670
    2e5c:	90 95       	com	r25
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1672
    2e5e:	9b 01       	movw	r18, r22
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1674
    2e60:	ac 01       	movw	r20, r24
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1676
    2e62:	bd 01       	movw	r22, r26
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1678
    2e64:	cf 01       	movw	r24, r30
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1680
    2e66:	08 95       	ret

00002e68 <__muluhisi3>:
__muluhisi3():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:626
    2e68:	52 d1       	rcall	.+676    	; 0x310e <__umulhisi3>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:627
    2e6a:	a5 9f       	mul	r26, r21
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:628
    2e6c:	90 0d       	add	r25, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:629
    2e6e:	b4 9f       	mul	r27, r20
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:630
    2e70:	90 0d       	add	r25, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:631
    2e72:	a4 9f       	mul	r26, r20
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:632
    2e74:	80 0d       	add	r24, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:633
    2e76:	91 1d       	adc	r25, r1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:634
    2e78:	11 24       	eor	r1, r1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:635
    2e7a:	08 95       	ret

00002e7c <__mulshisi3>:
__mulshisi3():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:603
    2e7c:	b7 ff       	sbrs	r27, 7
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:605
    2e7e:	f4 cf       	rjmp	.-24     	; 0x2e68 <__muluhisi3>

00002e80 <__mulohisi3>:
__mulohisi3():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:613
    2e80:	f3 df       	rcall	.-26     	; 0x2e68 <__muluhisi3>
    2e82:	82 1b       	sub	r24, r18
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:615
    2e84:	93 0b       	sbc	r25, r19
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:616
    2e86:	08 95       	ret

00002e88 <__muldi3>:
__muldi3():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:617
    2e88:	df 93       	push	r29
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:895
    2e8a:	cf 93       	push	r28
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:896
    2e8c:	1f 93       	push	r17
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:897
    2e8e:	0f 93       	push	r16
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:902
    2e90:	9a 9d       	mul	r25, r10
    2e92:	f0 2d       	mov	r31, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:903
    2e94:	21 9f       	mul	r18, r17
    2e96:	f0 0d       	add	r31, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:904
    2e98:	8b 9d       	mul	r24, r11
    2e9a:	f0 0d       	add	r31, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:905
    2e9c:	8a 9d       	mul	r24, r10
    2e9e:	e0 2d       	mov	r30, r0
    2ea0:	f1 0d       	add	r31, r1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:906
    2ea2:	03 9f       	mul	r16, r19
    2ea4:	f0 0d       	add	r31, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:907
    2ea6:	02 9f       	mul	r16, r18
    2ea8:	e0 0d       	add	r30, r0
    2eaa:	f1 1d       	adc	r31, r1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:910
    2eac:	4e 9d       	mul	r20, r14
    2eae:	e0 0d       	add	r30, r0
    2eb0:	f1 1d       	adc	r31, r1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:911
    2eb2:	5e 9d       	mul	r21, r14
    2eb4:	f0 0d       	add	r31, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:912
    2eb6:	4f 9d       	mul	r20, r15
    2eb8:	f0 0d       	add	r31, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:914
    2eba:	7f 93       	push	r23
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:915
    2ebc:	6f 93       	push	r22
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:916
    2ebe:	bf 92       	push	r11
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:917
    2ec0:	af 92       	push	r10
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:918
    2ec2:	5f 93       	push	r21
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:919
    2ec4:	4f 93       	push	r20
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:922
    2ec6:	d5 01       	movw	r26, r10
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:923
    2ec8:	22 d1       	rcall	.+580    	; 0x310e <__umulhisi3>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:924
    2eca:	8b 01       	movw	r16, r22
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:925
    2ecc:	ac 01       	movw	r20, r24
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:929
    2ece:	d7 01       	movw	r26, r14
    2ed0:	1e d1       	rcall	.+572    	; 0x310e <__umulhisi3>
    2ed2:	eb 01       	movw	r28, r22
    2ed4:	e8 0f       	add	r30, r24
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:931
    2ed6:	f9 1f       	adc	r31, r25
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:933
    2ed8:	d6 01       	movw	r26, r12
    2eda:	1e d0       	rcall	.+60     	; 0x2f18 <__muldi3_6>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:936
    2edc:	2f 91       	pop	r18
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:938
    2ede:	3f 91       	pop	r19
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:939
    2ee0:	d6 01       	movw	r26, r12
    2ee2:	15 d1       	rcall	.+554    	; 0x310e <__umulhisi3>
    2ee4:	c6 0f       	add	r28, r22
    2ee6:	d7 1f       	adc	r29, r23
    2ee8:	e8 1f       	adc	r30, r24
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:941
    2eea:	f9 1f       	adc	r31, r25
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:944
    2eec:	af 91       	pop	r26
    2eee:	bf 91       	pop	r27
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:946
    2ef0:	13 d0       	rcall	.+38     	; 0x2f18 <__muldi3_6>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:947
    2ef2:	2f 91       	pop	r18
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:949
    2ef4:	3f 91       	pop	r19
    2ef6:	0b d1       	rcall	.+534    	; 0x310e <__umulhisi3>
    2ef8:	c6 0f       	add	r28, r22
    2efa:	d7 1f       	adc	r29, r23
    2efc:	e8 1f       	adc	r30, r24
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:952
    2efe:	f9 1f       	adc	r31, r25
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:953
    2f00:	d6 01       	movw	r26, r12
    2f02:	05 d1       	rcall	.+522    	; 0x310e <__umulhisi3>
    2f04:	e6 0f       	add	r30, r22
    2f06:	f7 1f       	adc	r31, r23
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:956
    2f08:	98 01       	movw	r18, r16
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:958
    2f0a:	be 01       	movw	r22, r28
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:959
    2f0c:	cf 01       	movw	r24, r30
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:961
    2f0e:	0f 91       	pop	r16
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:962
    2f10:	1f 91       	pop	r17
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:963
    2f12:	cf 91       	pop	r28
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:964
    2f14:	df 91       	pop	r29
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:965
    2f16:	08 95       	ret

00002f18 <__muldi3_6>:
__muldi3_6():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:973
    2f18:	fa d0       	rcall	.+500    	; 0x310e <__umulhisi3>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:974
    2f1a:	46 0f       	add	r20, r22
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:975
    2f1c:	57 1f       	adc	r21, r23
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:976
    2f1e:	c8 1f       	adc	r28, r24
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:977
    2f20:	d9 1f       	adc	r29, r25
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:978
    2f22:	08 f4       	brcc	.+2      	; 0x2f26 <__muldi3_6+0xe>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:979
    2f24:	31 96       	adiw	r30, 0x01	; 1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:980
    2f26:	08 95       	ret

00002f28 <__moddi3>:
__moddi3():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1964
    2f28:	68 94       	set
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1965
    2f2a:	01 c0       	rjmp	.+2      	; 0x2f2e <__divdi3_moddi3>

00002f2c <__divdi3>:
__divdi3():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1972
    2f2c:	e8 94       	clt

00002f2e <__divdi3_moddi3>:
__divdi3_moddi3():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1977
    2f2e:	f9 2f       	mov	r31, r25
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1978
    2f30:	f1 2b       	or	r31, r17
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1979
    2f32:	0a f0       	brmi	.+2      	; 0x2f36 <__divdi3_moddi3+0x8>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1981
    2f34:	27 c0       	rjmp	.+78     	; 0x2f84 <__udivdi3_umoddi3>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1987
    2f36:	a0 e0       	ldi	r26, 0x00	; 0
    2f38:	b0 e0       	ldi	r27, 0x00	; 0
    2f3a:	e0 ea       	ldi	r30, 0xA0	; 160
    2f3c:	f7 e1       	ldi	r31, 0x17	; 23
    2f3e:	67 cb       	rjmp	.-2354   	; 0x260e <__prologue_saves__+0xc>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1991
    2f40:	09 2e       	mov	r0, r25
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1997
    2f42:	05 94       	asr	r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2002
    2f44:	1a f4       	brpl	.+6      	; 0x2f4c <__divdi3_moddi3+0x1e>
    2f46:	79 d0       	rcall	.+242    	; 0x303a <__negdi2>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2005
    2f48:	11 23       	and	r17, r17
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2006
    2f4a:	92 f4       	brpl	.+36     	; 0x2f70 <__divdi3_moddi3+0x42>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2007
    2f4c:	f0 e8       	ldi	r31, 0x80	; 128
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2008
    2f4e:	0f 26       	eor	r0, r31
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2010
    2f50:	ff ef       	ldi	r31, 0xFF	; 255
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2011
    2f52:	e0 94       	com	r14
    2f54:	f0 94       	com	r15
    2f56:	00 95       	com	r16
    2f58:	10 95       	com	r17
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2012
    2f5a:	b0 94       	com	r11
    2f5c:	c0 94       	com	r12
    2f5e:	d0 94       	com	r13
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2013
    2f60:	a1 94       	neg	r10
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2014
    2f62:	bf 0a       	sbc	r11, r31
    2f64:	cf 0a       	sbc	r12, r31
    2f66:	df 0a       	sbc	r13, r31
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2015
    2f68:	ef 0a       	sbc	r14, r31
    2f6a:	ff 0a       	sbc	r15, r31
    2f6c:	0f 0b       	sbc	r16, r31
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2018
    2f6e:	1f 0b       	sbc	r17, r31
    2f70:	13 d0       	rcall	.+38     	; 0x2f98 <__udivmod64>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2025
    2f72:	07 fc       	sbrc	r0, 7
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2027
    2f74:	62 d0       	rcall	.+196    	; 0x303a <__negdi2>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2030
    2f76:	cd b7       	in	r28, 0x3d	; 61
    2f78:	de b7       	in	r29, 0x3e	; 62
    2f7a:	ec e0       	ldi	r30, 0x0C	; 12
    2f7c:	61 cb       	rjmp	.-2366   	; 0x2640 <__epilogue_restores__+0xc>

00002f7e <__umoddi3>:
__umoddi3():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1806
    2f7e:	68 94       	set
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1807
    2f80:	01 c0       	rjmp	.+2      	; 0x2f84 <__udivdi3_umoddi3>

00002f82 <__udivdi3>:
__udivdi3():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1814
    2f82:	e8 94       	clt

00002f84 <__udivdi3_umoddi3>:
__udivdi3_umoddi3():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1818
    2f84:	8f 92       	push	r8
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1819
    2f86:	9f 92       	push	r9
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1820
    2f88:	cf 93       	push	r28
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1821
    2f8a:	df 93       	push	r29
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1822
    2f8c:	05 d0       	rcall	.+10     	; 0x2f98 <__udivmod64>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1823
    2f8e:	df 91       	pop	r29
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1824
    2f90:	cf 91       	pop	r28
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1825
    2f92:	9f 90       	pop	r9
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1826
    2f94:	8f 90       	pop	r8
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1827
    2f96:	08 95       	ret

00002f98 <__udivmod64>:
__udivmod64():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1842
    2f98:	88 24       	eor	r8, r8
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1843
    2f9a:	99 24       	eor	r9, r9
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1844
    2f9c:	f4 01       	movw	r30, r8
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1845
    2f9e:	e4 01       	movw	r28, r8
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1846
    2fa0:	b0 e4       	ldi	r27, 0x40	; 64
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1856
    2fa2:	9f 93       	push	r25
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1857
    2fa4:	aa 27       	eor	r26, r26
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1861
    2fa6:	9a 15       	cp	r25, r10
    2fa8:	8b 04       	cpc	r8, r11
    2faa:	9c 04       	cpc	r9, r12
    2fac:	ed 05       	cpc	r30, r13
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1862
    2fae:	fe 05       	cpc	r31, r14
    2fb0:	cf 05       	cpc	r28, r15
    2fb2:	d0 07       	cpc	r29, r16
    2fb4:	a1 07       	cpc	r26, r17
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1863
    2fb6:	98 f4       	brcc	.+38     	; 0x2fde <__udivmod64+0x46>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1866
    2fb8:	ad 2f       	mov	r26, r29
    2fba:	dc 2f       	mov	r29, r28
    2fbc:	cf 2f       	mov	r28, r31
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1867
    2fbe:	fe 2f       	mov	r31, r30
    2fc0:	e9 2d       	mov	r30, r9
    2fc2:	98 2c       	mov	r9, r8
    2fc4:	89 2e       	mov	r8, r25
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1868
    2fc6:	98 2f       	mov	r25, r24
    2fc8:	87 2f       	mov	r24, r23
    2fca:	76 2f       	mov	r23, r22
    2fcc:	65 2f       	mov	r22, r21
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1869
    2fce:	54 2f       	mov	r21, r20
    2fd0:	43 2f       	mov	r20, r19
    2fd2:	32 2f       	mov	r19, r18
    2fd4:	22 27       	eor	r18, r18
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1872
    2fd6:	b8 50       	subi	r27, 0x08	; 8
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1873
    2fd8:	31 f7       	brne	.-52     	; 0x2fa6 <__udivmod64+0xe>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1876
    2fda:	bf 91       	pop	r27
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1881
    2fdc:	27 c0       	rjmp	.+78     	; 0x302c <__udivmod64+0x94>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1884
    2fde:	1b 2e       	mov	r1, r27
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1887
    2fe0:	bf 91       	pop	r27
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1888
    2fe2:	bb 27       	eor	r27, r27
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1916
    2fe4:	22 0f       	add	r18, r18
    2fe6:	33 1f       	adc	r19, r19
    2fe8:	44 1f       	adc	r20, r20
    2fea:	55 1f       	adc	r21, r21
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1917
    2fec:	66 1f       	adc	r22, r22
    2fee:	77 1f       	adc	r23, r23
    2ff0:	88 1f       	adc	r24, r24
    2ff2:	99 1f       	adc	r25, r25
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1920
    2ff4:	88 1c       	adc	r8, r8
    2ff6:	99 1c       	adc	r9, r9
    2ff8:	ee 1f       	adc	r30, r30
    2ffa:	ff 1f       	adc	r31, r31
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1921
    2ffc:	cc 1f       	adc	r28, r28
    2ffe:	dd 1f       	adc	r29, r29
    3000:	aa 1f       	adc	r26, r26
    3002:	bb 1f       	adc	r27, r27
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1924
    3004:	8a 14       	cp	r8, r10
    3006:	9b 04       	cpc	r9, r11
    3008:	ec 05       	cpc	r30, r12
    300a:	fd 05       	cpc	r31, r13
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1925
    300c:	ce 05       	cpc	r28, r14
    300e:	df 05       	cpc	r29, r15
    3010:	a0 07       	cpc	r26, r16
    3012:	b1 07       	cpc	r27, r17
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1927
    3014:	48 f0       	brcs	.+18     	; 0x3028 <__udivmod64+0x90>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1930
    3016:	8a 18       	sub	r8, r10
    3018:	9b 08       	sbc	r9, r11
    301a:	ec 09       	sbc	r30, r12
    301c:	fd 09       	sbc	r31, r13
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1931
    301e:	ce 09       	sbc	r28, r14
    3020:	df 09       	sbc	r29, r15
    3022:	a0 0b       	sbc	r26, r16
    3024:	b1 0b       	sbc	r27, r17
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1935
    3026:	21 60       	ori	r18, 0x01	; 1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1938
    3028:	1a 94       	dec	r1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1939
    302a:	e1 f6       	brne	.-72     	; 0x2fe4 <__udivmod64+0x4c>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1944
    302c:	2e f4       	brtc	.+10     	; 0x3038 <__udivmod64+0xa0>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1945
    302e:	94 01       	movw	r18, r8
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1946
    3030:	af 01       	movw	r20, r30
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1947
    3032:	be 01       	movw	r22, r28
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1948
    3034:	cd 01       	movw	r24, r26
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1950
    3036:	00 0c       	add	r0, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1952
    3038:	08 95       	ret

0000303a <__negdi2>:
__negdi2():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2117
    303a:	60 95       	com	r22
    303c:	70 95       	com	r23
    303e:	80 95       	com	r24
    3040:	90 95       	com	r25
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2118
    3042:	30 95       	com	r19
    3044:	40 95       	com	r20
    3046:	50 95       	com	r21
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2119
    3048:	21 95       	neg	r18
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2120
    304a:	3f 4f       	sbci	r19, 0xFF	; 255
    304c:	4f 4f       	sbci	r20, 0xFF	; 255
    304e:	5f 4f       	sbci	r21, 0xFF	; 255
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2121
    3050:	6f 4f       	sbci	r22, 0xFF	; 255
    3052:	7f 4f       	sbci	r23, 0xFF	; 255
    3054:	8f 4f       	sbci	r24, 0xFF	; 255
    3056:	9f 4f       	sbci	r25, 0xFF	; 255
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2122
    3058:	08 95       	ret

0000305a <__ashldi3>:
__ashldi3():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3169
    305a:	00 2e       	mov	r0, r16
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3170
    305c:	08 30       	cpi	r16, 0x08	; 8
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3171
    305e:	90 f0       	brcs	.+36     	; 0x3084 <__ashldi3+0x2a>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3172
    3060:	98 2f       	mov	r25, r24
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3173
    3062:	87 2f       	mov	r24, r23
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3174
    3064:	76 2f       	mov	r23, r22
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3175
    3066:	65 2f       	mov	r22, r21
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3176
    3068:	54 2f       	mov	r21, r20
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3177
    306a:	43 2f       	mov	r20, r19
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3178
    306c:	32 2f       	mov	r19, r18
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3179
    306e:	22 27       	eor	r18, r18
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3180
    3070:	08 50       	subi	r16, 0x08	; 8
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3181
    3072:	f4 cf       	rjmp	.-24     	; 0x305c <__ashldi3+0x2>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3182
    3074:	22 0f       	add	r18, r18
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3183
    3076:	33 1f       	adc	r19, r19
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3184
    3078:	44 1f       	adc	r20, r20
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3185
    307a:	55 1f       	adc	r21, r21
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3186
    307c:	66 1f       	adc	r22, r22
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3187
    307e:	77 1f       	adc	r23, r23
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3188
    3080:	88 1f       	adc	r24, r24
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3189
    3082:	99 1f       	adc	r25, r25
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3190
    3084:	0a 95       	dec	r16
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3191
    3086:	b2 f7       	brpl	.-20     	; 0x3074 <__ashldi3+0x1a>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3192
    3088:	00 2d       	mov	r16, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3193
    308a:	08 95       	ret

0000308c <__ashrdi3>:
__ashrdi3():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3122
    308c:	97 fd       	sbrc	r25, 7
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3123
    308e:	10 94       	com	r1

00003090 <__lshrdi3>:
__lshrdi3():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3131
    3090:	00 2e       	mov	r0, r16
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3132
    3092:	08 30       	cpi	r16, 0x08	; 8
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3133
    3094:	98 f0       	brcs	.+38     	; 0x30bc <__lshrdi3+0x2c>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3134
    3096:	08 50       	subi	r16, 0x08	; 8
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3135
    3098:	23 2f       	mov	r18, r19
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3136
    309a:	34 2f       	mov	r19, r20
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3137
    309c:	45 2f       	mov	r20, r21
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3138
    309e:	56 2f       	mov	r21, r22
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3139
    30a0:	67 2f       	mov	r22, r23
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3140
    30a2:	78 2f       	mov	r23, r24
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3141
    30a4:	89 2f       	mov	r24, r25
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3142
    30a6:	91 2d       	mov	r25, r1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3143
    30a8:	f4 cf       	rjmp	.-24     	; 0x3092 <__lshrdi3+0x2>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3144
    30aa:	15 94       	asr	r1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3145
    30ac:	97 95       	ror	r25
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3146
    30ae:	87 95       	ror	r24
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3147
    30b0:	77 95       	ror	r23
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3148
    30b2:	67 95       	ror	r22
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3149
    30b4:	57 95       	ror	r21
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3150
    30b6:	47 95       	ror	r20
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3151
    30b8:	37 95       	ror	r19
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3152
    30ba:	27 95       	ror	r18
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3153
    30bc:	0a 95       	dec	r16
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3154
    30be:	aa f7       	brpl	.-22     	; 0x30aa <__lshrdi3+0x1a>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3155
    30c0:	11 24       	eor	r1, r1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3156
    30c2:	00 2d       	mov	r16, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3157
    30c4:	08 95       	ret

000030c6 <__adddi3>:
__adddi3():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2051
    30c6:	2a 0d       	add	r18, r10
    30c8:	3b 1d       	adc	r19, r11
    30ca:	4c 1d       	adc	r20, r12
    30cc:	5d 1d       	adc	r21, r13
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2052
    30ce:	6e 1d       	adc	r22, r14
    30d0:	7f 1d       	adc	r23, r15
    30d2:	80 1f       	adc	r24, r16
    30d4:	91 1f       	adc	r25, r17
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2053
    30d6:	08 95       	ret

000030d8 <__subdi3>:
__subdi3():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2080
    30d8:	2a 19       	sub	r18, r10
    30da:	3b 09       	sbc	r19, r11
    30dc:	4c 09       	sbc	r20, r12
    30de:	5d 09       	sbc	r21, r13
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2081
    30e0:	6e 09       	sbc	r22, r14
    30e2:	7f 09       	sbc	r23, r15
    30e4:	80 0b       	sbc	r24, r16
    30e6:	91 0b       	sbc	r25, r17
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2082
    30e8:	08 95       	ret

000030ea <__cmpdi2_s8>:
__cmpdi2_s8():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2102
    30ea:	00 24       	eor	r0, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2103
    30ec:	a7 fd       	sbrc	r26, 7
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2104
    30ee:	00 94       	com	r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2105
    30f0:	2a 17       	cp	r18, r26
    30f2:	30 05       	cpc	r19, r0
    30f4:	40 05       	cpc	r20, r0
    30f6:	50 05       	cpc	r21, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2106
    30f8:	60 05       	cpc	r22, r0
    30fa:	70 05       	cpc	r23, r0
    30fc:	80 05       	cpc	r24, r0
    30fe:	90 05       	cpc	r25, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2107
    3100:	08 95       	ret

00003102 <__tablejump2__>:
__tablejump2__():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2296
    3102:	ee 0f       	add	r30, r30
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2297
    3104:	ff 1f       	adc	r31, r31
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2328
    3106:	05 90       	lpm	r0, Z+
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2329
    3108:	f4 91       	lpm	r31, Z
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2330
    310a:	e0 2d       	mov	r30, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2331
    310c:	09 94       	ijmp

0000310e <__umulhisi3>:
__umulhisi3():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:564
    310e:	a2 9f       	mul	r26, r18
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:565
    3110:	b0 01       	movw	r22, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:566
    3112:	b3 9f       	mul	r27, r19
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:567
    3114:	c0 01       	movw	r24, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:568
    3116:	a3 9f       	mul	r26, r19
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:573
    3118:	70 0d       	add	r23, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:574
    311a:	81 1d       	adc	r24, r1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:575
    311c:	11 24       	eor	r1, r1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:576
    311e:	91 1d       	adc	r25, r1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:580
    3120:	b2 9f       	mul	r27, r18
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:581
    3122:	70 0d       	add	r23, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:582
    3124:	81 1d       	adc	r24, r1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:583
    3126:	11 24       	eor	r1, r1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:584
    3128:	91 1d       	adc	r25, r1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:585
    312a:	08 95       	ret

0000312c <malloc>:
malloc():
    312c:	0f 93       	push	r16
    312e:	1f 93       	push	r17
    3130:	cf 93       	push	r28
    3132:	df 93       	push	r29
    3134:	82 30       	cpi	r24, 0x02	; 2
    3136:	91 05       	cpc	r25, r1
    3138:	10 f4       	brcc	.+4      	; 0x313e <malloc+0x12>
    313a:	82 e0       	ldi	r24, 0x02	; 2
    313c:	90 e0       	ldi	r25, 0x00	; 0
    313e:	e0 91 38 39 	lds	r30, 0x3938	; 0x803938 <__flp>
    3142:	f0 91 39 39 	lds	r31, 0x3939	; 0x803939 <__flp+0x1>
    3146:	30 e0       	ldi	r19, 0x00	; 0
    3148:	20 e0       	ldi	r18, 0x00	; 0
    314a:	b0 e0       	ldi	r27, 0x00	; 0
    314c:	a0 e0       	ldi	r26, 0x00	; 0
    314e:	30 97       	sbiw	r30, 0x00	; 0
    3150:	99 f4       	brne	.+38     	; 0x3178 <malloc+0x4c>
    3152:	21 15       	cp	r18, r1
    3154:	31 05       	cpc	r19, r1
    3156:	09 f4       	brne	.+2      	; 0x315a <malloc+0x2e>
    3158:	4a c0       	rjmp	.+148    	; 0x31ee <malloc+0xc2>
    315a:	28 1b       	sub	r18, r24
    315c:	39 0b       	sbc	r19, r25
    315e:	24 30       	cpi	r18, 0x04	; 4
    3160:	31 05       	cpc	r19, r1
    3162:	d8 f5       	brcc	.+118    	; 0x31da <malloc+0xae>
    3164:	8a 81       	ldd	r24, Y+2	; 0x02
    3166:	9b 81       	ldd	r25, Y+3	; 0x03
    3168:	61 15       	cp	r22, r1
    316a:	71 05       	cpc	r23, r1
    316c:	89 f1       	breq	.+98     	; 0x31d0 <malloc+0xa4>
    316e:	fb 01       	movw	r30, r22
    3170:	82 83       	std	Z+2, r24	; 0x02
    3172:	93 83       	std	Z+3, r25	; 0x03
    3174:	fe 01       	movw	r30, r28
    3176:	11 c0       	rjmp	.+34     	; 0x319a <malloc+0x6e>
    3178:	40 81       	ld	r20, Z
    317a:	51 81       	ldd	r21, Z+1	; 0x01
    317c:	02 81       	ldd	r16, Z+2	; 0x02
    317e:	13 81       	ldd	r17, Z+3	; 0x03
    3180:	48 17       	cp	r20, r24
    3182:	59 07       	cpc	r21, r25
    3184:	e0 f0       	brcs	.+56     	; 0x31be <malloc+0x92>
    3186:	48 17       	cp	r20, r24
    3188:	59 07       	cpc	r21, r25
    318a:	99 f4       	brne	.+38     	; 0x31b2 <malloc+0x86>
    318c:	10 97       	sbiw	r26, 0x00	; 0
    318e:	61 f0       	breq	.+24     	; 0x31a8 <malloc+0x7c>
    3190:	12 96       	adiw	r26, 0x02	; 2
    3192:	0c 93       	st	X, r16
    3194:	12 97       	sbiw	r26, 0x02	; 2
    3196:	13 96       	adiw	r26, 0x03	; 3
    3198:	1c 93       	st	X, r17
    319a:	32 96       	adiw	r30, 0x02	; 2
    319c:	cf 01       	movw	r24, r30
    319e:	df 91       	pop	r29
    31a0:	cf 91       	pop	r28
    31a2:	1f 91       	pop	r17
    31a4:	0f 91       	pop	r16
    31a6:	08 95       	ret
    31a8:	00 93 38 39 	sts	0x3938, r16	; 0x803938 <__flp>
    31ac:	10 93 39 39 	sts	0x3939, r17	; 0x803939 <__flp+0x1>
    31b0:	f4 cf       	rjmp	.-24     	; 0x319a <malloc+0x6e>
    31b2:	21 15       	cp	r18, r1
    31b4:	31 05       	cpc	r19, r1
    31b6:	51 f0       	breq	.+20     	; 0x31cc <malloc+0xa0>
    31b8:	42 17       	cp	r20, r18
    31ba:	53 07       	cpc	r21, r19
    31bc:	38 f0       	brcs	.+14     	; 0x31cc <malloc+0xa0>
    31be:	a9 01       	movw	r20, r18
    31c0:	db 01       	movw	r26, r22
    31c2:	9a 01       	movw	r18, r20
    31c4:	bd 01       	movw	r22, r26
    31c6:	df 01       	movw	r26, r30
    31c8:	f8 01       	movw	r30, r16
    31ca:	c1 cf       	rjmp	.-126    	; 0x314e <malloc+0x22>
    31cc:	ef 01       	movw	r28, r30
    31ce:	f9 cf       	rjmp	.-14     	; 0x31c2 <malloc+0x96>
    31d0:	80 93 38 39 	sts	0x3938, r24	; 0x803938 <__flp>
    31d4:	90 93 39 39 	sts	0x3939, r25	; 0x803939 <__flp+0x1>
    31d8:	cd cf       	rjmp	.-102    	; 0x3174 <malloc+0x48>
    31da:	fe 01       	movw	r30, r28
    31dc:	e2 0f       	add	r30, r18
    31de:	f3 1f       	adc	r31, r19
    31e0:	81 93       	st	Z+, r24
    31e2:	91 93       	st	Z+, r25
    31e4:	22 50       	subi	r18, 0x02	; 2
    31e6:	31 09       	sbc	r19, r1
    31e8:	28 83       	st	Y, r18
    31ea:	39 83       	std	Y+1, r19	; 0x01
    31ec:	d7 cf       	rjmp	.-82     	; 0x319c <malloc+0x70>
    31ee:	20 91 36 39 	lds	r18, 0x3936	; 0x803936 <__brkval>
    31f2:	30 91 37 39 	lds	r19, 0x3937	; 0x803937 <__brkval+0x1>
    31f6:	23 2b       	or	r18, r19
    31f8:	41 f4       	brne	.+16     	; 0x320a <malloc+0xde>
    31fa:	20 91 02 38 	lds	r18, 0x3802	; 0x803802 <__malloc_heap_start>
    31fe:	30 91 03 38 	lds	r19, 0x3803	; 0x803803 <__malloc_heap_start+0x1>
    3202:	20 93 36 39 	sts	0x3936, r18	; 0x803936 <__brkval>
    3206:	30 93 37 39 	sts	0x3937, r19	; 0x803937 <__brkval+0x1>
    320a:	20 91 00 38 	lds	r18, 0x3800	; 0x803800 <__DATA_REGION_ORIGIN__>
    320e:	30 91 01 38 	lds	r19, 0x3801	; 0x803801 <__DATA_REGION_ORIGIN__+0x1>
    3212:	21 15       	cp	r18, r1
    3214:	31 05       	cpc	r19, r1
    3216:	41 f4       	brne	.+16     	; 0x3228 <malloc+0xfc>
    3218:	2d b7       	in	r18, 0x3d	; 61
    321a:	3e b7       	in	r19, 0x3e	; 62
    321c:	40 91 04 38 	lds	r20, 0x3804	; 0x803804 <__malloc_margin>
    3220:	50 91 05 38 	lds	r21, 0x3805	; 0x803805 <__malloc_margin+0x1>
    3224:	24 1b       	sub	r18, r20
    3226:	35 0b       	sbc	r19, r21
    3228:	e0 91 36 39 	lds	r30, 0x3936	; 0x803936 <__brkval>
    322c:	f0 91 37 39 	lds	r31, 0x3937	; 0x803937 <__brkval+0x1>
    3230:	e2 17       	cp	r30, r18
    3232:	f3 07       	cpc	r31, r19
    3234:	a0 f4       	brcc	.+40     	; 0x325e <malloc+0x132>
    3236:	2e 1b       	sub	r18, r30
    3238:	3f 0b       	sbc	r19, r31
    323a:	28 17       	cp	r18, r24
    323c:	39 07       	cpc	r19, r25
    323e:	78 f0       	brcs	.+30     	; 0x325e <malloc+0x132>
    3240:	ac 01       	movw	r20, r24
    3242:	4e 5f       	subi	r20, 0xFE	; 254
    3244:	5f 4f       	sbci	r21, 0xFF	; 255
    3246:	24 17       	cp	r18, r20
    3248:	35 07       	cpc	r19, r21
    324a:	48 f0       	brcs	.+18     	; 0x325e <malloc+0x132>
    324c:	4e 0f       	add	r20, r30
    324e:	5f 1f       	adc	r21, r31
    3250:	40 93 36 39 	sts	0x3936, r20	; 0x803936 <__brkval>
    3254:	50 93 37 39 	sts	0x3937, r21	; 0x803937 <__brkval+0x1>
    3258:	81 93       	st	Z+, r24
    325a:	91 93       	st	Z+, r25
    325c:	9f cf       	rjmp	.-194    	; 0x319c <malloc+0x70>
    325e:	f0 e0       	ldi	r31, 0x00	; 0
    3260:	e0 e0       	ldi	r30, 0x00	; 0
    3262:	9c cf       	rjmp	.-200    	; 0x319c <malloc+0x70>

00003264 <free>:
free():
    3264:	cf 93       	push	r28
    3266:	df 93       	push	r29
    3268:	00 97       	sbiw	r24, 0x00	; 0
    326a:	e9 f0       	breq	.+58     	; 0x32a6 <free+0x42>
    326c:	fc 01       	movw	r30, r24
    326e:	32 97       	sbiw	r30, 0x02	; 2
    3270:	12 82       	std	Z+2, r1	; 0x02
    3272:	13 82       	std	Z+3, r1	; 0x03
    3274:	a0 91 38 39 	lds	r26, 0x3938	; 0x803938 <__flp>
    3278:	b0 91 39 39 	lds	r27, 0x3939	; 0x803939 <__flp+0x1>
    327c:	ed 01       	movw	r28, r26
    327e:	30 e0       	ldi	r19, 0x00	; 0
    3280:	20 e0       	ldi	r18, 0x00	; 0
    3282:	10 97       	sbiw	r26, 0x00	; 0
    3284:	a1 f4       	brne	.+40     	; 0x32ae <free+0x4a>
    3286:	20 81       	ld	r18, Z
    3288:	31 81       	ldd	r19, Z+1	; 0x01
    328a:	82 0f       	add	r24, r18
    328c:	93 1f       	adc	r25, r19
    328e:	20 91 36 39 	lds	r18, 0x3936	; 0x803936 <__brkval>
    3292:	30 91 37 39 	lds	r19, 0x3937	; 0x803937 <__brkval+0x1>
    3296:	28 17       	cp	r18, r24
    3298:	39 07       	cpc	r19, r25
    329a:	09 f0       	breq	.+2      	; 0x329e <free+0x3a>
    329c:	61 c0       	rjmp	.+194    	; 0x3360 <free+0xfc>
    329e:	e0 93 36 39 	sts	0x3936, r30	; 0x803936 <__brkval>
    32a2:	f0 93 37 39 	sts	0x3937, r31	; 0x803937 <__brkval+0x1>
    32a6:	df 91       	pop	r29
    32a8:	cf 91       	pop	r28
    32aa:	08 95       	ret
    32ac:	ea 01       	movw	r28, r20
    32ae:	ce 17       	cp	r28, r30
    32b0:	df 07       	cpc	r29, r31
    32b2:	e8 f5       	brcc	.+122    	; 0x332e <free+0xca>
    32b4:	4a 81       	ldd	r20, Y+2	; 0x02
    32b6:	5b 81       	ldd	r21, Y+3	; 0x03
    32b8:	9e 01       	movw	r18, r28
    32ba:	41 15       	cp	r20, r1
    32bc:	51 05       	cpc	r21, r1
    32be:	b1 f7       	brne	.-20     	; 0x32ac <free+0x48>
    32c0:	e9 01       	movw	r28, r18
    32c2:	ea 83       	std	Y+2, r30	; 0x02
    32c4:	fb 83       	std	Y+3, r31	; 0x03
    32c6:	49 91       	ld	r20, Y+
    32c8:	59 91       	ld	r21, Y+
    32ca:	c4 0f       	add	r28, r20
    32cc:	d5 1f       	adc	r29, r21
    32ce:	ec 17       	cp	r30, r28
    32d0:	fd 07       	cpc	r31, r29
    32d2:	61 f4       	brne	.+24     	; 0x32ec <free+0x88>
    32d4:	80 81       	ld	r24, Z
    32d6:	91 81       	ldd	r25, Z+1	; 0x01
    32d8:	02 96       	adiw	r24, 0x02	; 2
    32da:	84 0f       	add	r24, r20
    32dc:	95 1f       	adc	r25, r21
    32de:	e9 01       	movw	r28, r18
    32e0:	88 83       	st	Y, r24
    32e2:	99 83       	std	Y+1, r25	; 0x01
    32e4:	82 81       	ldd	r24, Z+2	; 0x02
    32e6:	93 81       	ldd	r25, Z+3	; 0x03
    32e8:	8a 83       	std	Y+2, r24	; 0x02
    32ea:	9b 83       	std	Y+3, r25	; 0x03
    32ec:	f0 e0       	ldi	r31, 0x00	; 0
    32ee:	e0 e0       	ldi	r30, 0x00	; 0
    32f0:	12 96       	adiw	r26, 0x02	; 2
    32f2:	8d 91       	ld	r24, X+
    32f4:	9c 91       	ld	r25, X
    32f6:	13 97       	sbiw	r26, 0x03	; 3
    32f8:	00 97       	sbiw	r24, 0x00	; 0
    32fa:	b9 f5       	brne	.+110    	; 0x336a <free+0x106>
    32fc:	2d 91       	ld	r18, X+
    32fe:	3c 91       	ld	r19, X
    3300:	11 97       	sbiw	r26, 0x01	; 1
    3302:	cd 01       	movw	r24, r26
    3304:	02 96       	adiw	r24, 0x02	; 2
    3306:	82 0f       	add	r24, r18
    3308:	93 1f       	adc	r25, r19
    330a:	20 91 36 39 	lds	r18, 0x3936	; 0x803936 <__brkval>
    330e:	30 91 37 39 	lds	r19, 0x3937	; 0x803937 <__brkval+0x1>
    3312:	28 17       	cp	r18, r24
    3314:	39 07       	cpc	r19, r25
    3316:	39 f6       	brne	.-114    	; 0x32a6 <free+0x42>
    3318:	30 97       	sbiw	r30, 0x00	; 0
    331a:	51 f5       	brne	.+84     	; 0x3370 <free+0x10c>
    331c:	10 92 38 39 	sts	0x3938, r1	; 0x803938 <__flp>
    3320:	10 92 39 39 	sts	0x3939, r1	; 0x803939 <__flp+0x1>
    3324:	a0 93 36 39 	sts	0x3936, r26	; 0x803936 <__brkval>
    3328:	b0 93 37 39 	sts	0x3937, r27	; 0x803937 <__brkval+0x1>
    332c:	bc cf       	rjmp	.-136    	; 0x32a6 <free+0x42>
    332e:	c2 83       	std	Z+2, r28	; 0x02
    3330:	d3 83       	std	Z+3, r29	; 0x03
    3332:	40 81       	ld	r20, Z
    3334:	51 81       	ldd	r21, Z+1	; 0x01
    3336:	84 0f       	add	r24, r20
    3338:	95 1f       	adc	r25, r21
    333a:	c8 17       	cp	r28, r24
    333c:	d9 07       	cpc	r29, r25
    333e:	61 f4       	brne	.+24     	; 0x3358 <free+0xf4>
    3340:	4e 5f       	subi	r20, 0xFE	; 254
    3342:	5f 4f       	sbci	r21, 0xFF	; 255
    3344:	88 81       	ld	r24, Y
    3346:	99 81       	ldd	r25, Y+1	; 0x01
    3348:	48 0f       	add	r20, r24
    334a:	59 1f       	adc	r21, r25
    334c:	40 83       	st	Z, r20
    334e:	51 83       	std	Z+1, r21	; 0x01
    3350:	8a 81       	ldd	r24, Y+2	; 0x02
    3352:	9b 81       	ldd	r25, Y+3	; 0x03
    3354:	82 83       	std	Z+2, r24	; 0x02
    3356:	93 83       	std	Z+3, r25	; 0x03
    3358:	21 15       	cp	r18, r1
    335a:	31 05       	cpc	r19, r1
    335c:	09 f0       	breq	.+2      	; 0x3360 <free+0xfc>
    335e:	b0 cf       	rjmp	.-160    	; 0x32c0 <free+0x5c>
    3360:	e0 93 38 39 	sts	0x3938, r30	; 0x803938 <__flp>
    3364:	f0 93 39 39 	sts	0x3939, r31	; 0x803939 <__flp+0x1>
    3368:	9e cf       	rjmp	.-196    	; 0x32a6 <free+0x42>
    336a:	fd 01       	movw	r30, r26
    336c:	dc 01       	movw	r26, r24
    336e:	c0 cf       	rjmp	.-128    	; 0x32f0 <free+0x8c>
    3370:	12 82       	std	Z+2, r1	; 0x02
    3372:	13 82       	std	Z+3, r1	; 0x03
    3374:	d7 cf       	rjmp	.-82     	; 0x3324 <free+0xc0>

00003376 <strncpy>:
strncpy():
    3376:	fb 01       	movw	r30, r22
    3378:	dc 01       	movw	r26, r24
    337a:	41 50       	subi	r20, 0x01	; 1
    337c:	50 40       	sbci	r21, 0x00	; 0
    337e:	48 f0       	brcs	.+18     	; 0x3392 <strncpy+0x1c>
    3380:	01 90       	ld	r0, Z+
    3382:	0d 92       	st	X+, r0
    3384:	00 20       	and	r0, r0
    3386:	c9 f7       	brne	.-14     	; 0x337a <strncpy+0x4>
    3388:	01 c0       	rjmp	.+2      	; 0x338c <strncpy+0x16>
    338a:	1d 92       	st	X+, r1
    338c:	41 50       	subi	r20, 0x01	; 1
    338e:	50 40       	sbci	r21, 0x00	; 0
    3390:	e0 f7       	brcc	.-8      	; 0x338a <strncpy+0x14>
    3392:	08 95       	ret

00003394 <__do_global_dtors>:
__do_global_dtors():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2496
    3394:	10 e0       	ldi	r17, 0x00	; 0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2497
    3396:	c6 ea       	ldi	r28, 0xA6	; 166
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2498
    3398:	d0 e0       	ldi	r29, 0x00	; 0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2502
    339a:	03 c0       	rjmp	.+6      	; 0x33a2 <__do_global_dtors+0xe>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2508
    339c:	fe 01       	movw	r30, r28
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2509
    339e:	b1 de       	rcall	.-670    	; 0x3102 <__tablejump2__>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2510
    33a0:	21 96       	adiw	r28, 0x01	; 1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2515
    33a2:	c7 3a       	cpi	r28, 0xA7	; 167
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2516
    33a4:	d1 07       	cpc	r29, r17
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2521
    33a6:	d1 f7       	brne	.-12     	; 0x339c <__do_global_dtors+0x8>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2278
    33a8:	f8 94       	cli

000033aa <__stop_program>:
__stop_program():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2280
    33aa:	ff cf       	rjmp	.-2      	; 0x33aa <__stop_program>
